# 前言

​	本片是对一个实际应用场景的配置说明和程序设计说明。

# 1. 应用场景

​	为了实践前面几篇的内容，我们构建了如下应用场景：

| <img src="04_STM32CubeMX配置RTOS实战\1_application.jpg" style="zoom:50%;" /> |
| :----------------------------------------------------------: |

提炼出如下功能需求：

* 按键控制电机的启停和转速：长按控制启停，短按控制加减速；
* LED表示电机的转速：根据转速区间点亮不同颜色的LED；
* DHT11获取环境温湿度；
* OLED显示电机状态、速度、温湿度；

# 2. 系统框图

根据应用场景得出本次实践应用的系统框图：

| <img src="04_STM32CubeMX配置RTOS实战\2_system.jpg" style="zoom:67%;" /> |
| :----------------------------------------------------------: |

# 3. 程序流程图

## 3.1 程序结构分析

​	本次设计是基于FreeRTOS内核设计程序，因而将需求分为了下图所示的软件结构：

| <img src="04_STM32CubeMX配置RTOS实战\3_software_structure.jpg" style="zoom:67%;" /> |
| :----------------------------------------------------------: |

## 3.2 按键控制流程图

| <img src="04_STM32CubeMX配置RTOS实战\4_key_low_chart.jpg" style="zoom:50%;" /> |
| :----------------------------------------------------------: |

判断按键是短按还是长按，是通过计算按键按下和松开之间的时间差，我们认为一次短按按下的时间最长不会超过500ms，而为了更好的区分长按还是短按，我们将判定长按的时间设置为3s，即用户按着按键3s以上不放我们才认为是一次长按。

## 3.3 电机控制流程图

| <img src="04_STM32CubeMX配置RTOS实战\5_motor_flow_chart.jpg" style="zoom:50%;" /> |
| :----------------------------------------------------------: |

## 3.4 LED显示控制流程图

| <img src="04_STM32CubeMX配置RTOS实战\6_led_flow_chart.jpg" style="zoom:70%;" /> |
| :----------------------------------------------------------: |

## 3.5 DHT11读取控制流程图

| <img src="04_STM32CubeMX配置RTOS实战\7_dht11_flow_chart.jpg" style="zoom:80%;" /> |
| :----------------------------------------------------------: |

## 3.6 OLED显示流程图

| <img src="04_STM32CubeMX配置RTOS实战\8_disp_flow_chart.jpg" style="zoom:67%;" /> |
| :----------------------------------------------------------: |

# 4. STM32CubeMX的配置

​	从流程图中可以看出，我们需要4个任务，3个队列(电机发送速度给LED任务的队列和发送给显示任务的队列以及DHT11发送给显示任务的队列)，一个事件（按键发送改变电机状态的事件），还需要软件定时器2个，一个给按键消抖，一个给DHT11定时读取温湿度。我们备份第二篇里面的工程模板，改名叫做`STM32CubeMX_Config_FreeRTOS`，并且打开里面的cubemx工程，根据分析做修改。

* 任务

| ![](04_STM32CubeMX配置RTOS实战\9_task_config.jpg) |
| :-----------------------------------------------: |

​	这里我们将环境任务的优先级设置为最高，原因是我们是使用的模拟IO时序读取DHT11的数据，如果在这个过程中由于任务调度打断了时序，我们是无法得到准确的温湿度数据的。其他的任务优先级，我们认为按键信息是不能够错过的，因而把它放到次高优先级，电机任务则是在按键之后，最低的应该是显示和LED任务。

* 队列

| ![](04_STM32CubeMX配置RTOS实战\10_queue_config.jpg) |
| :-------------------------------------------------: |

​	由于我们的速度挡位值的范围很小，其实还可以设置成为`uint8_t`单位大小的队列，我们这里使用默认的。而环境的温湿度值理论上讲应该是一个浮点型，但是为了方便，我们只要了他们的整数部分，因而也保存在一个`uint16_t`型的队列中。

* 定时器

| ![](04_STM32CubeMX配置RTOS实战\11_timer_config.jpg) |
| :-------------------------------------------------: |

​	用于按键消抖的定时器我们设置成为一次性定时器，即一次周期到了之后需要手动开启定时器的下一次周期。而环境定时器我们则使用周期性的定时器，周期性的读取温湿度的值。

* 堆大小

​	当我们设计了众多的任务、队列等之后，默认的`3072kbytes`的堆肯定是不够的，我们可以根据`FreeRTOS Heap Usage`查看我们实际会用到多少的堆空间，然后去`Config parameters`中修改堆大小。

| ![](04_STM32CubeMX配置RTOS实战\12_heap_size.jpg) |
| :----------------------------------------------: |

# 5. 外设初始化

我们要配置的外设有：按键的GPIO、LED的GPIO、电机的GPIO和控制PWM输出的定时器、DHT11的GPIO、OLED的GPIO以及需要实现us级延时的定时器，配置细节我们就不多说了，我们直接配置结果：

* **按键的GPIO**

​	按键的GPIO是`PE14/PE15`：

| ![](04_STM32CubeMX配置RTOS实战\13_key_gpio_sch.jpg) |
| :-------------------------------------------------: |

我们将它们配置为双边沿触发中断的外部中断引脚：

| ![](04_STM32CubeMX配置RTOS实战\14_key_gpio_config.jpg) |
| :----------------------------------------------------: |

* **LED的GPIO**

​	LED的GPIO是`PF7/PF8/PF9`：

| ![](04_STM32CubeMX配置RTOS实战\15_led_gpio_sch.jpg) |
| :-------------------------------------------------: |

我们将它们配置为推挽输出即可：

| ![](04_STM32CubeMX配置RTOS实战\16_led_gpio_config.jpg) |
| :----------------------------------------------------: |

* **电机的GPIO**

​	电机的GPIO是`PC6/PE6`：

| ![](04_STM32CubeMX配置RTOS实战\17_motor_gpio_sch.jpg) |
| :---------------------------------------------------: |

其中`PC6`可以用PWM输出控制，而`PE6`只能是一个普通IO，我们通过改变PWM输出在`PC6`的占空比改变转速，而`PE6`我们在程序中输出常低：

| ![](04_STM32CubeMX配置RTOS实战\18_motor_gpio_cfg.jpg) |
| :---------------------------------------------------: |

* **控制PWM输出的定时器**

​	从`PC6`的配置可以看到，我们选择的是定时器3作为它的PWM输出控制定时器，我们将TIM3配置为1MHz的频率，1KHz的周期，让占空比在0~1000变化：

| <img src="04_STM32CubeMX配置RTOS实战\19_tim3_cfg.jpg" style="zoom: 80%;" /> |
| :----------------------------------------------------------: |

我们控制TIM3的占空比不需要中断和DMA，因而我们没有使能它的中断和DMA。

* **DHT11的GPIO**

​	DHT11的控制GPIO是`PF6`：

| ![](04_STM32CubeMX配置RTOS实战\20_dht11_gpio_sch.jpg) |
| :---------------------------------------------------: |

因为在控制过程中我们需要既让这个引脚有输出功能，又要有输入功能，来读取电平，而GPIO的开漏模式能够让引脚在输出一个高电平到寄存器的时候有读外部电平变化的能力，因而我们将它配置为一个开漏输出的引脚：

| ![](04_STM32CubeMX配置RTOS实战\21_dht11_gpio_cfg.jpg) |
| :---------------------------------------------------: |

* **us级延时控制的定时器**

​	us级延时主要是给DHT11使用的，我们在前面已经选择了TIM8作为HAL库的时基定时器，TIM3作为电机的控制定时器，为了避免功能冲突影响，我们这里的定时器就选择除了TIM3和TIM8以外的定时器TIM2，配置为1MHz的周期的普通定时器，通过改变周期来实验us延时：

| ![](04_STM32CubeMX配置RTOS实战\22_us_timer_cfg.jpg) |
| :-------------------------------------------------: |

* **OLED的GPIO**

​	OLED的GPIO是`PF10/PF11`：

| ![](04_STM32CubeMX配置RTOS实战\23_oled_gpio_sch.jpg) |
| :--------------------------------------------------: |

这是一个I2C控制的OLED，这两个引脚是I2C的SCL和SDA，同样在通讯过程中这两个引脚有可能会交出控制权读取外部电平，所以我们将他们都设置为开漏输出功能的引脚：

| ![](04_STM32CubeMX配置RTOS实战\24_oled_gpio_cfg.jpg) |
| :--------------------------------------------------: |

* 生成工程

​	配置好以上的外设和FREERTOS之后我们直接电机`Generate Code`生成工程，然后去打开工程。

# 6. 程序设计

​	我们的工程在面粉分析框图的时候已经说过，会分成多层，最底层是驱动层，最上层是业务层，因而需要根据那个架构来搭建我们的工程：

| ![](04_STM32CubeMX配置RTOS实战\25_project_struct.jpg) |
| :---------------------------------------------------: |

原本我们还应该有一层业务层，里面放我们的app程序，但是在cubemx生成的工程中，我们将所有的任务都放到了一个源文件`freertis.c`中实现，所以就将业务层省略了(所以有时候使用STM32CubeMX不能很好的满足设计需求，但是用于快速开发得到效果确实十分效率)。

​	鉴于STM32CubeMX生成的工程对于我们的目标程序框架有影响，因而我们将STM32CubeMX中的任务全部删掉，只保留了一个默认任务，然后在业务层中实现业务逻辑：

| ![](04_STM32CubeMX配置RTOS实战\26_new_project.jpg) |
| :------------------------------------------------: |

里面的代码可以从前面的课程中移植过来做下修改使用，比如LED、按键和OLED，而新增的电机设备和DHT11设备则需要自行设计(可以根据自己的学习进度自己设计代码验证自己的学习效果，也可以参考我们给的例程设计)。

# 7. 效果演示

