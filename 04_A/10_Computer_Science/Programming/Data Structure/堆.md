---
tags:
  - dataStructure
---
当函数执行完毕返回后，其栈帧被释放，若尝试访问原先在栈上分配的局部变量内存区域，将导致未定义行为（undefined behavior）。为解决这种生命周期受限的问题，我们需要使用堆内存。

# 什么是堆？ 

> [!NOTE] 堆：就是一块可被管理的空闲内存，可以使用 `malloc` / `free` 函数来管理它

`malloc()` 函数的工作原理是：在RAM中找到一段连续的空闲内存空间并分配给程序使用。这段空间位于程序的栈区（用于函数调用和局部变量）和数据区（用于全局变量和静态变量）之外。在典型的内存布局中，堆区通常位于数据区之后、栈区之前的区域。当调用 `malloc()` 时，堆管理器会从堆区的低地址向高地址方向分配内存，并返回分配区域的起始地址（低地址）。这与栈的增长方向（从高地址向低地址）相反。

```c
char *str;
str = malloc(100);
strcpy(str, "weidongshan");

free(str);
```

对于 FreeRTOS ，其堆内存管理（如 heap_1 到 heap_4 实现）通常是通过定义一个静态全局数组来实现堆，如 `static uint8_t ucHeap[configTOTAL_HEAP_SIZE];` ，大小由配置决定。这种方式使得嵌入式系统中的内存分配更加可控和可预测。

# 如何实现

```c
char heap_buf[1024];
int pos = 0;

void *my_malloc(int size)
{
	int old_pos = pos;
	pos += size;
	
	return &heap_buf[old_pos];
}

void my_free(void *buf)
{
	/* err */
}

int main(void)
{
	int i;
	char *buf = my_malloc(100);
	
	for (i = 0; i < 26; i++)
	{
		buf[i] = 'A' + i;
	}
	
	return 0;
}
```