---
tags:
  - dataStructure
---
# 栈是什么？

栈是一种后进先出(LIFO: Last In First Out)的数据结构。在ARM等微控制器中，栈主要用于：

1. 函数调用：**保存返回地址(LR寄存器)和局部变量**
2. 上下文切换：保存和恢复寄存器状态
3. 临时数据存储：为局部变量和临时数据分配内存空间

栈默认是从高地址向低地址生长，当我们执行PUSH操作时，栈指针(SP)减小；执行POP操作时，栈指针增大。在嵌入式系统中，栈空间通常是有限的，需要谨慎管理以避免栈溢出。

# 谁分配栈 / 如何分配栈？

```asm
__Vectors       DCD     0x20000000+0x10000
```

CPU 一上电，就会从异常向量表中把第一个数值存入到栈寄存器 `0x2000 0000` 里面。

为什么取这个数值，是因为 F103 芯片的内存基地址是 `0x2000 0000` ，结束地址是 `0x2001 0000`

在编译、链接程序的时候，我们会告诉编译器，在 `0x2000 0000` 至 `0x2001 0000` 中，前面的空间用来分配全局/静态变量，由于后面的空间没有利用到，于是我们可以把栈设置在这里，它大概率不会破坏到前面的数据空间

# C 函数会做什么？

C 函数开头：
1. 划分栈（LR，...，局部变量）
2. LR 存入栈
3. 执行代码
	- 代码中的变量也储存到栈中去

# 栈是如何运作的？

![[栈的运作.png]]

在 RTOS 中，每个任务都有自己的栈

# 栈的使用

```asm
0x08000024 B508      PUSH     {r3,lr}	// 入栈
```

![[04_A/编程/Data Structure/attachments/栈_01.png|657]]

编译调试以下程序我们发现

```c
int mymain()
{
  static volatile int s_a = 1;
  
  volatile int b;
  
  b = add_val(s_a);
  
  return 0;
}
```

| Name | Value      |
| ---- | ---------- |
| `b`  | 0x00000000 |
| `&b` | 0x2000FFF8 |

- 为什么变量 `b` 的地址这么奇怪？
- 原来 `R3` 就是变量 `b`

- `PUSH     {r3,lr}` 的作用
	- 保存 LR
	- 用 R3 来占坑，给变量 `b` 分配空间

```asm
    19:   volatile int b = 456; 
    20:    
0x08000026 F44F70E4  MOV      r0,#0x1C8		// r0 = 456
0x0800002A 9000      STR      r0,[sp,#0x00]	// r0 => [sp, #0] => [2000FFF8] 即变量 b
```

---

```asm
    15: int mymain() 
0x08000020 BD0C      POP      {r2-r3,pc}
0x08000022 0000      MOVS     r0,r0
```

- `POP      {r2-r3,pc}` 的作用
	- ![[04_A/编程/Data Structure/attachments/栈_02.png|693]]

---

> [!question] 如何估计栈的大小？
> 寻找使用局部变量最多的调用栈

---

# 栈的大小

栈的大小主要取决于：
- 局部变量
- 函数调用的深度

# 栈帧和栈有什么区别？

理解 ​​栈（Stack）​​ 和 ​​栈帧（Stack Frame）​​ 的区别以及栈帧的内容是理解函数调用和局部变量存储的关键。它们密切相关，但概念不同。

## 栈 (Stack)

​​是什么？​​ 栈是程序运行时内存中划分出来的一块 ​​**连续的、后进先出 (LIFO)** 的内存区域。

​​作用：​​
- ​**​存储函数调用信息：​**​ 当一个函数被调用时，系统会在栈上为其分配一块空间（栈帧）来存储该函数执行所需的信息。
- ​**​存储局部变量：​**​ 函数内部定义的​**​非静态局部变量​**​通常存储在栈帧中。
- ​**​传递函数参数：​**​ 在调用约定（如 `cdecl`, `stdcall`）中，部分或全部函数参数可能会通过栈传递（现代处理器也大量使用寄存器传递参数）。
- ​**​保存返回地址：​**​ 调用函数时，下一条指令的地址（返回地址）会被压入栈，以便被调用函数执行完毕后能返回到正确的位置。
- ​**​保存调用者的上下文：​**​ 在调用新函数前，可能需要将调用函数（父函数）的某些寄存器状态（如基指针 `EBP/RBP`）保存到栈上。

​​特点：​​
- ​**​自动管理：​**​ 栈空间的分配（函数调用时）和释放（函数返回时）由编译器生成的代码自动完成，程序员通常不直接管理。
- ​**​大小有限：​**​ 栈空间大小通常是固定的（在程序启动时设置或在链接时指定），如果函数调用层次太深或局部变量太大，会导致​**​栈溢出 (Stack Overflow)​**​。
- ​**​快速访问：​**​ 栈内存的分配和释放只是移动栈指针，效率非常高。
- ​**​线程私有：​**​ 在多线程程序中，每个线程通常拥有自己独立的栈。

## 栈帧 (Stack Frame)

- ​​是什么？​​ 栈帧是栈上为​**​一次特定的函数调用​**​所分配的一块连续内存区域。它包含了该函数调用执行过程中所需的所有信息。
- ​**​生命周期：​**​ 在函数被调用时创建（分配），在函数返回时销毁（释放）。
- ​**​位置：​**​ 位于栈的内部。**栈由一个个栈帧“堆积”而成。当前正在执行的函数的栈帧位于栈顶。**
- ​**​作用：​**​ 为一次函数调用提供执行环境，存储该函数调用专属的数据。

## 栈帧中可能保存的内容

一个典型的函数栈帧（具体布局因编译器、处理器架构、调用约定而异）通常包含以下部分，​**​从高地址向低地址增长​**​（栈通常向下增长）：

1. ​**​函数参数 (Function Arguments):​**​
    - 传递给被调用函数的参数值。
    - 如果参数数量少或小，可能会优先使用寄存器传递，剩余的参数或大参数（如结构体）则通过栈传递。
    - ​**​位置：​**​ 通常位于靠近调用者栈帧的底部（高地址端）。
2. ​**​返回地址 (Return Address):​**​
    - 这是​**​最关键​**​的部分之一。它保存了当被调用函数执行完毕后，应该返回到调用函数（父函数）中哪条指令继续执行的地址（即 `call` 指令之后的那条指令的地址）。
    - 由 `call` 指令自动压入栈中。
    - ​**​位置：​**​ 通常在栈帧的顶部（相对于被调用函数栈帧的起始位置，但在整个栈中是较低地址）。
3. ​**​旧的帧指针 (Old Frame Pointer / Saved `EBP/RBP`):​**​
    - 调用函数（父函数）的帧指针 (`EBP` in x86, `RBP` in x86-64) 的值。
    - 被调用函数在开始时通常会保存父函数的帧指针（`push ebp`），然后将当前栈指针 (`ESP/RSP`) 设置为新的帧指针 (`mov ebp, esp`)。
    - 这使得被调用函数可以通过固定的偏移量（相对于 `EBP/RBP`）访问自己的参数和局部变量，并且函数返回时可以方便地恢复父函数的栈帧。
    - ​**​位置：​**​ 紧跟在返回地址之后（更低地址）。
4. ​**​局部变量 (Local Variables):​**​
    - 函数内部定义的​**​非静态​**​局部变量。
    - 包括基本类型（`int`, `char`, `float`）、数组、结构体（如果不太大）等。
    - ​**​位置：​**​ 在保存的帧指针之下（更低地址）。编译器根据变量定义顺序和大小在栈帧中为它们分配空间。
5. ​**​临时存储 / 寄存器保存区 (Temporaries / Saved Registers):​**​
    - 编译器生成的用于存储中间计算结果的临时空间。
    - 根据调用约定，被调用函数（`callee`）可能需要保存某些寄存器的值（称为 `callee-saved registers` 或 `non-volatile registers`），并在返回前恢复它们，以确保调用函数（`caller`）的寄存器状态不被破坏。这些保存的寄存器值也存储在栈帧中。
    - ​**​位置：​**​ 通常在局部变量区域之下或穿插其中。

## 图示 (简化概念)

想象栈是一个向下生长的内存区域（地址递减），当前栈顶在最低地址 (`ESP/RSP` 指向这里)。

```
(高地址) <--- 栈底 (Stack Bottom)
+----------------------+ <--- 调用函数 (Caller) 的栈帧结束处 (或参数开始)
| Caller's Stack Frame |
| ...                  |
|----------------------| <--- 被调用函数(Callee) 的栈帧起始处 (通常由 `EBP/RBP` 指向)
| Argument N           | \
| ...                  |  > 函数参数 (Parameters)
| Argument 1           | /
|----------------------|
| Return Address       | <--- `call` 指令压入
|----------------------|
| Saved EBP/RBP        | <--- `push ebp/rbp` 压入 (旧的帧指针)
|----------------------| <--- EBP/RBP 现在指向这里 (当前帧指针)
| Local Variable 1     | \
| ...                  |  > 局部变量 (Local Variables)
| Local Variable M     | /
|----------------------|
| Temporary Storage    | \
| Saved Registers      | / (如果需要)
| ...                  |
|----------------------| <--- ESP/RSP 指向这里 (当前栈顶)
(低地址) <--- 栈顶 (Stack Top)
```

## 总结

- ​**​栈：​**​ 是内存中一块用于管理函数调用和局部变量的 LIFO 区域。
- ​**​栈帧：​**​ 是栈上为​**​一次特定函数调用​**​分配的内存块，包含了该调用执行所需的所有信息。
- ​**​栈帧内容：​**​ 主要包括函数参数、返回地址、保存的调用者帧指针、局部变量以及可能的临时存储和保存的寄存器值。

理解栈和栈帧对于调试（如查看调用栈）、理解内存布局、避免栈溢出以及进行底层编程至关重要。