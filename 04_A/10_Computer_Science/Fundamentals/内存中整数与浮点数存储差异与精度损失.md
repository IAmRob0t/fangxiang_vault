---
title: "内存中整数与浮点数存储差异与精度损失"
source: "https://mp.weixin.qq.com/s/LmQR0ar6GnbamOE9DhGbrQ"
author:
  - "[[微信公众平台]]"
published:
created: 2025-03-25
description: "数据存储相关内容。"
tags:
  - "clippings"
---
*2024年02月12日 22:05* *湖南*

  

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/mPZJgHsAnGAWeoz41JuwKXNhqm4CVcxbORco6KPnoTSqJul1Zo7icH8Yyib4FgWrnCBhpbQ2tYOUUf1gUg82Ig0Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

  

为什么我们代码将浮点数、整数进行强制转换，或打印输出时会出精度损失，或出错的情况？

想要搞明白这个问题，就需要了解一下整数、浮点数的存储规则。

## 1. 一、浮点数存储规则

根据国际标准IEEE（电气和电子工程协会）规定，任何一个浮点数NUM的二进制数可以写为：

**NUM = (-1) ^ S \* M \* 2 ^ E**; (S表示符号，E表示阶乘，M表示有效数字)

①当S为0时，表示一个正数；当S为1时，表示一个负数；

②M表示有效数字，1<= M <2；

③2^E表示指数

比如十进制的3.0，二进制就是0011.0 就可以写成（-1）^ 0 \* 1.1 \* 2 ^ 1

再比如十进制的-3.0，二进制就是-0011.0 就可以写成（-1）^ 1 \* 1.1 \* 2 ^ 1

而规定float类型有一个符号位（S），有8个指数位（E），和23个有效数字位（M）

double类型有一个符号位（S），有11个指数位（E），和52个有效数字位（M）

以float类型为例：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_jpg/mPZJgHsAnGC0tgsQgQubm5qOOVOZT3MLZbLwnge5dadeDUenfaBVSvCqsV8dTNud6gUGVGUBMhS8OHX8h0gicUw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

IEEE对于（有效数字）M和（指数）E有特殊的规定（以float为例）：

**1.**因为M的值一定是1<= M <2，所以它绝对可以写成1.xxxxxxx的形式，所以规定M在存储时舍去第一个1，只存储小数点之后的数字。

这样做节省了空间，以float类型为例，就可以保存23位小数信息，加上舍去的1就可以用23位来表示24个有效的信息。

**2.**对于E（指数）E是一个无符号整数所以E的取值范围为（0~ 255），但是在计数中指数是可以为负的，所以规定在存入E时，在它原本的值上加上中间数（127），在使用时减去中间数（127），这样E的真正取值范围就成了（-127~128）。

对于E还分为三种情况：

**①E不全为0，不全为1:**

这时就用正常的计算规则，E的真实值就是E的字面值减去127（中间值)，M的值要加上最前面的省去的1。

**②E全为0**

这时指数E等于1-127为真实值，M不在加上舍去的1，而是还原为0.xxxxxxxx小数。这样为了表示0，和一些很小的整数。

所以在进行浮点数与0的比较时，要注意。

**③E全为1**

当M全为0时，表示±无穷大（取决于符号位）；当M不全为1时，表示这数不是一个数（NaN）

## 2. 二、测试

代码如下：

```perl
void test(void){  float m=134.375;  char *a=(char*)&m;
  printf("0x%p:%d\n",a,*a);  printf("0x%p:%d\n",a+1,*(a+1) );  printf("0x%p:%d\n",a+2,*(a+2) );  printf("0x%p:%d\n",a+3,*(a+3) );}
```

代码输出结果：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/ju1DzqX8iaOm4tV1kkF8bT7mjKeQYUYdAqsuScLrlIwLyCorOIZPSrLuia2rzThA4dnia1PhLSfM5ATV9pNaqSEyw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

具体的计算过程如下：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_jpg/mPZJgHsAnGC0tgsQgQubm5qOOVOZT3MLaw8RYpLcpLqflWicxiatKGStj6VXNR462GPb9YGGF2aiayXmBicQ2D3LMw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

## 3. 三、精度损失

我们可以把十进制的小数部分乘以2，取整数部分作为二进制的一位，剩余小数继续乘以2，直至不存在剩余小数为止。

例如0.2可以转换为：

0.2 x 2 = 0.4 0

0.4 x 2 = 0.8 0

0.8 x 2 = 1.6 1

0.6 x 2 = 1.2 1

0.2 x 2 = 0.4 0

0.4 x 2 = 0.8 0

0.8 x 2 = 1.6 1

…

即：.0011001…

**它是一个无限循环的二进制数，这就是为什么十进制小数转换成二进制小数的时候为什么会出现精度损失的情况。**

## 4. 四、整数的存储规则

理解了浮点数的存储规则，再理解整数就很简单了。

**整数在内存中都是以补码的形式进行存储，整数有正负之分。当需存储有符号数时，用第一位来表示正（0）和负（1）。**

正数的反码和补码还是它本身，下面主要讨论下负数的反码和补码。反码是其原码除去最高符号位后其余位按位取反，补码是其反码在加上1 。

测试代码：

```cpp
void test(void){  int8_t n=-123;  uint8_t *p=(uint8_t *)&n;
  printf("%d\n",n);  printf("%d\n",*p);  }
```

输出结果：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_jpg/mPZJgHsAnGC0tgsQgQubm5qOOVOZT3MLPWLjURVrcehHbVWXa59LPacibcRNVK4Q5pRDK08w7z7icdpYCiaegD8kQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

计算过程如下：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_jpg/mPZJgHsAnGC0tgsQgQubm5qOOVOZT3MLWfMRskjZkX44FZXuwCPV6OLCxZfU6PH7yRHbcZeIhAENiaHQy4wdNow/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)