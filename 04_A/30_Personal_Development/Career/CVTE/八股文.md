# 自我介绍

面试官您好，
我是来自广东东软学院电子信息工程专业的应届本科生方向，今天我面试的岗位是嵌入式软件开发工程师（单片机方向）。
在过去的学习和实践中，我主要专注于嵌入式系统开发方向，完成了三段具有代表性的项目。
个人认为这一段经历和咱们今天聊的岗位契合度是比较高的。 
之前也看过咱们公司的职位描述和和核心业务，个人对咱们公司和这个岗位做的事都是比较感兴趣的，所以非常荣幸能够获得今天这么一个交流的机会，希望今天咱们可以沟通愉快

# C 语言

## `const` 关键字

作用：
-  `const` 的英文意思是”固定的“，用来**限定变量的值不能被修改**。
- 如果通过这个标识符修改变量的值，编译器会直接报错
- 但是仍可以改动底层内存

## `extern` 关键字

作用：
- 表示“**这个变量或函数在别的文件里定义**”
- 使其能在多个源文件之间共享访问

## `volatile` 关键字

作用：
- `volatile` 的英文意思是”易变的“
- 告诉编译器这个变量**可能被外部因素改变**（例如中断、硬件寄存器、其他线程等）。
- 这样编译器就**不会对这个变量进行优化**，每次使用都会从内存重新读取。
- 但是有的编译器很聪明，如果你使用 `volatile` 去声明了变量却不去使用它，编译器还是会将它给优化掉

## `static` 关键字

作用：
- **修饰局部变量**：延长生命周期，函数结束后变量不会被销毁，只会初始化一次。
- **修饰全局变量**：限制作用域，只在当前文件内可见。
- **修饰函数**：函数只在本文件可用，其他文件无法调用。

`static` 变量存储在那里？
- 存放在**全局数据区（静态区）**，而不是栈上。

## 数组和指针

- 数组名代表“整个一块连续的内存”，大小固定，不能重新指向别的地方。
- 指针是一个变量，里面存放地址，可以随时改变指向。
- 在函数传参时，数组会退化为指针传递。

## 函数指针和指针函数

函数指针就是**指向函数的指针变量**。
可以用它来**回调函数**或**实现函数表**。

指针函数是**返回值为指针的函数**

## 程序定义的全局变量过多会有什么问题？  

- **内存占用增加**：全局变量会常驻内存。
- **数据安全差**：任何函数都能改，容易被误改。
- **多线程不安全**：同时访问可能造成数据竞争。
- **可维护性差**：依赖太多，不好调试。
- **启动慢**：启动时要把全局变量从 Flash 拷贝到 RAM。

## C 的内存分区

- **栈（Stack）**：系统自动分配和回收，用来存放局部变量、函数参数、返回地址。
- **堆（Heap）**：程序员自己用 `malloc` / `free` 分配和释放。
- **全局 / 静态区**：放全局变量、静态变量。
- **常量区**：放字符串常量、`const` 常量等。
- **代码区**：放程序的可执行指令

# FreeRTOS

## 进程，线程

**进程（Process）**：程序运行起来的一个实例，系统会给它分配独立的内存和资源（代码区、堆、栈等）。  
**线程（Thread）**：进程里的执行单元，共享进程的资源。

在 FreeRTOS 里，其实线程就叫 **任务（Task）**。

**主要区别**：

| 对比项  | 进程            | 线程（任务）              |
| :--- | :------------ | :------------------ |
| 内存   | 各自独立          | 同进程共享               |
| 开销   | 大             | 小                   |
| 通信   | 要用管道、消息队列等IPC | 可直接共享内存或用RTOS提供的队列等 |
| 稳定性  | 崩一个不影响其他      | 崩一个可能拖整个程序          |
| 调度单位 | 操作系统分配资源      | CPU调度执行的最小单位        |

一句话记：**进程更独立、线程更高效。**

## 多进程，多线程

- **多进程**：系统里可以同时跑多个进程，彼此独立，稳定但通信麻烦。
- **多线程**：一个进程里可以同时跑多个线程，共享资源，通信快但容易互相影响。

FreeRTOS 本质上就是一个**多线程（多任务）系统**。

一句话记：  
**多进程重稳定，多线程重效率。**

## 线程安全

==如何保证线程的安全==

线程安全就是防止多个任务同时改同一份数据。

常见方法：
1. **加锁（Mutex）**：访问共享资源前上锁。
2. **进入临界区（Critical Section）**：关中断或挂起调度器，保证原子操作......
3. **使用RTOS通信机制**：用队列、任务通知、事件组传数据，而不是直接用全局变量。

一句话记：  
**访问共享资源要加锁，通信尽量走RTOS接口。**

## 线程的状态（任务状态）

FreeRTOS 的任务主要有四种状态：
- **运行态（Running）**：当前占着CPU执行。
- **就绪态（Ready）**：可以执行但还没轮到。
- **阻塞态（Blocked）**：在等事件或延时。
- **挂起态（Suspended）**：被手动暂停。

## 多线程优缺点

**优点：**
- 通信快，共享内存效率高。
- 创建、切换成本低。
- 占资源少。

**缺点：**
- 稳定性差，一个任务崩可能拖系统；
- 同步麻烦，否则容易出“线程打架”。
- 调试难度比单线程高。

一句话记：  
**多线程快，但容易乱。**

## 常见通信方式

在 FreeRTOS 里主要有几种常见的线程（任务）通信机制👇：
1. **队列（Queue）**：最常用！任务或中断之间传数据，FIFO方式，线程安全。
2. **信号量（Semaphore）**：用来同步或控制访问资源，比如“等一个事件”。
3. **互斥量（Mutex）**：防止资源被同时访问，带“优先级继承”，防止优先级反转。
4. **事件组（Event Group）**：任务可以等多个事件同时发生。
5. **任务通知（Task Notification）**：最轻量，直接任务对任务通知。

一句话记：  
**Queue 传数据，Semaphore 同步，Mutex 保护资源，Event Group 多事件同步，Task Notify 最轻量。**

![[FreeRTOS内核对象选择决策]]

## FreeRTOS 的 API

| 功能      | 常用API                                                 |
| :------ | :---------------------------------------------------- |
| 创建/删除任务 | `xTaskCreate()` / `vTaskDelete()`                     |
| 延时      | `vTaskDelay()` / `vTaskDelayUntil()`                  |
| 切换任务    | `taskYIELD()`                                         |
| 启动调度器   | `vTaskStartScheduler()`                               |
| 队列操作    | `xQueueCreate()` / `xQueueSend()` / `xQueueReceive()` |
| 信号量/互斥量 | `xSemaphoreGive()` / `xSemaphoreTake()`               |
| 任务通知    | `xTaskNotifyGive()` / `ulTaskNotifyTake()`            |

## 任务调度

==FreeRTOS 源码如何实现任务调度：==


FreeRTOS 的调度是**优先级抢占 + 时间片轮转**的结合：

- 高优先级任务可以**立即抢占**低优先级任务；
- 同优先级任务**轮流执行**，保证公平；
- 没有任务可运行时，会运行**空闲任务**（一般用来回收资源、做低功耗）。
	- 举个例子，比如有个任务 A，当它在执行中调用 `vTaskDelete()` 自杀后，尸体（栈空间、TCB 结构体）谁来清理？就是空闲任务嘛
- FreeRTOS 的核心链表结构有几个：
    1. `pxReadyTasksLists`：这是一个优先级数组，每个优先级一个链表，放“就绪状态”的任务。
    2. `xPendingReadyList`：专门处理**中断唤醒的任务**。
    3. `xDelayedTaskList1 / xDelayedTaskList2`：放那些**因延时或阻塞**的任务，比如调用了 `vTaskDelay()` 的。

## 任务切换

==FreeRTOS 如何实现任务切换：==

任务切换其实就是**保存当前任务上下文、恢复下一个任务上下文**：
1. 创建任务时，会先在栈里构建一个“初始上下文”（包括寄存器、程序计数器等）。
2. 任务切换时，先把当前任务的寄存器压栈保存。
	- 寄存器保存到栈里的那一块空间其实就是我们说的**任务上下文栈帧**。
3. 把栈指针存进该任务的 **TCB（任务控制块）**。
4. 取出下一个任务的 TCB 里的栈指针，恢复寄存器、PC。
5. 最后跳转回下一个任务的执行位置。

## 实时性

==FreeRTOS 是怎么保证实时性的？==

FreeRTOS 的实时性靠的是**确定性调度**：
- 它采用**优先级抢占机制**，高优先级的任务可以随时打断低优先级的任务执行，确保关键任务能第一时间响应。  
- 另外它的**中断延迟很低**，中断执行完就会马上触发调度。我在项目里也注意到，只要优先级分配合理，任务响应都是非常稳定的。  
- 同优先级的任务会用**时间片轮转**，这样就不会出现某个任务一直占着CPU的情况。 

整体来说，FreeRTOS 的运行是**可预测的**，也就是我们能估算出任务的执行和响应时间，这就是所谓的实时性。

## 互斥量（锁）

互斥量是一种**带优先级继承的二进制信号量**，主要用于任务间资源保护。

==特点：==
- 只能任务用（中断不能用）。
- 支持**递归互斥锁**，同一个任务可以多次获取同一个锁。
- FreeRTOS 的互斥锁谁上锁、谁释放只是约定。
- 它的**优先级继承**机制可以避免优先级反转问题

---

==互斥量有哪些种类：==

- **普通互斥量（Mutex）**
    - 用 `xSemaphoreCreateMutex()` 创建。
    - 只能任务使用（中断里不能用）。
    - 带 **优先级继承机制**，防止优先级反转。  
        ✅ 最常用于任务之间保护共享资源，比如串口、I²C总线等。
- **递归互斥量（Recursive Mutex）**
    - 用 `xSemaphoreCreateRecursiveMutex()` 创建。
    - 同一个任务可以多次获取同一把锁，不会死锁。
    - 每获取一次要释放一次（成对出现）。  
        ✅ 适合函数嵌套时反复访问同一资源的场景。

## 死锁

==死锁是怎么产生的？==

举个简单例子：
- 任务A拿了锁M1又要M2；
- 任务B拿了锁M2又要M1；
- 双方互相等待 → 卡死。

---

==解决：==
1. **优先级继承**：  
    当高优先级任务等待低优先级任务释放锁时，系统会暂时提升低优先级任务的优先级，让它先跑完再释放资源。
2. **优先级天花板协议**：  
    访问资源前任务先“提升到固定优先级”，防止多锁嵌套导致死锁。

# 基于 FreeRTOS 的智能家居系统

## 讲讲项目

我觉得最能代表我能力的项目是**基于 FreeRTOS 的智能家居系统**。  

这个项目用 STM32 + FreeRTOS 做多任务调度，整合了 DHT11 温湿度传感器、ESP8266 WiFi、OLED 显示和按键输入，可以用手机远程控制风扇和 LED。

项目的亮点是我用**队列代替环形缓冲区**做任务间通信，避免同步问题；DHT11 的读取我用**中断+二进制信号量**同步任务，保证实时性和稳定性。

这个项目让我真正理解了多任务调度、任务通信和中断同步这些核心技术。

## 为什么选择 FreeRTOS？

> 轻量、好移植，资源少也能跑。可以用任务、队列、信号量这些机制同时处理多个功能，比轮询效率高。

## 项目来源？怎么学的？

这是基于一个开源智能家居平台改进的，我做了功能扩展和调试优化。  

增加了网络时间同步、任务通信优化等。  

---

我主要参考官方文档、官方例程和视频教程。  

先跑通基础功能，再自己调整任务结构、优先级和模块划分。  

还查手册和论坛理解底层任务切换，比如栈帧保存、寄存器恢复。  
这样遇到中断或任务切换问题时，能快速定位原因。

## 学项目是因为 兴趣/毕设 ？

主要是因为兴趣。  

我对嵌入式系统和操作系统很感兴趣，所以做这个项目不仅是跑通例子，而是想理解任务调度和系统实时性。

也因此后来尝试自己写了一个简化版 RTOS 内核。

## 困难？怎么解决？

- **DHT11 时序问题**：读取耗时 3.3ms，同优先级任务 1ms 轮转可能被打断导致失败。  
    **解决**：读取时关闭调度或提高任务优先级，把时序处理放到中断里，EXTI9_5 优先级设高，USART3 设低。
- **中断优先级混乱**：  
    **解决**：统一 NVIC 抢占/子优先级策略，“抢占优先级决定是否打断，同级用子优先级排先后”。

## 优化

==有什么可以优化的==

- UART 收发用 DMA + 双缓冲，降低 CPU 占用与中断开销。
- OLED 独立任务+消息聚合，减少频繁刷新带来的总线占用。

## 多少个任务

这个项目主要使用了 3 个任务：

1. `SmartHomeTask`：智能家居的主任务 ，负责整个系统的运行和控制
2. `defaultTask`：系统默认的空闲任务
3. `GetNetTime`：负责获取和显示网络时间的任务

## 任务的优先级？

> 传感器采集 > WiFi 通信 > 显示更新 > 按键处理，优先级从高到低。

## 任务之间通信？

> 用队列传数据，比如传感器任务把数据放进队列，显示任务再从队列取出显示，线程间就不会互相卡住。

## WiFi 模块通信？

> 通过 UART 接口用 AT 指令控制 ESP8266，主要用指令连接热点、建立 TCP 连接、收发数据。

## OLED 显示逻辑？

> 通过 I2C 接口刷新数据，每次从队列里拿最新的传感器数据，再统一在显示任务里更新屏幕。

---

## 如何保证实时性？

> 用任务优先级来保证关键任务（比如传感器采集）先执行；而显示或网络通信这种非实时任务优先级低一点。

## 中断？

> 有，比如按键触发中断和DHT11的中断读取，在中断里发信号量通知主任务处理，不在中断里做耗时操作。

## I2C？

OLED（SSD1306）通过 I2C 驱动：
- 原因：占用引脚少，硬件支持好，速率够用，协议简单，方便挂其他设备；比 SPI 易于扩展。
- 设计：OLED 专属任务，其他任务只发显示请求，减少总线争用。

# 自己写 RTOS

## 讲讲项目

这个项目是我为了更深入理解 RTOS 内部原理而做的个人项目。  
我从零开始，在 ARM Cortex-M3 架构上写了一个迷你实时操作系统内核。

它主要实现了两部分核心功能：
1. **任务管理**：支持任务创建、启动和上下文切换。
2. **调度机制**：用 SysTick 定时器实现了简单的时间片轮转调度。

我没有依赖库，完全用 C 加一点汇编，根据 ARM 的调用规范和异常机制，手动管理任务栈帧和上下文切换（主要用 `PendSV`）。  

为了验证稳定性，我写了几个测试任务，比如不同频率闪烁的 LED、串口打印日志，跑了 72 小时稳定测试，都没出问题。

## 项目来源？怎么学的？

这是一个 自我驱动的学习型项目 。在之前使用 FreeRTOS 的项目中，我熟悉了它的 API 和多任务编程范式。但我更好奇的是： `vTaskDelay` 是如何让出 CPU 的？任务切换时，寄存器和局部变量是如何保存和恢复的？

为了解答这些问题，我决定自己动手写一个最简化的内核。所以，这个项目的“来源”是对技术底层的好奇心。

---

1. 基础准备 ：首先，我研究了 ARM 官方手册，也参考了一些相关的视频教程
2. 搭建框架 ：从最简单的裸机模板开始，先能点亮 LED、打印串口。
3. 分步实现 ：
    - 理解任务上下文（寄存器）怎么保存。
	- 写任务创建函数，初始化任务栈和 TCB。
	- 实现调度器，用 SysTick 触发 PendSV 完成任务切换。
4. 调试验证 ：用串口打印切换日志、LED 闪烁频率来验证调度是否正常。

## 学项目是因为 兴趣/毕设 ？

完全是出于兴趣。  

我一直对操作系统底层、特别是任务调度这部分很好奇，想从原理上搞懂它是怎么运行的，而不仅仅停留在用 FreeRTOS 的层面。

## 困难？怎么解决？

最大的坑是**上下文切换**，特别是**第一次启动任务**和**任务之间切换**是不一样的。

一开始，我在 `PendSV` 写的切换代码能在任务之间切换，但从 `main()` 启动第一个任务时会直接 `HardFault`。

后来我发现，第一次启动时 CPU 还在线程模式，栈环境不一样，不能直接用普通切换逻辑。  

所以我在启动调度器时做了特殊处理：  
手动把 PSP（进程栈指针）切到第一个任务的栈顶，然后通过 SVC 或直接改控制寄存器进入任务环境。  

## 优化？

目前的内核算是一个框架，还有很多可以扩展的方向：
1. **调度算法**：现在是时间片轮转，可以做成基于优先级的抢占式调度。
2. **同步机制**：增加信号量、互斥锁、消息队列等。
3. **内存管理**：做个内存池或简单的动态分配机制。
4. **系统调用**：用 SVC 做用户态/内核态分离，让结构更像真实 OS。
5. **低功耗优化**：比如 ` Tickless Idle` 模式，空闲时让 CPU 睡眠。

## 多少个任务？

这个项目是做 RTOS 内核的，所以线程数不固定。  
不过在测试时，我创建了三个任务：

- **任务 1**：每 200ms 翻转 LED1。
- **任务 2**：每 500ms 翻转 LED2。
- **任务 3**：每 1000ms 打印任务状态。

通过观察 LED 闪烁和串口输出，就能验证调度是否准确、切换是否稳定。

## I2C 

在我 自己写的这个 RTOS 内核项目 中， 没有直接用到 I2C 。不过，在我之前的 FreeRTOS 智能家居项目 中，我确实用到了 I2C 来连接 OLED 显示屏。

# 通信协议与外设总线

|     协议     |           线数           |  通信方式  |          速率           |    传输距离    |  主从结构   | 优点            | 缺点             | 常见用途          | 选择建议       |
| :--------: | :--------------------: | :----: | :-------------------: | :--------: | :-----: | :------------ | :------------- | :------------ | :--------- |
|  **I²C**   |     2 根线（SCL、SDA）      | 同步、半双工 |    中等（100kHz～1MHz）    | 短距离（几十厘米）  |   有主从   | 接线少，可多从机，支持寻址 | 速率较慢，抗干扰一般     | 传感器通信、EEPROM  | 模块多、接线少时首选 |
|  **UART**  |      2 根线（TX、RX）       | 异步、全双工 | 中等（常见 9600～115200bps） |   中等（几米）   |   点对点   | 简单易用、软件支持多    | 不能多机通信，需要匹配波特率 | 模块通信、调试输出     | 点对点、短距通信   |
|  **SPI**   | 4 根线（SCK、MOSI、MISO、CS） | 同步、全双工 |    高速（几MHz～几十MHz）     | 短距离（PCB 内） |   主从    | 速率高、协议简单、全双工  | 线多、不适合多从机      | Flash、显示屏、ADC | 要高速传输、在板内用 |
| **RS-485** |      2 根线（A、B 差分）      | 异步、半双工 |     中等（最高约10Mbps）     |  远距离（上千米）  | 多主多从可实现 | 抗干扰强、远距离传输    | 只支持半双工         | 工业通信、PLC      | 长距离、多节点场合  |

项目 2：
- USART1 ：调试串口 (115200 波特率)
- USART3 ：WiFi 模块通信串口 (115200 波特率)
- IIC：与OLED显示屏通信

项目 3：
- 使用USART1外设

## I²C（IIC）

### 工作原理

- 是一种用于在数字电路中进行短距离通信的协议
- 启动通信：主设备将 SCL 保持高电平的同时，将 SDA 从高电平拉低，形成起始信号。
- 停止通信：主设备将 SCL 保持高电平的同时，将 SDA 从低电平拉到高电平， 形成停止信号。

### 主从

==I2C 是否有主从之分？如何在多从机场景下选中要通信的从机？==

- 有主从之分
- 主机发起传输并在地址帧里指定目标从机地址，被选中的从机会响应 ACK （确认）

### 特点

- 支持多主多从
- 只需两根线
- 速度比 SPI 慢且需要上拉电阻

### 时序

主设备 SCL 为高电平时，SDA 从高电平切换到低电平，表明传输开始；主设备发送目标设备的 7 位地址（有时是 10 位地址，根据需要），最低位用 1、0 表示读或写；接收设备在成功接收地址后发送应答位（ACK），拉低 SDA 电平来发送 ACK，之后进行数据传输；通信结束时，主设备 SCL 为高电平时，SDA 从低电平切换到高电平。

### 几根线

==I2C 总线有几根线？各自作用是什么？==

- 两根：SCL（时钟）和 SDA（数据）
- 另外物理上还要求上拉电阻。

### 排查问题

==如果打印日志，如何根据日志排查 I2C 驱动问题？==

- 看是 NACK（否定确认） 还是超时
- 地址是否正确
- 是否多主冲突
- SCL/SDA 是否被拉低长期占用
- 按这些点一步步排查。

## UART / 串口

### 工作原理

- 串口通常使用是异步，全双工
- 串口通信速率不是特别快，最快也就是几 M bps，再快容易出问题
- STM32F10X 系列 串口 1 2 3 既支持同步通信业支持异步通信，但是通常开发使用异步通信。

UART 通信是一种用于串行数据传输的异步通信协议，通常用于将数据从一个设备传输到另一个设备。

### 串口帧

==串口帧的格式有哪些类型（数据位长度、校验位、停止位等），它们的区别是什么？==

- 常见格式像 8N1（8 数据位、无校验、1 停止位）
- 或 7E1（7 位、偶校验、1 停止位）
- 区别在传输的数据宽度和错误检测能力。

### 正确传输

==如何确保串口每个数据位正确传输？==

靠双方波特率匹配、在位中点采样并留出时钟容差，再用校验/重传检测错误。

### 校验方式

==串口常用的校验方式有哪些？==

常见是奇/偶校验，复杂点的有校验和或 CRC（后两者通常用于更长帧或更强校验）。

### 单工、半双工全双工

==串口是单工、半双工还是全双工？各自原理和区别是什么？==

- 全双工（TX/RX 两线独立）
- 半双工用一线双向切换，单工则只有一个方向发送。

### GPIO 模拟串口

==假设串口不够用，如何用 GPIO 模拟串口（软件串口）？==

- 可以用 Keil V5 自带的串口模拟器先模拟输出，我在做项目时上机前一般都会先这么做。
- 实际硬件上也能用 GPIO 模拟串口，就是要靠定时精度来保证每个位的时序。

## 波特率

==概念是什么？==

波特率就是每秒传输多少符号/位（对 UART 来说通常等同于比特/秒）。

==常用波特率有哪些及其适用场景？==

- 115200（常用于调试和速度要求高）
- 9600（兼容性好、抗干扰强且低速设备常用）

# 中断

## 基础概念

==什么是中断？中断的优点和缺点分别是什么？==

- 中断就是外设或事件打断 CPU 正常执行去处理紧急事
- 优点是响应快、效率高
- 缺点是增加复杂性和上下文切换开销

## 软/硬中断

==软中断（软件触发）和硬中断（外设/硬件触发）的区别？==

- 软中断是 CPU 或软件写寄存器触发的，中断源是程序；
- 硬中断来自外设/外部引脚、由硬件产生。

==硬中断和软中断哪个可以被屏蔽？==

- 软中断
- 硬中断得看优先级的情况

## 中断优先级

==什么是中断优先级？NVIC（或类似中断控制器）如何管理中断优先级与嵌套？==

- 中断优先级决定谁先被处理
- NVIC 用优先级字段决定可抢占性，优先级高的可以打断低优先级中断实现嵌套。

## 响应过程

==中断的响应过程是怎样的？==

- 保存必要寄存器/PC
- 跳到中断向量执行 ISR
- 结束后恢复上下文继续原程序

## 函数编写

==写中断函数需要满足什么要求？==

- 程序要短小
- 避免阻塞
- 并尽量把重工作交给任务/线程。

==中断里能否有返回值和传参？如何在中断与线程/任务间传递数据？==

- 不能
- 数据用全局变量/环形缓冲/消息队列
- 或通过给任务发信号/释放信号量来传递。

## 注意事项

==使用中断有哪些注意事项？==

- 避免长时间阻塞
- 不能调用会睡眠的 API
- 注意共享数据的互斥

# 存储与内存

## SRAM / DRAM

==SRAM 和 DRAM 的区别是什么？==

- SRAM 用触发器单元存储，速度快无需刷新但成本高
- DRAM 用电容存储需周期性刷新，密度高但速度和功耗相对差。

## 大小端

==大端与小端的区别是什么？常见的判断方法？==

- 大端是高位字节放低地址
- 小端是低位字节放低地址
- 判断可用一个 `int=0x01020304`
- 然后以字节指针读第 0 个字节看是 0x01 还是 0x04。

## 优化内存

==如何优化嵌入式程序的内存使用？==

- 优先静态分配
- 减少堆使用
- 用合适宽度的类型
- 复用缓冲区
- 放常量到 Flash

# GPIO（通用输入输出）

## 常见模式

==GPIO 常见模式有哪些？==

- 输入 4 种 : 模拟输入 浮空输入 上拉输入 下拉输入
- 输出 4 种：通用开漏 通用推挽 复用开漏 复用推挽

## 外设配置

==GPIO 在外设复用中如何配置（引脚复用/AF）？==

- 通过芯片的引脚复用寄存器把该引脚切到对应的外设功能（AF）
- 同时设置速率/上拉下拉/驱动强度。

## 终端配置/去抖

==GPIO 中断（外部中断/EXTI）触发配置与去抖动方案？==

- 可配置为上升/下降/双边沿触发
- 去抖动用硬件 RC 滤波
- 外设去抖或软件延时/计数确认。

# DMA（直接存储器访问）

==DMA 的工作原理是什么？==

DMA 让外设和内存直接搬数据，不走 CPU，配置源地址、目的地址和长度后硬件自动传输并在完成时通知 CPU。

==DMA 的主要特点==

减轻 CPU 负担、传输高效还可支持循环模式和半完成中断，但需注意缓存一致性和地址对齐问题。

# 数据结构

## 堆

==堆存的是什么？==

堆用来动态分配内存，存放运行时按需分配的对象或缓冲区。

==如何扩展堆的大小？==

- 在裸机常通过链接脚本调整堆与栈边界
- 或把外部 RAM（如 PSRAM）映射加入堆空间
- 注意不能超出物理 RAM。

## 树

==二叉树遍历实现思路==

最直观的是递归：前序（根→左→右）、中序（左→根→右）、后序（左→右→根）；也可用显式栈做非递归遍历。

## 链表

- 如何判断一个链表有环？

