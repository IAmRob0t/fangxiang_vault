---
tags:
  - HAL
---
# I2C 程序层次

## 1. 硬件原理图

[[06_GPIO 中断#使用 OLED 进行调试]]

## 2. 硬件框图

要操作 OLED，需要理解硬件框图：

![[HAL快速入门与项目实战.pdf#page=90&rect=111,132,529,312|HAL快速入门与项目实战, p.90]]

STM32 上的程序通过 I2C 控制器读写 LCD 控制器芯片 SSD1306，通过配置 SSD1306 进而操作屏幕。当初始化成功后，程序就可以往 SSD1306 内部的 GDDRAM（显存）写入数据，从而控制屏幕的显示。

## 3. 软件层次

要在 OLED 上显示字符串，涉及这几个层次的程序：
1. 应用程序：我来决定“在哪个位置、显示什么字符”
2. 库函数 (字符/图片显示)：我收集了字符点阵，知道发送点阵数据才能显示字符
3. OLED (SSD1306) 取出程序：我知道发送什么 I2C 数据（先设置地址、再发送数据），才能把点阵数据写入显存
4. I2C 控制器驱动 (HAL)：我可以发送 I2C 数据

| 应用程序                 |
| -------------------- |
| 库函数（字符 / 图片显示）       |
| OLED (SSD1306) 驱动程序  |
| STM32 I2C 控制器驱动（HAL） |

# I2C 协议

## 1. I2C 总线的概念

I2C(Inter-Integrated Circuit，又称 IIC)总线是一种由 PHILIPS 公司开发的串行总线，用于连接微控制器及其外围设备，它具有如下特点：
- 只有两条总线线路：一条串行数据线(SDA)，一条串行时钟线(SCL)。
- 每个连接到总线的器件都可以使用软件根据它的惟一的地址来识别。
- 传输数据的设备间是简单的主/从关系。
- 主机可以用作主机发送器或主机接收器。
- 它是一个真正的多主机总线，两个或多个主机同时发起数据传输时，可以通过冲突检测和仲裁来防止数据被破坏。
- 串行的 8 位双向数据传输，位速率在标准模式下可达 100kbit/s，在快速模式下可达 400kbit/s，在高速模式下可达 3.4Mbit/s。
- 片上的滤波器可以增加抗干扰功能，保证数据的完整。
- 连接到同一总线上的 IC 数量只受到总线的最大电容 400pF 的限制。

下图是一条 I2C 总线上多个设备相连的例子。

![[HAL快速入门与项目实战.pdf#page=92&rect=149,434,446,519|HAL快速入门与项目实战, p.92]]

先说明一些术语，如下表所示。
- 发送器：发送数据到总线的器件
- 接收器：从总线接收数据的器件
- 主机：发起/停止数据传输、提供时钟信号的器件
- 从机：被主机寻址的器件
- 多主机：可以有多个主机试图去控制总线，但是不会破坏数据
- 仲裁：当多个主机试图去控制总线时，通过仲裁可以使得只有一个主机获得总线控制权，并且它传输的信息不被破坏
- 同步：多个器件同步时钟信号的过程

## 2. I2C 总线的形象类比

在讲解协议细节前，先使用生活示例形象理解 I2C 协议：体育老师可以把球发给学生，也可以把球从学生中接过来。

依照这个简单的例子，可以引入 IIC 的传输协议：
- 老师说开始了，表示开始信号 (start)
- 老师提醒某个学生要发球，表示发送地址和方向 (address/read/write)
- 老师发球/接球，表示数据的传输
- 接到球要回应：回应信号 (ACK）
- 老师说结束，表示 IIC 传输结束 (P)

## 3. I2C 总线的信号类型

I2C 总线在传送数据过程中共有三种类型信号：开始信号、结束信号和响应信号。

- 开始信号 (S)：SCL 为高电平时，SDA 由高电平向低电平跳变，开始传送数据。
- 结束信号 (P)：SCL 为低电平时，SDA 由低电平向高电平跳变，结束传送数据。
- 响应信号 (ACK)：接收器在接收到 8 位数据后，在第 9 个时钟周期，拉低 SDA 电平。

它们的波形如图所示：

![[HAL快速入门与项目实战.pdf#page=93&rect=143,101,450,327|HAL快速入门与项目实战, p.93]]

SDA 上传输的数据必须在 SCL 为高电平期间保持稳定，SDA 上的数据只能在 SCL 为低电平期间变化，如图所示。

![[HAL快速入门与项目实战.pdf#page=94&rect=158,666,439,770|HAL快速入门与项目实战, p.94]]

## 4. I2C 总线的数据传输格式

发送到 SDA 线上的每个字节必须是 8 位的，每次传输可以发送的字节数量不受限制。每个字节后必须跟一个响应位。首先传输的是数据的最高位 (MSB)。如果从机要完成一些其他功能后 (例如一个内部中断服务程序) 才能继续接收或发送下一个字节，从机可以拉低 SCL 迫使主机进入等待状态。当从机准备好接收下一个数据并释放 SCL 后，数据传输继续。如果主机在传输数据期间也需要完成一些其他功能 (例如一个内部中断服务程序) 也可以拉低 SCL 以占住总线。

启动一个传输时，主机先发出 S 信号，然后发出 8 位数据。这 8 位数据中前 7 位为从机的地址，第 8 位表示传输的方向 (0 表示写操作，1 表示读操作)。被选中的从机发出响应信号。紧接着传输一系列字节及其响应位。最后，主机发出 P 信号结束本次传输。

下图是几种 I2C 总线上数据传输的格式。

![[HAL快速入门与项目实战.pdf#page=94&rect=90,228,497,501|HAL快速入门与项目实战, p.94]]

并非每传输 8 位数据之后，都会有 ACK 信号。有以下 3 种例外：

1. 当从机不能响应从机地址时 (例如它正忙于其他事而无法响应 I2C 总线的操作，或者这个地址没有对应的从机)，在第 9 个 SCL 周期内 SDA 线没有被拉低，即没有 ACK 信号。
   这时，主机发出一个 P 信号终止传输或者重新发出一个 S 信号开始新的传输。
2. 如果从机接收器在传输过程中，不能接收更多的数据时，它也不会发出 ACK 信号。这样，主机就可以意识到这点，从而发出一个 P 信号终止传输或者重新发出一个 S 信号开始新的传输。
3. 主机接收器在接收到最后一个字节后，也不会发出 ACK 信号。于是，从机发送器释放 SDA 线，以允许主机发出 P 信号结束传输。

# STM32 I2C 硬件结构

## 1. 硬件框图

![[STM32F103xx参考手册(英文原版).pdf#page=755&rect=122,311,531,758|STM32F103xx参考手册(英文原版), p.755]]

## 2. 操作方法

在 I2C 传输里，有 2 个角色：Master、Slave。我们常用 Master，它主动发起传输、产生时钟信号。

对于 STM32，如何使用 I2C Master？

- 配置 I2C_CR2 寄存器（Control Register）：配置时钟源
- 配置 I2C_CCR 寄存器（Clock Control Register）：配置 SCL 高、低电平的时长
- 配置 I2C_TRISE：发现 SCL 上升沿后，再等多少时间才去采样 SCL 数据
- 配置 I2C_CR1 寄存器：使能 I2C 控制器
- 设置 I2C_CR1 寄存器的 START 位：发出 Start 信号

接下来，就可以通过查询方式或是中断方式进行数据传输了。

发送数据：

![[STM32F103xx参考手册(英文原版).pdf#page=760&rect=66,398,530,672|STM32F103xx参考手册(英文原版), p.760]]

接收数据：

![[STM32F103xx参考手册(英文原版).pdf#page=761&rect=63,359,531,626|STM32F103xx参考手册(英文原版), p.761]]

# I2C HAL 编程

## 1. STM32CubeMX 配置

OLED 屏幕使用 I2C1 通道，I2C1 使用 PB6、PB7 作为 SCL、SDA 引脚，配置如下：

![[HAL快速入门与项目实战.pdf#page=98&rect=106,515,489,735|HAL快速入门与项目实战, p.98]]

## 2. 查询方式函数说明

本节程序源码为“0801_i2c_poll”，在“0706_uart_stdio”的基础上修改得来。

### 2.1. Master 模式函数

使用查询方式写 I2C 设备、读 I2C 设备函数原型如下：

```c
HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout);

HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout);
```

参数说明：

| 参数                        | 说明                                                                  |
| ------------------------- | ------------------------------------------------------------------- |
| `I2C_HandleTypeDef *hi2c` | 使用哪个 I2C 控制器                                                        |
| `uint16_t DevAddress`     | 设备地址，需要把 7 位地址左移 1 位                                                |
| `uint8_t *pData`          | 数据 buffer                                                           |
| `uint16_t Size`           | 数据个数                                                                |
| `uint32_t Timeout`        | 超时时间，单位是 Tick，一般是 1ms                                               |
| 返回值                       | `HAL_OK`：成功<br>`HAL_ERROR`：错误<br>`HAL_BUSY`：总线忙<br>`HAL_TIMEOUT`：超时 |

### 2.2. MEM 模式函数

MEM 模式只是软件上的概念，仍然是作为 Master 读写数据。

上述函数只能发起单向的数据传输，但是在实际编程中，比如要“读存储地址 addr 上的数值”，涉及 2 个方向的数据传输：要向 I2C 设备发起写操作把“存储地址 addr”发给他，然后向 I2C 设备发起读操作得到数值。

还有一种情况，“ 把数值 `val` 写到存储地址 `addr` ” 上，使用“`HAL_I2C_Master_Transmit`”函数时，需要在数据 buffer 里填入 `addr` 和 `val`，不太直观。

这时可以使用下面的函数：

```c
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout);

HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout);
```

参数说明： 

| 参数                        | 说明                                                                                                                                            |
| ------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| `I2C_HandleTypeDef *hi2c` | 使用哪个 I2C 控制器                                                                                                                                  |
| `uint16_t DevAddress`     | 设备地址，需要把 7 位地址左移 1 位                                                                                                                          |
| `uint16_t MemAddress`     | 存储地址，即 I2C 设备上的寄存器地址或存储地址                                                                                                                     |
| `uint16_t MemAddSize`     | 存储地址的大小，有 2 种取值：<br>`I2C_MEMADD_SIZE_8BIT`：存储地址为 1 字节，就是 `MemAddress` 的低字节<br>`I2C_MEMADD_SIZE_16BIT`：存储地址为 2 字节，先发送 `MemAddress` 的高字节，再发送低字节 |
| `uint8_t *pData`          | 数据 buffer                                                                                                                                     |
| `uint16_t Size`           | 数据个数                                                                                                                                          |
| `uint32_t Timeout`        | 超时时间，单位是 Tick，一般是 1ms                                                                                                                         |
| 返回值                       | `HAL_OK`：成功<br>`HAL_ERROR`：错误<br>`HAL_BUSY`：总线忙<br>`HAL_TIMEOUT`：超时                                                                           |

## 3. 中断方式函数说明

本节程序源码为“0802_i2c_int”，在“0801_i2c_poll”的基础上修改得来。

### 3.1. Master 模式函数

使用中断方式写 I2C 设备、读 I2C 设备函数原型如下：

```c
HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size);

HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size);
```

| 参数                        | 说明                            |
| ------------------------- | ----------------------------- |
| `I2C_HandleTypeDef *hi2c` | 使用哪个 I2C 控制器                  |
| `uint16_t DevAddress`     | 设备地址，需要把 7 位地址左移 1 位          |
| `uint8_t *pDat`           | 数据 buffer                     |
| `uint16_t Size`           | 数据个数                          |
| 返回值                       | `HAL_OK`：成功<br>`HAL_BUSY`：总线忙 |

这两个函数只是发出 Start 信号，后续完全由中断程序来传输后续数据。这两个函数返回后，并不表示传输已经完成，需要在中断回调函数里判断。

要使用中断方式，还需要使用 STM32CubeMX 配置 I2C 中断，如下：

![[HAL快速入门与项目实战.pdf#page=100&rect=111,504,484,733|HAL快速入门与项目实战, p.100]]

如果传输完成或出错，如下回调函数会被调用：

```c
/* 主设备发送完成回调函数 */
void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c);

/* 主设备接收完成回调函数 */
void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c);

/* 出错回调函数 */ void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
```

可以在这些回调函数里设置变量，表示传输已经完成。

### 3.2. MEM 模式函数

上述函数只能发起单向的数据传输，但是在实际编程中，比如要“读存储地址 addr 上的数值”，涉及 2 个方向的数据传输：要向 I2C 设备发起写操作把“存储地址 addr”发给他，然后向 I2C 设备发起读操作得到数值。

还有一种情况，“ 把数值 val 写到存储地址 addr ” 上，使用 “HAL_I2C_Master_Transmit_IT”函数时，需要在数据 buffer 里填入 addr 和 val，不太直观。

这时可以使用下面的函数：

```c
HAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size);

HAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size);
```

| 参数                        | 说明                                                                                                                                                    |
| ------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| `I2C_HandleTypeDef *hi2c` | 使用哪个 I2C 控制器                                                                                                                                          |
| `uint16_t DevAddress`     | 设备地址，需要把 7 位地址左移 1 位                                                                                                                                  |
| `uint16_t MemAddress`     | 存储地址，即 I2C 设备上的寄存器地址或存储地址                                                                                                                             |
| `uint16_t MemAddSize`     | 存储地址的大小，有 2 种取值：<br>1.  `I2C_MEMADD_SIZE_8BIT`：存储地址为 1 字节，就是 `MemAddress` 的低字节<br>2.  `I2C_MEMADD_SIZE_16BIT`：存储地址为 2 字节，先发送 `MemAddress` 的高字节，再发送低字节 |
| `uint8_t *pData`          | 数据 buffer                                                                                                                                             |
| `uint16_t Size`           | 数据个数                                                                                                                                                  |
| 返回值                       | `HAL_OK`：成功<br>`HAL_BUSY`：总线忙                                                                                                                         |

这几个函数只是发出 Start 信号，后续完全由中断程序来传输后续数据。这两个函数返回后，并不表示传输已经完成，需要在中断回调函数里判断。

如果传输完成或出错，如下回调函数会被调用：

```c
/* MEM模式发送完成回调函数 */
void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c);

/* MEM模式接收完成回调函数 */
void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c);

/* 出错回调函数 */
void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
```

可以在这些回调函数里设置变量，表示传输已经完成。

## 4. DMA 方式函数说明

本节程序源码为“0803_i2c_dma”，在“0802_i2c_int”的基础上修改得来。

### 4.1. Master 模式函数

使用 DMA 方式写 I2C 设备、读 I2C 设备函数原型如下：

```c
HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size);

HAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size);
```

| 参数                        | 说明                            |
| ------------------------- | ----------------------------- |
| `I2C_HandleTypeDef *hi2c` | 使用哪个 I2C 控制器                  |
| `uint16_t DevAddress`     | 设备地址，需要把 7 位地址左移 1 位          |
| `uint8_t *pData`          | 数据 buffer                     |
| `uint16_t Size`           | 数据个数                          |
| 返回值                       | `HAL_OK`：成功<br>`HAL_BUSY`：总线忙 |

这几个函数只是发出 Start 信号，后续完全由 DMA 来传输后续数据。这两个函数返回后，并不表示传输已经完成，需要在回调函数里判断。

要使用 DMA 方式，还需要使用 STM32CubeMX 配置 DMA，如下：

![[HAL快速入门与项目实战.pdf#page=102&rect=108,512,464,718|HAL快速入门与项目实战, p.102]]

如果传输完成或出错，如下回调函数会被调用：

```c
/* 主设备发送完成回调函数 */
void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c);

/* 主设备接收完成回调函数 */
void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c);

/* 出错回调函数 */
void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
```

可以在这些回调函数里设置变量，表示传输已经完成。

### 4.2. MEM 模式函数

上述函数只能发起单向的数据传输，但是在实际编程中，比如要“读存储地址 addr 上的数值 val”，涉及 2 个方向的数据传输：要向 I2C 设备发起写操作把“存储地址 addr”发给他，然后向 I2C 设备发起读操作得到数值。

还有一种情况，“ 把数值 val 写到存储地址 addr ” 上，使用 “HAL_I2C_Master_Transmit_IT”函数时，需要在数据 buffer 里填入 addr 和 val，不太直观。

这时可以使用下面的函数：

```c
HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size);

HAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size);
```

| 参数                        | 说明                                                                                                                                            |
| ------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| `I2C_HandleTypeDef *hi2c` | 使用哪个 I2C 控制器                                                                                                                                  |
| `uint16_t DevAddress`     | 设备地址，需要把 7 位地址左移 1 位                                                                                                                          |
| `uint16_t MemAddress`     | 存储地址，即 I2C 设备上的寄存器地址或存储地址                                                                                                                     |
| `uint16_t MemAddSize`     | 存储地址的大小，有 2 种取值：<br>`I2C_MEMADD_SIZE_8BIT`：存储地址为 1 字节，就是 `MemAddress` 的低字节<br>`I2C_MEMADD_SIZE_16BIT`：存储地址为 2 字节，先发送 `MemAddress` 的高字节，再发送低字节 |
| `uint8_t *pData`          | 数据 buffer                                                                                                                                     |
| `uint16_t Size`           | 数据个数                                                                                                                                          |
| 返回值                       | `HAL_OK`：成功<br>`HAL_BUSY`：总线忙                                                                                                                 |

这几个函数只是发出 Start 信号，后续完全由中断程序来传输后续数据。这两个函数返回后，并不表示传输已经完成，需要在中断回调函数里判断。

如果传输完成或出错，如下回调函数会被调用：

```c
/* MEM模式发送完成回调函数 */
void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c);

/* MEM模式接收完成回调函数 */
void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c);

/* 出错回调函数 */
void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
```

可以在这些回调函数里设置变量，表示传输已经完成。

# 在 OLED 上显示汉字

本节程序源码为“0804_i2c_chinese”，在“0802_i2c_int”的基础上修改得来。

## 1. 显存与像素的关系

OLED 分辨率为 $128*64$，像素个数=128*64=8192，每个像素使用 1 位数据来表示：数据为 1 则像素被点亮，数据为 0 则像素被关闭。在 SSD1306 内部，有名为 GDDRAM 的显存，如下：

![[HAL快速入门与项目实战.pdf#page=104&rect=111,468,526,650|HAL快速入门与项目实战, p.104]]

GDDRAM 显存被分为 64 行 128 类；这 64 行又可以分为 8 页，每页是 8 行。

写在 GDDRAM 里的第 1 个字节，它对应 OLED 上左上角第 1 列的 8 个像素；bit7 对应第 7 行，bit0 对应第 0 行。显存中数据和像素的对应关系如下图所示：

![[HAL快速入门与项目实战.pdf#page=104&rect=111,263,525,427|HAL快速入门与项目实战, p.104]]

在初始化 SSD1306 后，再往 GDDRAM 里写入数据即可控制像素。

## 2. 地址模式

要往 GDDRAM 里写入数据，需要指定地址。如果每写一个数据都要先指定地址，效率太低。高效的方法是：先指定起始行、列地址后，每写一个数据，地址就自动增加。根据地址增加的方向，有 3 种地址模式：

1. **页地址模式（Page Addressing Mode）**
	- 每写一个数据，列地址增加 1；当列地址到达最右边后：又从第 0 列开始，行地址不变。
	- ![[HAL快速入门与项目实战.pdf#page=105&rect=168,579,451,671|HAL快速入门与项目实战, p.105]]
2. **行地址模式（Horizontal Addressing Mode）**
	- 每写一个数据，列地址增加 1；当列地址到达最右边后：又从第 0 列开始，页地址加 1。当列地址、页地址都到达最大值后，又从起始列地址、起始页地址开始。
	- ![[HAL快速入门与项目实战.pdf#page=105&rect=140,436,454,539|HAL快速入门与项目实战, p.105]]
3. **列地址模式（Vertical Addressing Mode）**
	- 每写一个数据，页地址增加 1；当页地址到达最底边后：又从第 0 页开始，列地址也加 1。当列地址、页地址都到达最大值后，又从起始列地址、起始页地址开始。
	- ![[HAL快速入门与项目实战.pdf#page=105&rect=153,286,463,394|HAL快速入门与项目实战, p.105]]

程序里使用页地址模式

## 3. 如何发出命令和数据

要写 GDDRAM 时，需要指定起始的页地址、列地址——这被称为命令，还要发出数据。怎么分辨 I2C 总线上传输的是命令还是数据？在 I2C 传输的数据里，指定设备地址后的第 1 个字节数据被用来分辨：第 2 个数据是“命令”还是“发给 GDDRAM 的数据”。如下图所示：

![[HAL快速入门与项目实战.pdf#page=106&rect=147,488,470,693|HAL快速入门与项目实战, p.106]]

写 SSD1306 时，发出设备地址后的第 1 个字节数据，被称为“Control byte”：

- bit7 为“Co”位：Continuation bit，它一般为“0”，表示后面传输的只有“Data byte”。
- bit6 位“D/C#”位：表示后面传输的“Data byte”是“数据（data）”还是“命令 （commonad）”。“D/C#”位为 0 表示传输的是命令，为 1 表示传输的是数据（这是写入 GDDRAM 里的数据）。

发出命令、数据的代码示例：

```c
/*
 *	函数名：OLED_WriteCmd
 *	功能描述：I2C 发送命令给 OLED
 *	输入参数：cmd-发送给 OLED 的命令
 *	输出参数：无
 *	返回值：0-成功，其他值失败
*/
static int OLED_WriteCmd (uint8_t cmd)
{
	uint8_t tmpbuf[2];
	
	tmpbuf[0] = 0;
	tmpbuf[1] = cmd;
	
	return HAL_I2C_Master_Transmit (g_pHI2COLED, OLED_I2C_ADDR, tmpbuf, 2, OLED_TIMEOUT);
}

/*
 *	函数名：OLED_WriteData
 *	功能描述：I2C 发送数据给 OLED
 *	输入参数：data-发送给 OLED 的写入 GDRAM 的数据
 *	输出参数：无
 *	返回值：0-成功，其他值失败
*/
static int OLED_WriteData (uint8_t data)
{
	uint8_t tmpbuf[2];
	
	tmpbuf[0] = 0x40;
	tmpbuf[1] = data;
	
	return HAL_I2C_Master_Transmit (g_pHI2COLED, OLED_I2C_ADDR, tmpbuf, 2, OLED_TIMEOUT);
}
```

## 4. 显示汉字

### 4.1. 生成汉字点阵

运行“PCtoLCD2002”，先点击菜单“选项”进行设置，如下图所示：

![[HAL快速入门与项目实战.pdf#page=108&rect=167,550,450,723|HAL快速入门与项目实战, p.108]]

然后如下操作得到点阵，以“百问网”为例：

![[HAL快速入门与项目实战.pdf#page=108&rect=160,290,458,529|HAL快速入门与项目实战, p.108]]

### 4.2. 编程显示汉字

本节程序源码为“0804_i2c_chinese”，在“0802_i2c_int”的基础上修改得来。