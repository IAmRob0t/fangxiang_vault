---
tags:
---
# 设计思路与结构体

## 网络系统层次

![[23_net_layer.png|197]]

## 抽象网卡设备的结构体

```c
typedef struct NetDevice {
	char *name;
	char ip[4];
	char mac[6];
	int (*Init)(struct NetDevice *ptDev);
	int (*Connect)(struct NetDevice *ptDev, char *SSID, char *pasword);
	void (*DisConnect)(struct NetDevice *ptDev);
	/* source, dest, data */
	int (*Send)(struct NetDevice *ptDev, char *Type, char *pDestIP, int iDestPort, unsigned char *Data, int iLen);
	int (*Recv)(struct NetDevice *ptDev, char *Type, int iLocalPort, char *pSrcIP, unsigned char *Data, int *piLen);
}NetDevice, *PNetDevice;
```

# ESP8266 模块编程

## AT 指令练习

参考资料： [[AT 指令使用示例_V1.3_ESP8266 Non-OS.pdf]]

练习 AT 指令：
* 先烧录程序
* 接好 USB 串口线
* 执行 AT 命令：使用AiThinker_Serial_Tool_V1.2.3
* 向开发板发送网络数据：使用sscom5.13.1

```shell
1. 配置 WiFi 模式
AT+CWMODE=3						// softAP+station mode

2. 连接路由器
AT+CWJAP="Programmers","100asktech" // SSID and password of router
响应：OK

3. 查询 ESP8266 设备的 IP 地址
AT+CIFSR
响应：
+CIFSR:APIP,"192.168.4.1"
+CIFSR:APMAC,"1a:fe:34:a5:8d:c6"
+CIFSR:STAIP,"192.168.3.133"
+CIFSR:STAMAC,"18:fe:34:a5:8d:c6"
OK

4. 单连接
AT+CIPMUX=0
响应：
OK

5. 创建 UDP 传输, 最后一个参数设置为2时表示UDP通信的远端可改变
AT+CIPSTART="UDP","192.168.101.110",8080,1112,2
响应：
CONNNECT	
OK

6. 发送数据
AT+CIPSEND=7	 	// Send 7 bytes
>UDPtest			//	enter the data, no CR
响应：
Recv 7 bytes
OK

7. 发送数据到其他指定远端。例例如，发数据到 192.168.101.111, 端口 1000
AT+CIPSEND=7,"192.168.101.111",1000	 //	Send 7 bytes
>UDPtest							 //	enter the data, no CR
响应：
Recv 7 bytes
OK

8. 接收数据。 当 ESP8266 设备接收到服务器器发来的数据，将提示如下信息：
+IPD,n:xxxxxxxxxx // received n bytes, data=xxxxxxxxxxx	

9. 断开 UDP 传输
AT+CIPCLOSE
响应：
CLOSED
OK
```

![[AT 指令使用示例_V1.3_ESP8266 Non-OS.pdf#page=9&rect=47,412,569,650|AT 指令使用示例_V1.3_ESP8266 Non-OS, p.9]]

## ESP8266 编程

## 网卡管理层编程

# 实现 AT 命令

## 编写 `at_command.c`

在 `esp8266.c` 中，调用了这些函数：

```c
ATInterfaceSelect
ATInterfaceInit
ATCommandSend
ATDataRecv
```

![[25_at_hardware_interface.png]]

* ATCommandSend
	* 发送
	* 读取返回结果
	* 判断状态
* ATDataRecv
	* 读取数据
	* 解析数据
	* 判断状态

## 实现 UART 接口设备

所以，对于不同的接口，抽象出一个结构体：

```c
#define ATInterfaceDevice  UARTDevice
#define PATInterfaceDevice PUARTDevice

typedef struct UARTDevice {
	char *name;
	int (*Init)(struct UARTDevice *ptDev);
	void (*InvalidRecvBuf)(struct UARTDevice *ptDev);
	int (*Write)(struct UARTDevice *ptDev, char *Data, int iLen);
	int (*ReadByte)(struct UARTDevice *ptDev, char *Data);
}UARTDevice, *PUARTDevice;
```

# 串口设备编程

## AT 模块框架

在 `at_command.c` 里，调用了底层 UART 硬件的接口函数：

```c
#define ATInterfaceDevice	UARTDevice
#define PATInterfaceDevice	PUARTDevice

typedef struct UARTDevice {
	char *name;
	int (*Init)(struct UARTDevice *ptDec);
	void (*InvalidRecvBuf)(struct UARTDevice *ptDev);
	int (*Write)(struct UARTDevice *ptDev, cha *Data, int iLen);
	int (*ReadByte)(struct UARTDevice *ptDev, char *Data);
}UARTDevice, *PUARTDevice;
```

## 实现 UART 接口设备

![[27_use_two_uarts.png]]

STM32F103 上使用了 2 个 UART：
* UART1：通过 USB 串口芯片与 PC 相连，实现了 printf、scanf 等操作
* UART3：与 WIFI 模块 ESP8266 相连

UART1 的代码在 `ModuleDrivers\driver_usart.c` 里，

我们可以参考这个文件实现 UART3 的操作。

### 初始化

* 硬件初始化：引脚、波特率等

  ```c
  // Core\Src\usart.c
  void MX_USART3_UART_Init(void)
  {
  
    /* USER CODE BEGIN USART3_Init 0 */
  
    /* USER CODE END USART3_Init 0 */
  
    /* USER CODE BEGIN USART3_Init 1 */
  
    /* USER CODE END USART3_Init 1 */
    huart3.Instance = USART3;
    huart3.Init.BaudRate = 115200;
    huart3.Init.WordLength = UART_WORDLENGTH_8B;
    huart3.Init.StopBits = UART_STOPBITS_1;
    huart3.Init.Parity = UART_PARITY_NONE;
    huart3.Init.Mode = UART_MODE_TX_RX;
    huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    huart3.Init.OverSampling = UART_OVERSAMPLING_16;
    if (HAL_UART_Init(&huart3) != HAL_OK)
    {
      Error_Handler();
    }
    /* USER CODE BEGIN USART3_Init 2 */
  
    /* USER CODE END USART3_Init 2 */
  
  }
  ```

* 中断初始化

  ```c
  // ModuleDrivers\driver_usart.c
  
  void EnableUART3IRQ(void)
  {
      HAL_NVIC_SetPriority(USART3_IRQn, 0, 1);
      HAL_NVIC_EnableIRQ(USART3_IRQn);
      
      __HAL_UART_ENABLE_IT(&huart3, UART_IT_RXNE); 
  }
  ```

* 环形缓冲区的初始化

  ```c
  // smartdevice\device\uart\uart_dev.c
  
  /**********************************************************************
   * 函数名称： UART3Init
   * 功能描述： 初始化UART3
   * 输入参数： ptDev-没有使用
   * 输出参数： 无
   * 返 回 值： 0-成功
   * 修改日期       版本号     修改人	      修改内容
   * -----------------------------------------------
   * 2021/10/15	     V1.0	  韦东山	      创建
   ***********************************************************************/
  static int UART3Init(struct UARTDevice *ptDev)
  {
  	/* 在Core\Src\main.c里已经初始化硬件
  	 * 1. MX_USART3_UART_Init
  	 * 2. EnableUART3IRQ
  	 */
  
  	ring_buffer_init(&g_UART3RingBuffer);
  	
  	return 0;
  }
  ```

### 发送数据

使用查询方式发送多个数据，调用流程如下：

```shell
UART3Write // smartdevice\device\uart\uart_dev.c
	KAL_UART3Write // smartdevice\kal\kal_uart_dev.c
		CAL_UART3Write // smartdevice\cal\cal_uart_dev.c
			USART3_SendBytes // ModuleDrivers\driver_usart.c
```

底层函数是 `USART3_SendBytes`，代码如下：

```c
// ModuleDrivers\driver_usart.c

/**********************************************************************
 * 函数名称： USART3_SendBytes
 * 功能描述： 通过UART3发出多个数据
 * 输入参数： buf-数据缓冲区
 * 输入参数： len-数据长度
 * 输出参数： 无
 * 返 回 值： 0-成功
 * 修改日期       版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2021/10/15	     V1.0	  韦东山	      创建
 ***********************************************************************/
void USART3_SendBytes(char *buf, int len)
{
	int i;
	for (i = 0; i < len; i++)
	{
		while ((USART3->SR & (1<<7)) == 0);
		USART3->DR = buf[i];		
	}
}
```

### 接收数据

流程为：

* 中断服务程序：把数据放入环形缓冲区
* 上层代码：从环形缓冲区得到数据

中断服务程序代码：

```c
// ModuleDrivers\driver_usart.c

/**********************************************************************
 * 函数名称： USART3_IRQHandler
 * 功能描述： UART3中断函数,把接收到的数据放入环形缓冲区
 * 输入参数： 无
 * 输出参数： 无
 * 返 回 值： 无
 * 修改日期       版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2021/10/15	     V1.0	  韦东山	      创建
 ***********************************************************************/
void USART3_IRQHandler(void)
{
	static ring_buffer *uart3_ringbuffer = GetUART3RingBuffer();
    unsigned char c = 0;
	
    if((USART3->SR &(1<<5)) != 0)
    {
        c = USART3->DR;
        ring_buffer_write(c, uart3_ringbuffer);
    }
    HAL_UART_IRQHandler(&huart3);
}

```

上层代码:

```c
// smartdevice\device\uart\uart_dev.c

/**********************************************************************
 * 函数名称： UART3ReadByte
 * 功能描述： 通过UART3读取1个字节(不等待,无数据就返回-1)
 * 输入参数： ptDev-没有使用
 * 输出参数： Data-数据缓冲区
 * 返 回 值： 0-成功, (-1)-无数据
 * 修改日期       版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2021/10/15	     V1.0	  韦东山	      创建
 ***********************************************************************/
static int UART3ReadByte(struct UARTDevice *ptDev, char *Data)
{
	return ring_buffer_read((unsigned char *)Data, &g_UART3RingBuffer)
}
```

# 单元测试

## 编写测试代码

* 初始化
* 连接 WIFI
* 显示自己的 IP、端口
* 创建 UDP 传输
* 读取数据、打印出来

## 上机测试

向开发板发送数据：
* 使用**sscom5.13.1**
* 使用微信小程序：搜"百问网嵌入式物联网"

# 用作输入设备

## 设计思路

ESP8266 通过串口把网络数据发给主控，数据格式为：

```shell
+IPD,n:xxxxxxxxxx // received n bytes, data=xxxxxxxxxxx	
```

所以，可以这样做：

* 在串口接收中断里：记录收到的数据
* 判断是否有 `+IPD,` 前缀
  * 如果有，继续接收数据，得到长度 n
    * 得到长度后，继续接收数据本身
    * 接收到 n 个数据后，构造 InputEvent，放入缓冲区

## 编写代码

构造一个 InputDevice，在它的初始化函数里，提供串口中断的回调函数。

在回调函数里，处理串口数据。

## 上机测试

向开发板发送数据：

* 使用**sscom5.13.1**
* 使用微信小程序：搜"百问网嵌入式物联网"

# 用作输入设备\_单元测试

## 编写单元测试代码

仍然使用 `net_test.c`

## 上机测试

向开发板发送数据：

* 使用**sscom5.13.1**
* 使用微信小程序：搜"百问网嵌入式物联网"

