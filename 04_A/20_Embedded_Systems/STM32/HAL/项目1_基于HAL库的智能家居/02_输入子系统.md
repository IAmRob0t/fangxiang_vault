---
tags:
  - hal
---
# 核心结构体

## 输入事件

对于传递的"数据数据"，我们把它称为"输入事件"。

"输入事件"结构体可以支持多种类型的设备，比如按键、触摸屏、网络数据、scanf 数据。

结构体类型定义如下：

```c
#define TIME_T int
#define INTPU_BUF_LEN 1024

typedef enum
{    
	INPUT_EVENT_TYPE_KEY,
	INPUT_EVENT_TYPE_TOUCH,
	INPUT_EVENT_TYPE_NET,
	INPUT_EVENT_TYPE_STDIO
}INPUT_EVENT_TYPE;

typedef struct InputEvent {
	TIME_T time;
	INPUT_EVENT_TYPE eType;
	int iX;
	int iY;
	int iKey;
	int iPressure;
	char str[INTPU_BUF_LEN];
}InputEvent, *PInputEvent;
```

## 输入设备

"输入事件"由"输入设备"产生，

"输入设备"的核心是"获得数据事件"的函数，

结构体定义如下：

```c
typedef struct InputDevice {
	char *name;
	int (*GetInputEvent)(PInputEvent ptInputEvent);
	int (*DeviceInit)(void);
	int (*DeviceExit)(void);
	struct InputDevice *pNext;
}InputDevice, *PInputDevice;
```

# 设计思路

- 支持多设备
- 支持多系统
	- 裸机
	- FreeRTOS
	- RT-Thread
	- 甚至 Linux

---

- 数据来源：多个
- 使用者：1 个（业务子系统）
- 防止数据丢失：环形 `buffer`
- 数据来自中断
	- 裸机：中断里解析数据，放入环形 `buffer`
	- RTOS：多任务中解析数据，放入环形 `buffer`

## 共同点

输入事件被存放入环形缓冲区，业务函数从环形缓冲区读取数据

## 不同点

- 逻辑程序：在 ISR 中读取引荐、构造 InputEvent ，放入环形缓冲区
- RTOS 程序：对于每个输入设备，都创建一个任务
	- 在 ISR 中，触发任务
	- 在任务中，读取硬件、构造 InputEvent ，放入环形缓冲区

## 轮询

```c
int main2()
{
	while(1)
	{
		key = read_gpio();
		if (key)
		{
			// 1. key ==> InputEvent
			// 2. 处理
		}
		
		packet = read_net();
		if (packet)
		{
			// 1. packet ==> InputEvent
			// 2. 处理
		}
		
		str = scanf();
		if (str)
		{
			// 1. str ==> InputEvent
			// 2. 处理
		}
		
		other = read_other();
	}
}
```

## 业务、硬件分开

```c
int main()
{
	while (1)
	{
		event = GetInputEventFromDevices();		// 读 buffer。谁写 buffer？
		switch (event)
		{
			case 'a':
				process_a();
				break;
			case 'b':
				process_b();
				break;
		}
	}
}
```

# 实现环形缓冲区

## 环形缓冲区结构体

```c
// smartdevice\input\input_buffer.h
#define BUFFER_SIZE 10        /* 环形缓冲区的大小 */
typedef struct
{
    InputEvent buffer[BUFFER_SIZE];  /* 缓冲区空间 */
    volatile unsigned int pW;           /* 写地址 */
    volatile unsigned int pR;           /* 读地址 */
} InputEventBuffer;
```

## 环形缓冲区的读写操作

```c
// smartdevice\input\input_buffer.c

static InputEventBuffer g_tInputBuffer;

int GetInputEvent(PInputEvent ptInputEvent)
{
    int i = (g_tInputBuffer->pW + 1) % BUFFER_SIZE;

	/* 防御式编程 */
	if (!ptInputEvent)
		return -1;
	
    if(i != g_tInputBuffer->pR)    // 环形缓冲区没有写满
    {
        g_tInputBuffer->buffer[g_tInputBuffer->pW] = *ptInputEvent;
        g_tInputBuffer->pW = i;
		return 0;
    }
	return -1;
}

int PutInputEvent(PInputEvent ptInputEvent)
{
	/* 防御式编程 */
	if (!ptInputEvent)
		return -1;

	/* 环形缓冲区空, 则返回-1 */
    if(g_tInputBuffer->pR == g_tInputBuffer->pW)
    {
        return -1;
    }
    else
    {
        *ptInputEvent = g_tInputBuffer->buffer[g_tInputBuffer->pR];
        g_tInputBuffer->pR = (g_tInputBuffer->pR + 1) % BUFFER_SIZE;
        return 0;
    }
}
```

# 实现按键输入

## 层次

* 设备层：在 gpio_key. C 里构造一个 InputDevice
* 内核抽象层：我们想支持裸机、FreeRTOS、RT-Thread，引入内核抽象层
* 芯片抽象层：有些芯片提供了 HAL 库，有些并没有提供。为了支持多种芯片，引入芯片抽象层
* 硬件操作层：不管怎么抽象，最终都要操作硬件

![[按键输入层次.png]]

## 设备的初始化

```c
// gpio_key.c
g_tKeyDevice.DeviceInit
    GPIOKeyInit
    	KAL_GPIOKkeyInit
    		CAL_GPIOKkeyInit
    			KEY_GPIO_ReInit
```

## 数据的产生

在中断里构造 InputEvent，放入环形缓冲区。

```c
// driver_key.c
EXTI15_10_IRQHandler
    HAL_GPIO_EXTI_Callback    	
```

```c
// driver_key.c

/*
 *  函数名：HAL_GPIO_EXTI_Callback
 *  功能描述：外部中断回调函数
 *  输入参数：GPIO_Pin --> 产生外部中断的引脚
 *  输出参数：无
 *  返回值：无
*/
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
	InputEvent event;

	/* 消除抖动 */
	
	if(KEY1_PIN == GPIO_Pin)    // 判断进来的外部中断线连接的引脚是不是按键的引脚
	{
		//key1_val = K1;
		event.time = KAL_GetTime();	// kal
		event.eType = INPUT_EVENT_TYPE_KEY;
		event.iKey = K1_CODE;
		event.iPressure = !K1_STATUS;		// 读取GPIO电平,按下时压力是1，松开后压力是0
		PutInputEvent(&event);
	}
	else if(KEY2_PIN == GPIO_Pin)
	{
		//key2_val = K2;
		event.time = KAL_GetTime();	// kal
		event.eType = INPUT_EVENT_TYPE_KEY;
		event.iKey = K2_CODE;
		event.iPressure = !K2_STATUS;		// 读取GPIO电平,按下时压力是1，松开后压力是0
		PutInputEvent(&event);
	}
}
```

# 设备管理

## 支持多个输入设备

## 实现 InputDevice 的管理

### 使用链表管理 InputDevice

```c
/**********************************************************************
 * 函数名称： InputDeviceRegister
 * 功能描述： 注册一个输入设备
 * 输入参数： ptInputDevice-输入设备
 * 输出参数： 无
 * 返 回 值： 无
 * 修改日期         版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2021/09/24	    V1.0	  韦东山	      创建
 ***********************************************************************/
void InputDeviceRegister(PInputDevice ptInputDevice)
{
	ptInputDevice->pNext = g_ptInputDevices;
	g_ptInputDevices = ptInputDevice;
}
```

### 提供统一的函数使用 InputDevice

```c
/**********************************************************************
 * 函数名称： InitInputDevices
 * 功能描述： 初始化所有的输入设备
 * 输入参数： 无
 * 输出参数： 无
 * 返 回 值： 无
 * 修改日期        版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2021/09/24	     V1.0	  韦东山	      创建
 ***********************************************************************/
void InitInputDevices(void)
{
	PInputDevice pDev = g_ptInputDevices;

	while (pDev)
	{
		pDev->DeviceInit();
		pDev = pDev->pNext;
	}
}
```

# 单元测试

## 编写测试代码

核心函数为：

```c
/**********************************************************************
 * 函数名称： input_test
 * 功能描述： 输入系统单元测试函数
 * 输入参数： 无
 * 输出参数： 无
 * 返 回 值： 无
 * 修改日期       版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2021/09/24	     V1.0	  韦东山	      创建
 ***********************************************************************/
void input_test(void)
{
	InputEvent event;
	
	AddInputDevices();
	InitInputDevices();
	while (1)
	{
		if (GetInputEvent(&event) == 0)
		{
			printf("get input event:\r\n");
			printf("type: %d\r\n", event.eType);
			printf("time: %d\r\n", event.time);
			printf("key : %d\r\n", event.iKey);
			printf("pressure : %d\r\n", event.iPressure);
		} 
	}
}
```

然在 main 函数中调用 `input_test`。

## 上机实验

烧录程序、使用串口观察：按下/松开按键的打印信息。

发现 Bug：

```c
#define INTPU_BUF_LEN 1024

typedef struct InputEvent {
	TIME_T time;
	INPUT_EVENT_TYPE eType;
	int iX;
	int iY;
	int iKey;
	int iPressure;
	char str[INTPU_BUF_LEN];
}InputEvent, *PInputEvent;
```

InputEvent 中 str 数组太大了，在 input_test 函数中使用了局部变量 `InputEvent event`。

* 局部变量时保存在栈里的
* 栈覆盖了全局变量的区域，导致这个现象：按下、松开按键多次之后，程序打印无数信息
* 正常现象是：每次按下、松开，只打印一次信息

解决方法：
* 把 INTPU_BUF_LEN 改小，比如改为 20
* 或者增大栈空间，修改 `MDK-ARM\startup_stm32f103xe.s`

  ```shell
  Stack_Size		EQU     0x400
  改为
  Stack_Size		EQU     0x800
  ```

# 输入系统补课

## 单片机程序框架

单片机程序的 3 种写法：

### 轮流执行

```c
int main()
{
    while (1)
    {
        A();
        B();
        C();
        D();
    }
}
```

### 前后台

```c
void gpio_isr()
{
	put_data();
}

int main()
{
	while (1)
    {
    	if (get_data())
        {
	        do_something();
        }
    }
}
```

### 多任务

```c
void productor_task()
{
    while (1)
    {
        if (has_data)
		    put_data();
    }
}

void consumer_task()
{
    while (1)
    {
        if (get_data())
		    do_something();
    }    
}

int main()
{
    create_task(productor_task);
    create_task(consumer_task);
    start_scheduler();
}
```

## 轮流执行的程序怎么写？

出个题目，用按键控制 LED：

![[06_example1.png]]

### 常规写法

### 面向对象的写法

* 什么叫面向对象？
* 怎么抽象出结构体？

### 为什么要面向对象？

## 对于按键，怎么抽象出结构体？

* 框图
* InputEvent
* InputDevice

## 我们之前写的程序，怎么使用定时器消除抖动？

### 机械抖动

![[07_bouce.png]]

### 怎么消除抖动？

* 硬件？
* 软件等待一会？
* 定时器？

![[08_use_timer_debouncing.png]]

## 写程序
