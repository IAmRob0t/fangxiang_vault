---
tags:
  - hal
---
# 设计思路与结构体

## 字体操作

有点阵字体，有矢量字体，比如：

* 使用点阵绘制文字时：每个文字的大小一样，前后文字互不影响
  ![[16_font_bit.png]]
* 使用 Freetype 绘制文字时：大小可能不同，前面文字会影响后面文字
  ![[17_freetype_font.png|310]]

### 怎么描述点阵字体

对于普通的点阵字体，怎么描述它？比如下面的点阵：
![[18_dot_font_example.png]]

* X、Y 方向大小
* 每个像素的值


用下面的结构体来表示即可：

```c
struct dot_font {
    int iX;
    int iY;
    int iWidth;
    int iHeigh;
    unsigned char *dots; /* 指向一个bufffer, dots[0]对应第1列, dots[1]对应第1列, ... */
};
```

### 怎么描述矢量字体

对于矢量字体，每个字体的大小可能不一样，前一个字体会影响下一个字体。

下图是一个矢量字体的例子，图中两个黑点很重要：
* 右边的黑点：当前字符的原点
* 右边的黑点：下一个字符的原点

![[19_freetype_font_example.png]]

怎么描述一个矢量字体？上图的参数都要记录下来。

## 字体位图的数据结构

能否抽象出一个结构体，既能描述点阵字体，也能描述矢量字体？

```c
typedef struct FontBitMap {
	int iLeftUpX;     /* 位图左上角X坐标 */
	int iLeftUpY;     /* 位图左上角Y坐标 */
	int iWidth;       /* 字体宽度 */
	int iRows;        /* 字体高度 */
	int iCurOriginX;  /* 原点X坐标 */
	int iCurOriginY;  /* 原点Y坐标 */
	int iNextOriginX; /* 下一个字符X坐标 */ 
	int iNextOriginY; /* 下一个字符Y坐标 */ 
	unsigned char *pucBuffer; /* 字符点阵 */
}FontBitMap, *PFontBitMap;
```

## 字体库的数据结构

对于字库操作，最关键的点在于"获得指定字符"的字库数据。
另外，点阵字库文件中，每个字符大小是固定的。
矢量字符文字文件中，可以灵活设置字符的大小。
可以抽象出这样的结构体：

```c
typedef struct FontLib {
	char *name;
	int (*FontInit)(struct FontOpr *pFontLib);  /* 初始化字库 */
	void (*GetFontSize)(int *piWidth, int *piHeigh);  /* 获取字体大小 */
	int (*SetFontSize)(int iFontSize);          /* 设置字体大小 */
	int (*GetFontBitMap)(unsigned int dwCode, PFontBitMap ptFontBitMap);  /* 获取某个字符的字库 */
	struct FontLib *ptNext;
}FontLib, *PFontLib;
```

## 程序层次

![[15_font_levels.png]]

# 实现 ASCII 字库的操作

## 构造 FontLib

编写 `ascii_font.c`，构造一个 FontLib 结构体：

```c
/* 构造一个FontLib */
static FontLib g_ASCIIFontLib = {
	"ascii",
	NULL,
	ASCIIGetFontSize,
	NULL,
	ASCIIGetFontBitMap,
};
```

函数 `ASCIIGetFontSize` 用来获得字库点阵的宽度、高度，代码如下：

```c
/**********************************************************************
 * 函数名称： ASCIIGetFontSize
 * 功能描述： 获得ASCII字库中字符点阵的宽、高
 * 输入参数： 无
 * 输出参数： piWidth-保存宽度
 * 输出参数： piHeigh-保存高度
 * 返 回 值： 无
 * 修改日期        版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2021/10/08	     V1.0	  韦东山	      创建
 ***********************************************************************/
static void ASCIIGetFontSize(int *piWidth, int *piHeigh)					/* 获取字体大小 */
{
	if (piWidth)
		*piWidth = 8;
	if (piHeigh)
		*piHeigh = 16;
}
```

核心函数是 `ASCIIGetFontBitMap`：

```c
/**********************************************************************
 * 函数名称： ASCIIGetFontBitMap
 * 功能描述： 获得ASCII字库中某个字符的点阵
 * 输入参数： dwCode-哪个字符,字符的ASCII码
 * 输出参数： ptFontBitMap-用来保存字库点阵
 * 返 回 值： 0-成功, -1-失败
 * 修改日期        版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2021/10/08	     V1.0	  韦东山	      创建
 ***********************************************************************/
static int ASCIIGetFontBitMap(unsigned int dwCode, PFontBitMap ptFontBitMap)  /* 获取某个字符的字库 */
{
	int iWidth = 8;
	int iHeigh = 16;
	unsigned char *dots = ascii_font[dwCode];
	if (!ptFontBitMap)
	{
		/* 调用GetFontBitMap之前要设置原点X,Y坐标
		 * 根据它可以算出左上角X,Y坐标
		 * 根据它可以算出下一个字符的原点X,Y坐标
		 */

		/* 计算左上角坐标 */
		ptFontBitMap->iLeftUpX = ptFontBitMap->iCurOriginX;
		ptFontBitMap->iLeftUpY = ptFontBitMap->iCurOriginY - iHeigh + 1;

		/* 计算下一个字符的原点坐标 */
		ptFontBitMap->iNextOriginX = ptFontBitMap->iCurOriginX + iWidth;
		ptFontBitMap->iNextOriginY = ptFontBitMap->iCurOriginY;

		/* 设置点阵宽度/高度 */
		ptFontBitMap->iWidth = iWidth;
		ptFontBitMap->iRows  = iHeigh;

		/* 如果用户没有提供自己的buffer, 直接返回字库数组里的数据 */
		if (!ptFontBitMap->pucBuffer)
			ptFontBitMap->pucBuffer = dots;
		else /* 如果用户提供了自己的buffer, 复制字库数组里的数据 */
			memcpy(ptFontBitMap->pucBuffer, dots, 16);

		return 0;
	}
	return -1;
}
```

## 实现管理层

### `font_manager.c`

底层字库要向上注册 FontLib，函数 `FontLibRegister` 代码如下：

```c
/**********************************************************************
 * 函数名称： FontLibRegister
 * 功能描述： 注册一个字库
 * 输入参数： ptFontLib-字库
 * 输出参数： 无
 * 返 回 值： 无
 * 修改日期        版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2021/10/09	     V1.0	  韦东山	      创建
 ***********************************************************************/
void FontLibRegister(PFontLib ptFontLib)
{
	ptFontLib->pNext = g_ptFontLibs;
	g_ptFontLibs = ptFontLib;
}
```

所谓注册，就是把底层的 FontLib 放入上层的链表。

我们还可以根据名字，从链表里把 FontLib 取出来，函数为 `__GetFontLib`：

```c
/**********************************************************************
 * 函数名称： __GetFontLib
 * 功能描述： 获得字库
 * 输入参数： name-字库的名称
 * 输出参数： 无
 * 返 回 值： 成功-PFontLib, 失败-NULL
 * 修改日期        版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2021/10/09	     V1.0	  韦东山	      创建
 ***********************************************************************/
PFontLib __GetFontLib(char *name)
{
	PFontLib pTmp = g_ptFontLibs;
	while (pTmp)
	{
		if (strcmp(pTmp->name, name) == 0)
			return pTmp;
		else
			pTmp = pTmp->pNext;
	}
	return NULL;
}
```

### `font_system.c`

为了让 `font_manager.c` 和底层的 `ascii_font.c` 不相互调用，引入了 `font_system.c`。

里面有 2 个函数：

```c
/**********************************************************************
 * 函数名称： AddFontLibs
 * 功能描述： 注册多个字库
 * 输入参数： 无
 * 输出参数： 无
 * 返 回 值： 无
 * 修改日期        版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2021/10/08	     V1.0	  韦东山	      创建
 ***********************************************************************/
void AddFontLibs(void)
{
	AddFontLibASCII();
}

/**********************************************************************
 * 函数名称： GetFontLib
 * 功能描述： 获得字库
 * 输入参数： name-字库的名称
 * 输出参数： 无
 * 返 回 值： 成功-PFontLib, 失败-NULL
 * 修改日期        版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2021/10/09	     V1.0	  韦东山	      创建
 ***********************************************************************/
PFontLib GetFontLib(char *name)
{
	return __GetFontLib(name);
}
```
