---
tags:
  - hal
---
# 设计思路

## 怎么访问设备

### 裸机里怎么访问设备

使用 HAL 库，或者厂家自己封装的库，甚至自己编写代码直接访问寄存器。

### FreeRTOS 怎么访问设备

FreeRTOS 中没有驱动程序框架，它访问设备时方法跟裸机一样。

### RT-Thread 怎么访问设备

RT-Thread 可以使用 2 种方法访问设备：
* 像裸机一样
* 使用 RT-Thread 的驱动程序框架

![[RT-Thread 驱动程序框架.png]]

所谓"驱动框架"，就是事先定义好的接口函数，你要添加新设备就必须实现这些接口函数。

好处是：无论硬件怎么改，驱动程序的接口不变，上面的应用程序也就不需要改变。

"I/O 设备管理"接口如下：

![[RT-Thread IO设备管理.png]]

应用程序通过标准的接口来访问设备：rt_device_find/rt_device_open/rt_device_read/rt_device_write 等等。

### Linux 下怎么访问设备

Linux 系统中，APP 和驱动程序严格分离开：

* APP 无法直接读写寄存器
* APP 必须通过驱动程序访问设备
* APP 使用的接口只有：open/read/write/ioctl 等

## 有必要统一设备的访问吗？

先把设备子系统分层：

![[设备子系统分层.png]]

至少有 2 层：虚线上下
* 虚线之上：写出统一的 API 接口
* 虚线之下：根据不同的系统，调用不同的函数

---

对于开发应用程序的人：
* 他不关心 LED 使用哪个 GPIO 引脚
* 他不关心 GPIO 是输出高还是低来控制 LED
* 他不关心 open 什么、read/write 什么
* 我们不应该要求他：
	* 阅读原理图
	* 阅读芯片手册
	* 研究 HAL 库、RT-Thread 或者 Linux 的驱动函数怎么调用
* 甚至不应该要求他去理解你抽象出来的某个结构体
	* 你可以抽象出一个 `LEDDevice`
	* 但是 `LEDDevice` 里，他只关心怎么使用 `Init` / `Control` 中 2 个函数指针
	  * 其他成员一概不关心

所以，我们很有必要提供更高层次的 API，以 LED 为例：
* 可以提供：`LEDInit` / `LedControl`，这 2 个函数可以放入 `LEDDevice` 结构体里
* 应用开发者，只需要调用这 2 个函数

## 设计原则：驱动和应用分开

在 Linux 驱动开发中，有一句话：驱动只提供功能，不提供策略。

什么意思呢？就是各司其职，不要越界。

以 LCD 的使用为例，可以分为 3 层：

|   APP<br>业务相关   |
| :-------------: |
| **文 / 图<br>显示** |
|    **设备驱动**     |

* 驱动程序：
	* 提供像素操作的功能
	* 但是怎么显示字符、显示多大、在哪显示，这不关我的事
* 库函数/功能函数：
	* 提供显示字符、显示图片的功能
	* 但是显示什么字符、在哪显示，这不关我的事
* APP：
	* 使用库函数来显示字符、显示图片
	* 我甚至不需要看驱动程序

我们实现各类子系统时，要划分层次的时候，也要理清楚：
* 有哪些功能
* 这些功能怎么细分？得到层次
* 每个层次各司其职，不要越界

## 设计思路

使用面向对象的思想，对于每一种设备，抽象出一个结构体，结构体里有设备相关的函数指针。

不同设备，不强求统一，不强求用一个结构体类型，支持所有设备。

编写函数时，要注意：
* 头文件：这些函数是面向 APP 开发者，假设他们对硬件一无所知
* C 文件：函数内部，再根据不同系统、不同芯片，调用其他函数

# 实现 LED 设备

## 抽象出结构体

```c
#define LED_WHITE 	0
#define LED_BLUE 	1
#define LED_GREEN 	2

typedef struct LEDDevice {
	int which;
	int (*Init)(struct LEDDevice *ptLEDDevice);
	int (*Control)(struct LEDDevice *ptLEDDevice, int iStatus);
	void (*SetColor)(struct LEDDevice *ptLEDDevice, int iColor);
	void (*SetBrightness)(struct LEDDevice *ptLEDDevice, int iBrightness);
}LEDDevice, *PLEDDevice;
```

## 编程

我们把 LED 设备分为 4 层：

![[LED设备层次.png]]

### 设备层

```c
static int LEDDeviceInit(struct LEDDevice *ptLEDDevice)
{
	return KAL_LEDDeviceInit(ptLEDDevice);
}

static int LEDDeviceControl(struct LEDDevice *ptLEDDevice, int iStatus)
{
	return KAL_LEDDeviceControl(ptLEDDevice, iStatus);
}


static LEDDevice g_tLEDDevices = {
	{LED_WHITE, LEDDeviceInit, LEDDeviceControl},
	{LED_BLUE,  LEDDeviceInit, LEDDeviceControl},
	{LED_GREEN, LEDDeviceInit, LEDDeviceControl},
};

PLEDDevice GetLEDDevice(int which)
{
	if (which >= LED_WHITE && which <= LED_GREEN)
		return &g_tLEDDevices[which];
	else
		return NULL;
}
```

### 内核抽象层

```c
#include <led_device.h>

int KAL_LEDDeviceInit(struct LEDDevice *ptLEDDevice)
{	
	/* 对于裸机/FreeRTOS */
	return CAL_LEDDeviceInit(ptLEDDevice);

	/* 对于RT-Thread */

	/* 对于Linux */
}

int KAL_LEDDeviceControl(struct LEDDevice *ptLEDDevice, int iStatus)
{
	/* 对于裸机/FreeRTOS */
	return CAL_LEDDeviceControl(ptLEDDevice, iStatus);

	/* 对于RT-Thread */

	/* 对于Linux */
}
```

### 芯片抽象层

```c
#include <led_device.h>

int CAL_LEDDeviceInit(struct LEDDevice *ptLEDDevice)
{	
	/* 对于hal */
	/* 已经在MX_GPIO_Init初始化了引脚 */
	return 0;
}

int CAL_LEDDeviceControl(struct LEDDevice *ptLEDDevice, int iStatus)
{
	/* 对于hal */
	return HAL_LEDDeviceControl(ptLEDDevice, iStatus);
}
```

### 硬件操作层

```c
/*
 *  函数名：int HAL_LEDDeviceControl(struct LEDDevice *ptLEDDevice, int iStatus)
 *  输入参数：ptLEDDevice-哪个LED
 *  输入参数：iStatus-LED状态, 1-亮, 0-灭
 *  输出参数：无
 *  返回值：0-成功, -1: 失败
 */
int HAL_LEDDeviceControl(struct LEDDevice *ptLEDDevice, int iStatus)
{
	if (!ptLEDDevice)
		return -1;
	
	switch (ptLEDDevice->which)
	{
		case LED_WHITE: 
		{
		    HAL_GPIO_WritePin(WHITE_GPIO_Port, WHITE_Pin, !iStatus);
			break;
		}

		case LED_BLUE: 
		{
		    HAL_GPIO_WritePin(BLUE_GPIO_Port, BLUE_Pin, !iStatus);
			break;
		}

		case LED_GREEN: 
		{
		    HAL_GPIO_WritePin(GREEN_GPIO_Port, GREEN_Pin, !iStatus);
			break;
		}

		default:
			return -1;
	}

	return 0;
	
}
```

# 单元测试

编写测试代码：

```c
/**********************************************************************
 * 函数名称： led_test
 * 功能描述： 设备系统LED设备单元测试函数
 * 输入参数： 无
 * 输出参数： 无
 * 返 回 值： 无
 * 修改日期       版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2021/09/27	     V1.0	  韦东山	      创建
 ***********************************************************************/
void led_test(void)
{
	PLEDDevice p1 = GetLEDDevice(LED_WHITE);
	PLEDDevice p2 = GetLEDDevice(LED_BLUE);
	PLEDDevice p3 = GetLEDDevice(LED_GREEN);

	p1->Init(p1);
	p2->Init(p2);
	p3->Init(p3);

	while (1)
	{
		p1->Control(p1, 1);
		p2->Control(p2, 1);
		p3->Control(p3, 1);

		KAL_Delay(500);

		p1->Control(p1, 0);
		p2->Control(p2, 0);
		p3->Control(p3, 0);
		
		KAL_Delay(500);
		
	}
}
```

# 显示设备结构体抽象

## 显示设备的硬件概括

### LCD 显示原理

什么是 LCD？就是多行多列的像素：
* 对于黑白屏幕 (单色屏幕)，这些像素只有 2 个状态：点亮、熄灭
* 对于彩色屏幕，这些像素有颜色：可以用 RGB 三原色来表示

怎么控制 LCD 上每个像素的状态？
* 有显存，就是一块内存，也被称为 `FrameBuffer`
* 每个像素在显存上都有对应的数据
	* 对于黑白屏 (单色屏)，每个像素在显存里有对应的 1 位数据
	* 对于彩色屏，每个像素在显存里有几个字 (可能是 1 字节、2 字节、4 字节)
	* 每个像素用多少位数据？被称为 BPP： Bits Per Pixel。

要注意的是，LCD 可能自带显存，也可能不带有显存 (要使用 LCD 的话，就需要在系统内存中分配显存)。

有三种类型的 LCD：

### LCD 含有显存, CPU 通过 I2C 访问

很多 I2C、SPI 接口的屏幕，本身是含有显存的。要在 LCD 上显示文字、图片，就需要网显存里写入数据。

程序通过 I2C 接口写显存。

![[09_display_with_ram_through_i2c.png]]

### LCD 没有显存, LCD 控制器从内存得到数据

很多 TFT LCD 本身是没有显存的，那么数据保存在哪里？可以在系统内存里分配一块空间，它就是显存。

设置好 LCD 控制器后，它就会自动从显存取出数据、发送给 LCD。

我们只需要写数据到显存即可。

![[10_display_without_ram.png]]

### LCD 含有显存, CPU 可以直接访问

有些 LCD 含有显存，并且 CPU 可以直接访问显存：就像访问一般内存一样访问显存。

我们只需要写数据到显存即可。

![[11_display_with_ram_like_ram.png]]

### 差别在哪？

对于软件来说，这 3 种 LCD 都有显存，第 1 种无法直接写显存；第 2、3 种可以直接写显存。

能否统一？

对于第 1 种 LCD，能否也直接写显存？可以：

* 在系统内存分配另一个"显存 FB"
* 软件直接写"显存 FB"
* 在通过 I2C 把"显存 FB"的内容传送到 LCD 自带的显存

![[12_another_framebuffer.png]]

## 显示设备的结构体抽象

怎么抽象出一个显示设备？

* 有初始化函数
* 有显存，怎么描述显存？
	* 起始地址
	* 分辨率
	* 每个像素用多少位来表示
* 对于第 1 种 LCD，还需要一个 Flush 函数，把"显存 FB"的内容"刷"到 LCD 的显存去

结构体如下：

```c
typedef struct DisplayDevice {
	char *name;
	void *FBBase;
	int iXres;									// x 方向的分辨率
	int iYres;									// y 方向的分辨率
	int iBpp;									// 每个像素用多少位表示
	int (*Init)(struct DisplayDevice *ptDev);	// 硬件初始化
	void (*Flush)(struct DisplayDevice *ptDev);	// 把FBBase的数据刷到LCD的显存里
	
	/*	设置FBBase中的数据, 把(iX,iY)的像素设置为颜色dwColor 
	 *	dwColor的格式:0x00RRGGBB
	 */
	int (*SetPixel)(struct DispayDevice *ptDev, int iX, int iY, unsigned int dwColor); 
}DispayDevice, *PDispayDevice;
```

# 设备系统_实现显示设备

## 程序层次

![[13_display_layer.png|154]]

## 编程

核心是底下的 oled_device. C，它要构造出一个 DisplayDevice。

我们先实现它，再去考虑管理的事情。

### 构造 DisplayDevice

文件：`oled_device.c`

```c
static DispayDevice g_tOLEDDevice = {
	"OLED",
	g_OLEDFramebuffer,
	128,
	64,
	1,
	OLEDDeviceInit,
	OLEDDeviceFlush,
	OLEDDeviceSetPixel
};
```

#### Init 和 Flush

`OLEDDeviceInit` 和 `OLEDDeviceFlush` 比较简单，都是调用下面 KAL 层的函数：

```c
/**********************************************************************
 * 函数名称： OLEDDeviceInit
 * 功能描述： 初始化OLED硬件
 * 输入参数： ptDev-哪个显示设备
 * 输出参数： 无
 * 返 回 值： 0-成功
 * 修改日期       版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2021/09/29	     V1.0	  韦东山	      创建
 ***********************************************************************/
static int OLEDDeviceInit(struct DispayDevice *ptDev)
{
	/* 初始化OLED硬件 */
	return KAL_OLEDDeviceInit(ptDev);
}

/**********************************************************************
 * 函数名称： OLEDDeviceFlush
 * 功能描述： 把临时显存的数据, 刷到LCD的显存去
 * 输入参数： ptDev-哪个显示设备
 * 输出参数： 无
 * 返 回 值： 无
 * 修改日期       版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2021/09/29	     V1.0	  韦东山	      创建
 ***********************************************************************/
static void OLEDDeviceFlush(struct DispayDevice *ptDev)
{
	/* 把Framebuffer g_OLEDFramebuffer的数据搬到OLED自带的显存里 */
	KAL_OLEDDeviceFlush(ptDev);
}
```

#### `SetPixel` 函数

需要计算的就是，(`iX`, `iY`) 在显存里哪个位置、哪个 bit，

代码如下：

```c
/**********************************************************************
 * 函数名称： OLEDDeviceSetPixel
 * 功能描述： 在显存中设置(iX,iY)像素的颜色
 * 输入参数： ptDev-哪个显示设备
 * 输入参数： iX-X坐标
 * 输入参数： iY-Y坐标
 * 输入参数： dwColor-颜色
 * 输出参数： 无
 * 返 回 值： 0-成功
 * 修改日期       版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2021/09/29	     V1.0	  韦东山	      创建
 ***********************************************************************/
static int OLEDDeviceSetPixel(struct DispayDevice *ptDev, int iX, int iY, unsigned int dwColor) /* 0x00RRGGBB */
{
	unsigned char *buf = ptDev->FBBase;
	int page;
	unsigned char *byte;
	int bit;
	
	if (iX >= ptDev->iXres || iY >= ptDev->iYres)
		return -1;

	page = iY / 8;
	byte = buf + page * 128 + iX;
	bit = iY % 8;

	if (dwColor)
		*byte |= (1<<bit);
	else
		*byte &= ~(1<<bit);

	return 0;
}
```

### KAL 层

文件：`kal_oled_device.c`

核心思路就是根据配置项，调用对应的函数。代码如下：

```c
/**********************************************************************
 * 函数名称： KAL_OLEDDeviceInit
 * 功能描述： 内核抽象层的函数,初始化OLED硬件
 * 输入参数： ptDev-哪个显示设备
 * 输出参数： 无
 * 返 回 值： 0-成功
 * 修改日期       版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2021/09/29	     V1.0	  韦东山	      创建
 ***********************************************************************/
int KAL_OLEDDeviceInit(struct DispayDevice *ptDev)
{
	/* 初始化OLED硬件 */
#if defined (CONFIG_NOOS)
	return CAL_OLEDDeviceInit(ptDev);
#elif defined (CONFIG_FREERTOS)
	return FreeRTOS_OLEDDeviceInit(ptDev);
#elif defined (CONFIG_RTTHREAD)
	return RTThread_OLEDDeviceInit(ptDev);
#endif
}

/**********************************************************************
 * 函数名称： OLEDDeviceFlush
 * 功能描述： 内核抽象层的函数, 把临时显存的数据, 刷到LCD的显存去
 * 输入参数： ptDev-哪个显示设备
 * 输出参数： 无
 * 返 回 值： 无
 * 修改日期       版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2021/09/29	     V1.0	  韦东山	      创建
 ***********************************************************************/
void KAL_OLEDDeviceFlush(struct DispayDevice *ptDev)
{
	/* 把Framebuffer g_OLEDFramebuffer的数据搬到OLED自带的显存里 */
#if defined (CONFIG_NOOS)
	CAL_OLEDDeviceFlush(ptDev);
#elif defined (CONFIG_FREERTOS)
	FreeRTOS_OLEDDeviceFlush(ptDev);
#elif defined (CONFIG_RTTHREAD)
	RTThread_OLEDDeviceFlush(ptDev);
#endif
}
```

### CAL 层

文件：`cal_oled_device.c`

核心思路就是根据配置项，调用对应的函数。代码如下：

```c
/**********************************************************************
 * 函数名称： CAL_OLEDDeviceInit
 * 功能描述： 芯片抽象层的函数,初始化OLED硬件
 * 输入参数： ptDev-哪个显示设备
 * 输出参数： 无
 * 返 回 值： 0-成功
 * 修改日期       版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2021/09/29	     V1.0	  韦东山	      创建
 ***********************************************************************/
int CAL_OLEDDeviceInit(struct DispayDevice *ptDev)
{
	/* 初始化OLED硬件 */
#if defined (CONFIG_SUPPORT_HAL)
    // 1. 重新初始化I2C的引脚
    I2C_GPIO_ReInit();
    // 2. 初始化OLED  
    OLED_Init();
	return 0;
#elif 
	return NOHAL_OLEDDeviceInit(ptDev);
#endif
}

/**********************************************************************
 * 函数名称： CAL_OLEDDeviceFlush
 * 功能描述： 芯片抽象层的函数, 把临时显存的数据, 刷到LCD的显存去
 * 输入参数： ptDev-哪个显示设备
 * 输出参数： 无
 * 返 回 值： 无
 * 修改日期       版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2021/09/29	     V1.0	  韦东山	      创建
 ***********************************************************************/
void CAL_OLEDDeviceFlush(struct DispayDevice *ptDev)
{
	/* 把Framebuffer g_OLEDFramebuffer的数据搬到OLED自带的显存里 */
#if defined (CONFIG_SUPPORT_HAL)
	OLED_Copy(ptDev->FBBase);
#elif 
	NOHAL_OLEDDeviceFlush(ptDev);
#endif
}
```

### 硬件操作

一起讲 HAL 库时写过程序，参考代码：

```shell
// 需要用到OLED的代码
rtos_doc_source\RTOS培训资料\
	01_项目1_基于HAL库实现智能家居\
		03_项目必备的HAL库基础\1_项目源码\4_OLED
```

- `ascii_font.c`
- `driver_i2c.c`
- `driver_i2c.h`
- `driver_oled.c`
- `driver_oled.h`

# 显示设备单元测试

## 编写管理层

### `display_device.c`

需要支持 OLED、TFTLCD

使用链表来管理底下各个显示设备，底层的显示设备要把自己注册进链表：

```c
 * 函数名称： DisplayDeviceRegister
 * 功能描述： 注册一个输入设备
 * 输入参数： ptDisplayDevice-输入设备
 * 输出参数： 无
 * 返 回 值： 无
 * 修改日期        版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2021/09/24	     V1.0	  韦东山	      创建
 ***********************************************************************/
void DisplayDeviceRegister(PDisplayDevice ptDisplayDevice)
{
	ptDisplayDevice->pNext = g_ptDisplayDevices;
	g_ptDisplayDevices = ptDisplayDevice;
}
```

我们还可以通过名字从链表中把设备取出来，`__GetDisplayDevice` 函数前面有 `__` 前缀，表示这是内部函数：

```c
/**********************************************************************
 * 函数名称： __GetDisplayDevice
 * 功能描述： 获得显示设备
 * 输入参数： name-显示设备的名称
 * 输出参数： 无
 * 返 回 值： 成功-PDisplayDevice, 失败-NULL
 * 修改日期        版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2021/10/08	     V1.0	  韦东山	      创建
 ***********************************************************************/
PDisplayDevice __GetDisplayDevice(char *name)
{
	PDisplayDevice pTmp = g_ptDisplayDevices;
	while (pTmp)
	{
		if (strcmp(pTmp->name, name) == 0)
			return pTmp;
		else
			pTmp = pTmp->pNext;
	}
	return NULL;
}
```

### `display_system.c`

这是显示设备对外的统一接口，提供了 2 个函数。

第一个函数是注册所有的显示设备：

* 它调用 OLED 设备提供的 `AddDisplayDeviceOLED` 函数
* 如果还有其他显示设备，请在此函数中添加注册代码

```c
/**********************************************************************
 * 函数名称： AddDisplayDevices
 * 功能描述： 注册多个显示设备
 * 输入参数： 无
 * 输出参数： 无
 * 返 回 值： 无
 * 修改日期        版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2021/10/08	     V1.0	  韦东山	      创建
 ***********************************************************************/
void AddDisplayDevices(void)
{
	AddDisplayDeviceOLED();
}
```

第二个函数是根据名字获得显示设备：

```c
/**********************************************************************
 * 函数名称： GetDisplayDevice
 * 功能描述： 获得显示设备
 * 输入参数： name-显示设备的名称
 * 输出参数： 无
 * 返 回 值： 成功-PDisplayDevice, 失败-NULL
 * 修改日期        版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2021/10/08	     V1.0	  韦东山	      创建
 ***********************************************************************/
PDisplayDevice GetDisplayDevice(char *name)
{
	return __GetDisplayDevice(name);
}
```

## 编写单元测试代码

代码为 `smartdevice\unittest\display_test.c`，函数如下：

```c

/**********************************************************************
 * 函数名称： display_test
 * 功能描述： 显示设备单元测试函数
 * 输入参数： 无
 * 输出参数： 无
 * 返 回 值： 无
 * 修改日期       版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2021/10/08	     V1.0	  韦东山	      创建
 ***********************************************************************/
void display_test(void)
{
	PDisplayDevice ptDevice;
	char *name = "OLED";
	int x, y;
	
	AddDisplayDevices();

	ptDevice = GetDisplayDevice(name);

	if (!ptDevice)
	{
		printf("Can not get DisplayDevice %s\r\n", name);
		return;
	}

	/* 1. 初始化设备 */
	ptDevice->Init(ptDevice);

	/* 2. 清除屏幕 */
	memset(ptDevice->FBBase, 0, ptDevice->iSize);

	/* 3. 画线 */
	y = ptDevice->iYres / 2;
	for (x = 0; x < ptDevice->iXres; x++)
		ptDevice->SetPixel(ptDevice, x, y, 1);

	x = ptDevice->iXres / 2;
	for (y = 0; y < ptDevice->iYres; y++)
		ptDevice->SetPixel(ptDevice, x, y, 1);


	/* 4. Flush */
	ptDevice->Flush(ptDevice);
}
```

# 风扇设备源码讲解

## 硬件操作原理

![[扩展板原理图_F103_Extend_V2.pdf#page=1&rect=75,608,172,695|扩展板原理图_F103_Extend_V2, p.1]]

|       | INA | INB |
| ----- | --- | --- |
| 顺时针旋转 | 0   | 1   |
| 逆时针旋转 | 1   | 0   |
| 停止    | 0   | 0   |
| 停止    | 1   | 1   |
## 代码讲解

```shell
从上到下涉及的文件:
		smartdevice\unittest\fan_test.c
		smartdevice\device\fan_device.c
		smartdevice\kal\kal_fan_device.c
		smartdevice\cal\cal_fan_device.c
		ModuleDrivers\driver_fan.c
```

## 单元测试

`smartdevice\unittest\fan_test.c`：

```c
/**********************************************************************
 * 函数名称： fan_test
 * 功能描述： 设备系统风扇设备单元测试函数
 * 输入参数： 无
 * 输出参数： 无
 * 返 回 值： 无
 * 修改日期       版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2021/10/18	     V1.0	  韦东山	      创建
 ***********************************************************************/
void fan_test(void)
{
	PFANDevice ptDev = GetFANDevice();

	/* 初始化设备 */
	ptDev->Init(ptDev);

	while (1)
	{
		/* 顺时针旋转 */
		ptDev->SetSpeed(ptDev, 1);
		KAL_Delay(2000);
		
		/* 停止 */
		ptDev->SetSpeed(ptDev, 0);
		KAL_Delay(2000);

		/* 逆时针旋转 */
		ptDev->SetSpeed(ptDev, -1);
		KAL_Delay(2000);		
		
		/* 停止 */
		ptDev->SetSpeed(ptDev, 0);
		KAL_Delay(2000);
	}
}
```