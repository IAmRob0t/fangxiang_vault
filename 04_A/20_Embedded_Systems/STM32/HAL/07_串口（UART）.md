---
tags:
  - HAL
deadline: 2025-04-09
---
# Tasks

- [x] 07-3-4串口编程_DMA方式 [due:: 2025-04-12] [started:: 2025-04-12] [priority:: critical] [completed:: 2025-04-12]
 - 07-4使用DMA+IDLE中断接收数据
 - 07-5完善UART程序与stdio

# 同步传输与异步传输

## 概念与示例

使用生活例子来说明什么是同步、异步：
- 同步：朋友打电话说到我家吃饭，我在家里等他们
- 异步：朋友没有提前打招呼，突然就到我家来了

它们的差别在于：有没有使用一种方法“实现约好时间”。

在电子产品中，使用同步传输时，一般涉及两个信号：
1. 时钟信号：用来通知对方要读取数据了
2. 数据信号：用来传输数据

![[HAL快速入门与项目实战.pdf#page=76&rect=89,134,480,553|HAL快速入门与项目实战, p.76|584]]

---

以红外遥控器解码器为例，它向单片机发出的数据格式如下：
- 起始信号：解码器发出一个 9ms 的低电平、4.5ms 的高电平，用来通知对方说"开始了"
	- ![[HAL快速入门与项目实战.pdf#page=77&rect=233,645,353,738|HAL快速入门与项目实战, p.77|224]]
- 表示一位数据
	- 逻辑 1：0.56ms 的低电平+1.69ms 的高电平
	- 逻辑 0：0.56ms 的低电平+0.56ms 的高电平
	- ![[HAL快速入门与项目实战.pdf#page=77&rect=135,507,446,594|HAL快速入门与项目实战, p.77|516]]

## 差别

|       | 同步传输          | 异步传输      |
| ----- | ------------- | --------- |
| 信号线   | 多：时钟信号、数据信号   | 少：只需要数据信号 |
| 速率    | 可变，提高时钟信号频率即可 | 双方提前约定    |
| 抗干扰能力 | 强             | 弱         |

> [!NOTE] 抗干扰能力也取决于协议的设计，有些异步传输的协议也设计得比较好，抗干扰能力强

# UART 协议与操作方法

## UART 协议

通用异步收发器简称 UART，即“Universal Asynchronous Receiver Transmitter”，它用来传输串行数据：发送数据时，CPU 将并行数据写入 UART，UART 按照一定的格式在一根电线上串行发出；接收数据时，UART 检测另一根电线上的信号，将串行数据收集放在缓冲区中，CPU 即可读取 UART 获得这些数据。UART 之间以全双工方式传输数据，最精简的连线方法只有三根电线：TxD 用于发送数据，RxD 用于接收数据，GND 用于给双方提供参考电平，连线如图所示：

![[HAL快速入门与项目实战.pdf#page=78&rect=165,493,428,630|HAL快速入门与项目实战, p.78|525]]

TxD 、 RxD 数据线以“位”为最小单位传输数据。**帧 (frame)** 由具有完整意义的、不可分割的若干位组成，它包含**开始位、数据位、较验位 (需要的话) 和停止位**。发送数据之前， UART 之间要约定好数据的**传输速率** (即每位所占据的时间，其倒数称为波特率)、数据的**传输格式** (即有多少个数据位、是否使用较验位、是奇较验还是偶较验、有多少个停止位)。

数据传输流程如下：
1. 平时数据线处于“空闭”状态(1 状态)。
2. 当要发送数据时，UART 改变 TxD 数据线的状态(变为 0 状态)并维持 1 位的时间（$\frac{1}{115200} S$）——这样接收方检测到开始位后，再等待 1.5 位的时间就开始一位一位地检测数据线的状态得到所传输的数据。
3. UART 一帧中可以有 5、6、7 或 8 位的数据，发送方一位一位地改变数据线的状态将它们发送出去，**首先发送最低位**。
4. 如果使用较验功能，UART 在发送完数据位后，还要发送 1 个较验位。有两种较验方法： 奇较验、偶较验——数据位连同较验位中，“1”的数目等于奇数或偶数。[^1]
5. 最后，发送停止位，数据线恢复到“空闭”状态(1 状态)。停止位的长度有 3 种：1 位、 1.5 位、2 位。
	- 一般选择 1 位停止位就够了，性能较低的芯片选择较长的停止位。

---

- STM32F103xx 起始位是如何判断的？

![[STM32F103xx参考手册(英文原版).pdf#page=794&rect=122,396,528,647|STM32F103xx参考手册(英文原版), p.794|542]]

将会发起连续的 16 次的判断，前 7 次至少有 2 个 0，中间 3 次至少有 2 个 0

---

- STM32F103xx 数据位是如何判断？（1 bit 的时间）

![[STM32F103xx参考手册(英文原版).pdf#page=796&rect=120,259,531,411|STM32F103xx参考手册(英文原版), p.796|487]]

如果 1 个数据位只是在它中间进行检测将会不严谨，所以采用在 1 位中进行 16 次检测。只在乎中间那 3 次，如果有两次 0 就认为是 0；如果有两次 1 则认为是 1；如果 2 次都一样最好。

---

UART 使用标准的 **TTL/CMOS 逻辑电平** (0～5V、0～3.3V、0～2.5V 或 0～1.8V 四种) 来表示数据，高电平表示 1，低电平表示 0。进行长距离传输时，为了增强数据的抗干扰能力、提高传输长度，通常[^2] 将 TTL/CMOS 逻辑电平转换为 **RS-232 逻辑电平**，3～12V 表示 0，-3～- 12V 表示 1。

下图演示了 UART 使用 7 个数据位、偶较验、2 个停止位的格式传输字符“A”(二进制值为 0b01000001) 时，TTL/CMOS 逻辑电平、RS-232 逻辑电平对应的波形。

![[HAL快速入门与项目实战.pdf#page=79&rect=120,374,476,769|HAL快速入门与项目实战, p.79|358]]

传 $1 byte = \frac{1}{115200} * 10 = \frac{1}{11520} S$

### 波特率和比特率

双方约定了“传输 1 bit 数据的时间”，就可以算出 1 秒内能传输多少 bit 数据，这被称为“比特率”，又经常被称为“波特率”。两者有什么关系？

假设发送方 A 能精确控制信号的电压，接收方 B 也能精确识别电压，双方如此约定：

| 电压范围     | 表示的两 bit 的数据 |
| -------- | ------------ |
| 0~0.7V   | 0b00         |
| 0.8~1.5V | 0b01         |
| 1.6~2.3V | 0b10         |
| 2.4~3.3V | 0b11         |

那么要传输一个字节的数据，比如 0x78，它的二进制数为 0b01,11,10,00，只需要传输 4 次（假设 1ms 改变一次电压，假设先传输低位）：
1. 第 1ms，A 设置电压为 0V，B 识别出电压后，认为收到了 bit1 为 0、bit0 为 0
2. 第 2ms，A 设置电压为 1.6V，B 识别出电压后，认为收到了 bit3 为 1、bit2 为 0
3. 第 3ms，A 设置电压为 2.4V，B 识别出电压后，认为收到了 bit5 为 1、bit4 为 1
4. 第 4ms，A 设置电压为 0.8V，B 识别出电压后，认为收到了 bit7 为 0、bit6 为 1

只需要 4ms，就传输了 4 个状态，但是传输了 8bit 数据：`波特率*2=比特率`。

假设发送方 A 精确控制信号电压的能力比较差，只能保证 0~0.7V、1.8~3.3V 的电压比较稳定；接收方 B 识别电压的能力也不够精确，只能保证可以识别出 0~0.7V、1.8~3.3V 的电压，于是双方约定：

| 电压范围     | 表示的 1 bit 数据 |
| -------- | ------------ |
| 0~0.7V   | 0            |
| 1.8~3.3V | 1            |

那么要传输一个字节的数据，比如 0x78，它的二进制数为 0b01111000，需要传输 8 次 （假设 1ms 改变一次电压，假设先传输低位）：
1. 第 1ms，A 设置电压为 0V，B 识别出电压后，认为收到了 bit0 为 0
2. 第 2ms，A 设置电压为 0V，B 识别出电压后，认为收到了 bit1 为 0
3. 第 3ms，A 设置电压为 0V，B 识别出电压后，认为收到了 bit2 为 0
4. 第 4ms，A 设置电压为 3.3V，B 识别出电压后，认为收到了 bit3 为 1
5. 第 5ms，A 设置电压为 3.3V，B 识别出电压后，认为收到了 bit4 为 1
6. 第 6ms，A 设置电压为 3.3V，B 识别出电压后，认为收到了 bit5 为 1
7. 第 7ms，A 设置电压为 3.3V，B 识别出电压后，认为收到了 bit6 为 1
8. 第 8ms，A 设置电压为 0V，B 识别出电压后，认为收到了 bit7 为 0

需要 8ms，传输 8 个状态，传输了 8bit 数据：波特率=比特率。

所以，波特率：1 秒内传输信号的状态数（波形数）。比特率：1 秒内传输数据的 bit 数。如果一个波形，能表示 N 个 bit，那么：`波特率 * N = 比特率` 。

## STM32 UART 硬件结构

在实际中，不需要将数据位一位一位地发送或读取，我们有专门的硬件来做这件事情

![[STM32F103xx参考手册(英文原版).pdf#page=789&rect=67,232,529,755|STM32F103xx参考手册(英文原版), p.789|606]]

([[STM32F103xx参考手册(英文原版).pdf#page=821&selection=12,0,12,30&color=yellow|📖]])
图中的 CR1 即 Control register 1 (USART_CR1)
- M: Word length
- PCE: Parity control enable
- PS: Parity selection

([[STM32F103xx参考手册(英文原版).pdf#page=823&selection=12,0,12,30&color=yellow|📖]])
Control register 2 (USART_CR2)
- STOP: STOP bits

([[STM32F103xx参考手册(英文原版).pdf#page=824&selection=14,0,14,30&color=yellow|📖]])
Control register 3 (USART_CR3)

如何使用？
1. 设置传输速率、传输格式
	- 例如 115200, 8n1 —— 115200 指波特率，8 代表数据位是 8 位，n 代表不用校验位，1 代表停止位是 1 位
2. 发送数据
	- 先写数据Val ->(写入) Transmit Data Register (TDR) -> Transmit Shift Register -> 逐位发送
	- 判断状态： TDR 空、Shift Reg: ([[STM32F103xx参考手册(英文原版).pdf#page=818&selection=173,0,174,23&color=yellow|📖]])TC
3. 读数据
	- 分辨状态：([[STM32F103xx参考手册(英文原版).pdf#page=818&selection=184,0,185,30&color=yellow|📖]])RXNE
	- 读数据：RDR

也可以使用中断
([[STM32F103xx参考手册(英文原版).pdf#page=821&selection=191,0,192,22&color=yellow|📖]])
TXEIE: TXE interrupt enable
([[STM32F103xx参考手册(英文原版).pdf#page=822&selection=17,0,18,23&color=yellow|📖]])
RXNEIE: RXNE interrupt enable

# UART 编程

## 硬件连接

要是串口，请按照下图连线：底板的 TXD、RXD 和 USB 串口 RXD、TXD 交叉连接，GND 要互相连接。注意：ST-Link 也要保持连接，我们使用 ST-Link 进行供电、烧录、调试。

![[HAL快速入门与项目实战.pdf#page=82&rect=113,459,513,655|HAL快速入门与项目实战, p.82|571]]


## 使用串口工具
 
![[HAL快速入门与项目实战.pdf#page=84&rect=108,410,423,663|HAL快速入门与项目实战, p.84|481]]

## 三种编程方式

结合 UART 硬件结构，有 3 种编程方法：
1. **查询方式**
	- 要发送数据时，先把数据写入 TDR 寄存器，然后判断 TDR 为空再返回。当然也可以先判断 TDR 为空，再写入。
	- 要读取数据时，先判断 RDR 非空，再读取 RDR 得到数据。
2. **中断方式**
	- 使用中断方式，效率更高，并且可以在接收数据时避免数据丢失。
	- 要发送数据时，使能“TXE”中断（发送寄存器空中断）。在 TXE 中断处理函数里，从程序的发送 buffer 里取出一个数据，写入 TDR。等再次发生 TXE 中断时，再从程序的发送 buffer 里取出下一个数据写入 TDR，发送完成后再去禁止中断。
	- 对于接收数据，在一开始就 **使能“RXNE”** 中断（接收寄存器非空）。这样，UART 接收到一个数据就会触发中断，在中断程序里读取 RDR 得到数据，存入程序的接收 buffer。当程序向读取串口数据时，它**直接读取**接收 buffer 即可。
	- 这里涉及的“发送 buffer”、“接收 buffer”，特别适合使用“环形 buffer”。
3. **DMA 方式**
	- 使用中断方式时，在传输、接收数据时，会发生中断，还需要 CPU 执行中断处理函数。有另外一种方法：DMA（Direct Memory Access），它可以直接在 2 个设备之间传递数据，无需 CPU 参与。
	- ![[HAL快速入门与项目实战.pdf#page=85&rect=114,419,419,703|HAL快速入门与项目实战, p.85|453]]
	- 设置好 DMA（源、目的、地址增减方向、每次读取数据的长度、读取次数）后，DMA 就会自动地在 SRAM 和 UART 之间传递数据：
		1. 发送时：DMA 从 SRAM 得到数据，写入 UART 的 TDR 寄存器
		2. 接收时：DMA 从 UART 的 RDR 寄存器得到数据，写到 SRAM 去
		3. 指定的数据传输完毕后，触发 DMA 中断；在数据传输过程中，没有中断，CPU 无需处理。

- 函数如下：

|     | 查询方式                                                                                                   | 中断方式                                                | DMA 方式                                                                                |
| --- | ------------------------------------------------------------------------------------------------------ | --------------------------------------------------- | ------------------------------------------------------------------------------------- |
| 发送  | ([[STM32F1HAL库和LL库用户手册.pdf#page=551&selection=50,45,50,65&color=yellow\|📖]])<br>`HAL_UART_Transmit()` | `HAL_UART_Transmit_IT`<br>`HAL_UART_TxCpltCallback` | `HAL_UART_Transmit_DMA`<br>`HAL_UART_TxHalfCpltCallback`<br>`HAL_UART_TxCpltCallback` |
| 接收  | ([[STM32F1HAL库和LL库用户手册.pdf#page=551&selection=53,48,53,67&color=yellow\|📖]])<br>`HAL_UART_Receive ()` | `HAL_UART_Receive_IT`<br>`HAL_UART_RxCpltCallback`  | `HAL_UART_Receive_DMA`<br>`HAL_UART_RxHalfCpltCallback`<br>`HAL_UART_RxCpltCallback`  |
| 错误  |                                                                                                        | `HAL_UART_ErrorCallback`                            | `HAL_UART_ErrorCallback`                                                              |

## 查询方式

本节程序源码为“0701_uart_poll”，在“0604_key_circle_buffer”的基础上修改得来。

缺点：发送数据时要死等发送完毕，接收数据时容易丢失。

## 中断方式

本节程序源码为“0702_uart_interrupt”，在“0701_uart_poll”的基础上修改得来。

使用查询方式可能会产生数据丢失的情况，可以使用中断方式。但当调用中断方式及的 `HAL_UART_Receive_IT` 时，也需要有一个函数来调用，如果不能及时被调用的话，数据也会丢失，所以这个函数没有什么实际的作用，在实际的工作场景中我们根本就不用，我们得自己去实现一套。

1. 调用函数 `HAL_UART_Transmit_IT` 只是去使能中断
2. 发生 999 次 TXE 中断
3. 发生一次 TC 中断

## 中断方式改造

本节程序源码为“0703_uart_circle_buffer”，在“0702_uart_interrupt”的基础上修改得来。

由于我们的程序没有及时地调用接收函数 `HAL_UART_Receive_IT` 导致数据地丢失

1. 一开始就使能接收中断
2. 接收中断里，把数据存入环形 buffer

## DMA 方式

本节讲的是传统 DMA 方式，不涉及“idle 中断”，它会在后面讲解。

本节程序源码为“0704_uart_dma”，在“0703_uart_circle_buffer”的基础上修改得来。

---

无论是使用查询方式还是使用中断方式，都离不开 CPU 的处理，这种方式会使 CPU 不能专注地解决问题。我们可以使用 DMA，DMA 可以帮助 CPU 从 RAM 中读取数据，传输到 UART，也可以从 UART 读取数据到 RAM

- 发送
	- 源：`char tx_buf[1000];` ，源累加，1 字节 / 2 字节
	- 目的：TDR，不变
	- 长度：1000
- 接收
	- 源：RDR，不变
	- 目的：`char rx_buf[1000];` ，目的累加，1 字节 / 2 字节
	- 长度：1000

使用传统的 DMA 方式接收数据没有意义，



如果发送方发送第一个数据时卡壳了，无法在 10bit 时间内发送第二个数据，对这种情况 IDEL 中断就没什么意义。所以说，使用 IDEL 中断是在**传输大量数据**的时候才有意义。

---

无论是使用查询方式还是使用中断方式，都离不开 CPU 的处理，这种方式会使 CPU 不能专注地解决问题。我们可以使用 DMA，DMA 可以帮助 CPU 从 RAM 中读取数据，传输到 UART，也可以从 UART 读取数据到 RAM

- 发送
	- 源：`char tx_buf[1000];` ，源累加，1 字节 / 2 字节
	- 目的：TDR，不变
	- 长度：1000
- 接收
	- 源：RDR，不变
	- 目的：`char rx_buf[1000];` ，目的累加，1 字节 / 2 字节
	- 长度：1000

使用传统的 DMA 方式接收数据没有意义，

# UART IDLE中断的使用

## IDLE 中断
 
UART 的 IDLE 中断何时发生？RxD 引脚一开始就是空闲的啊，难道 IDLE 中断一直产生？ 不是的。当我们使能 IDLE 中断后，它并不会立刻产生，而是：至少收到 1 个数据后，发现在一个字节的时间里，都没有接收到新数据，才会产生 IDLE 中断。

IDLE 空闲的定义是：**总线上在一个字节（10bit）的时间内没有再接收到数据**。 

我们使用 DMA 接收数据时，确实可以提高 CPU 的效率，但是“无法预知要接收多少数据”，而我们想尽快处理接收到的数据。怎么办？比如我想读取 100 字节的数据，但是接收到 60 字节后对方就不再发送数据了，怎么办？我们怎么判断数据传输中止了？可以使用 IDLE 中断。在这种情况下，DMA 传输结束的条件有 3：
1. 接收完指定数量的数据了，比如收到了 100 字节的数据了，`HAL_UART_RxCpltCallback` 被调用
2. 总线空闲了：`HAL_UARTEx_RxEventCallback` 被调用
3. 发生了错误：`HAL_UART_ErrorCallback` 被调用

如果发送方发送第一个数据时卡壳了，无法在 10bit 时间内发送第二个数据，对这种情况 IDEL 中断就没什么意义。所以说，使用 IDEL 中断是在**传输大量数据**的时候才有意义。使用 IDLE 状态来接收的函数有：

|        | 函数                             | 回调函数                                                                                                           |
| ------ | ------------------------------ | -------------------------------------------------------------------------------------------------------------- |
| 查询方式   | `HAL_UARTEx_ReceiveToIdle`     | 根据返回参数 `RxLen` 判断是否接收完毕，还是因为空闲而返回                                                                              |
| 中断方式   | `HAL_UARTEx_ReceiveToIdle_IT`  | 完毕：`HAL_UART_RxCpltCallback` 因为空闲而中止： `HAL_UARTEx_RxEventCallback`                                             |
| DMA 方式 | `HAL_UARTEx_ReceiveToIdle_DMA` | 传输一半： `HAL_UART_RxHalfCpltCallback` <br>完毕： `HAL_UART_RxCpltCallback`<br>因为空闲而中止： `HAL_UARTEx_RxEventCallback` |
| 错误     |                                | `HAL_UART_ErrorCallback`                                                                                       |

## 使用 DMA+IDLE 接收数据

本节程序源码为“0705_uart_dma_idle”，在“0704_uart_dma”的基础上修改得来。

# 完善程序与 `stdio`

本节程序源码为“0706_uart_stdio”，在“0705_uart_dma_idle”的基础上修改得来。先配置使用 MicroLib 时：

![[HAL快速入门与项目实战.pdf#page=88&rect=134,480,481,704|HAL快速入门与项目实战, p.88|523]]

然后只需要实现这 2 个函数：

```c
int fputc (int ch, FILE* stream);
int fgetc (FILE *f);
```

参考：

[Documentation – Arm Developer](https://developer.arm.com/documentation/dui0475/f/?lang=en)

还需要实现 `__backspace ()` ，全部代码如下：

```c
int fputc (int ch)
```

`printf \ scanf`
1. 标准库
2. MiroLib
3. 自己写

---

[^1]: Tips：现在我们信号的传输能力越来越强，越来越可靠，都不需要去校验了，但是协议的东西还是得了解。

[^2]: 使用电平转换芯片，例如 MAX232。但是现在基本不使用 RS232 接口，可以通过 USB 转串口的芯片，例如 CP2104、CH340
