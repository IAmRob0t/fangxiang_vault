---
tags:
  - stm32
---

在STM32F103微控制器中，C语言的地址和值存储机制紧密依赖于其ARM Cortex-M3内核的内存架构和硬件设计。以下是对其存储机制的深入解析：

---

# 内存映射与地址空间

STM32F103的地址空间分为以下关键区域：
- **Flash存储器**（0x0800 0000 - 0x0807 FFFF）：存储程序代码和只读数据（如`const`变量）。
- **SRAM**（0x2000 0000 - 0x2000 4FFF）：存储运行时数据（全局变量、栈、堆）。
- **外设寄存器**（0x4000 0000 - 0x5003 FFFF）：通过内存映射访问硬件外设（如GPIO、USART）。
- **位带区域**（0x4200 0000 - 0x43FF FFFF）：允许通过位带别名实现原子位操作。

# 变量的存储位置

## 1. 全局变量与静态变量

- **初始化的全局变量**：存储在`.data`段（SRAM），初始值从Flash复制到SRAM。
- **未初始化的全局变量**：存储在`.bss`段（SRAM），启动时清零。
- **静态变量**（包括函数内的`static`变量）：存储方式与全局变量类似，但作用域受限。

## 2. 局部变量

- **栈（Stack）**：默认位于SRAM的高地址区域（向下生长），存放函数参数、返回地址和局部变量。
  - 栈大小由启动文件（如`startup_stm32f10x.s`）配置，溢出会导致未定义行为。
  
## 3. 动态分配的内存

- **堆（Heap）**：位于`.bss`段之后，通过`malloc`/`free`管理，需手动控制内存碎片。

# 外设寄存器的访问

外设寄存器通过**内存映射I/O**访问，使用 `volatile` 关键字防止编译器优化：

```c
#define GPIOA_BASE 0x40010800
typedef struct {
	volatile uint32_t CRL;   // 端口配置低寄存器（地址偏移0x00）
	volatile uint32_t CRH;   // 端口配置高寄存器（地址偏移0x04）
	// 其他寄存器...
} GPIO_TypeDef;

GPIO_TypeDef *GPIOA = (GPIO_TypeDef *)GPIOA_BASE;
GPIOA->CRL |= 0x3; // 修改GPIOA的CRL寄存器
```

# 地址对齐与访问方式

- **对齐要求**：32位数据需4字节对齐，16位数据需2字节对齐。未对齐访问会触发硬件异常（如`HardFault`）。
- **访问方式**：
  - **字节访问**：`uint8_t *ptr = (uint8_t *)0x20000000;`
  - **半字访问**：`uint16_t *ptr = (uint16_t *)0x20000000;`
  - **字访问**：`uint32_t *ptr = (uint32_t *)0x20000000;`

# 位带操作

Cortex-M3支持**位带（Bit-Banding）**，允许通过别名地址原子操作单个位：
```c
// 将SRAM地址0x20000000的第1位映射到位带别名区
#define BITBAND_SRAM(address, bit) (0x22000000 + ((address - 0x20000000) * 32) + (bit * 4))

volatile uint32_t *bitband_var = (uint32_t *)BITBAND_SRAM(0x20000000, 1);
*bitband_var = 1; // 原子操作：将0x20000000地址的位1置1
```

# 指针与地址操作

- **指针的本质**：存储内存地址的变量，类型决定了解引用时的访问方式。

```c
uint32_t *ptr = (uint32_t *)0x20000000; // 指向SRAM起始地址
*ptr = 0x12345678; // 写入32位数据
```

- **函数指针**：指向代码段的地址，用于回调或跳转：

```c
void (*func_ptr)(void) = (void (*)(void))0x08000000;
func_ptr(); // 跳转到Flash地址0x08000000执行
```

#  链接脚本与内存分配

链接脚本（如`.ld`文件）定义内存布局：
- 指定Flash和SRAM的起始地址及大小。
- 分配`.text`（代码）、`.data`、`.bss`等段的存储位置。
- 控制栈和堆的起始地址及大小。

# 调试与地址查看

- **Map文件**：编译生成的`.map`文件显示所有符号的地址。
- **调试器**：通过IDE（如STM32CubeIDE）查看变量和寄存器的实时地址与值。

# 常见问题与优化

- **栈溢出**：通过填充模式（如`0xDEADBEEF`）检测。
- **内存泄漏**：避免频繁`malloc`/`free`，使用静态分配或内存池。
- **性能优化**：对齐关键数据、使用DMA减少CPU负载。

# 总结

STM32F103的存储机制结合了ARM架构特性与硬件设计，理解其内存映射、变量存储类别、外设访问及地址操作是开发高效嵌入式系统的关键。通过合理利用链接脚本、调试工具和硬件特性，可以显著提升代码的可靠性和性能。