---
title: 嵌入式软件出现内存泄漏的时候，如何进行排查和分析？
source: https://mp.weixin.qq.com/s/mI9ugo-z8Z2GSAYUx_btaw
author:
  - "[[微信公众平台]]"
published: 
created: 2025-04-02
description: 
tags:
  - clippings
  - c
---
*2025年01月10日 17:50* *广东*

```
我是老温，一名热爱学习的嵌入式工程师
关注我，一起变得更加优秀！
```

# 内存泄漏问题原理

## 1. 堆内存在C代码中的存储方式

内存泄漏问题只有在使用堆内存的时候才会出现，栈内存不存在内存泄漏问题，因为栈内存会自动分配和释放。C代码中堆内存的申请函数是malloc，常见的内存申请代码如下：

```
char *info = NULL;    /**转换后的字符串**/
info = (char*)malloc(NB_MEM_SPD_INFO_MAX_SIZE);
if( NULL == info)
{
    (void)tdm_error("malloc error!\n");
    return NB_SA_ERR_HPI_OUT_OF_MEMORY;
}
```

由于malloc函数返回的实际上是一个内存地址，所以保存堆内存的变量一定是一个指针（除非代码编写极其不规范）。

再重复一遍，保存堆内存的变量一定是一个指针，这对本文主旨的理解很重要。当然，这个指针可以是单指针，也可以是多重指针。

malloc函数有很多变种或封装，如g\_malloc、g\_malloc0、VOS\_Malloc等，这些函数最终都会调用malloc函数。

## 2. 堆内存的获取方法

看到本小节标题，可能有些同学有疑惑，上一小节中的malloc函数，不就是堆内存的获取方法吗？

的确是，通过malloc函数申请是最直接的获取方法，如果只知道这种堆内存获取方法，就容易掉到坑里了。一般的来讲，堆内存有如下两种获取方法：

方法一：将函数返回值直接赋给指针，一般表现形式如下：

```
char *local_pointer_xx = NULL;
local_pointer_xx = (char*)function_xx(para_xx, …);
```

该类涉及到内存申请的函数，返回值一般都指针类型，例如：

```
GSList* g_slist_append (GSList   *list, gpointer  data);
```

方法二：将指针地址作为函数返回参数，通过返回参数保存堆内存地址，一般表现形式如下：

```
int ret;
char *local_pointer_xx = NULL;    /**转换后的字符串**/
ret = (char*)function_xx(..., &local_pointer_xx, ...);
```

该类涉及到内存申请的函数，一般都有一个入参是双重指针，例如：

```
__STDIO_INLINE _IO_ssize_t;
getline (char **__lineptr, size_t *__n, FILE *__stream);
```

前面说通过malloc申请内存，就属于方法一的一个具体表现形式。其实这两类方法的本质是一样的，都是函数内部间接申请了内存，只是传递内存的方法不一样，方法一通过返回值传递内存指针，方法二通过参数传递内存指针。

## 3. 内存泄漏三要素

最常见的内存泄漏问题，包含以下三个要素：

要素一：函数内有局部指针变量定义；

要素二：对该局部指针有通过上一小节中“两种堆内存获取方法”之一获取内存；

要素三：在函数返回前（含正常分支和异常分支）未释放该内存，也未保存到其它全局变量或返回给上一级函数。

## 4. 内存释放误区

稍微使用过C语言编写代码的人，都应该知道堆内存申请之后是需要释放的。但为何还这么容易出现内存泄漏问题呢？

一方面，是开发人员经验不足、意识不到位或一时疏忽导致；另一方面，是内存释放误区导致。很多开发人员，认为要释放的内存应该局限于以下两种：

1） 直接使用内存申请函数申请出来的内存，如malloc、g\_malloc等；

2）该开发人员熟悉的接口中，存在内存申请的情况，如iBMC的兄弟，都应该知道调用如下接口需要释放list指向的内存：

```
dfl_get_object_list(const char* class_name, GSList **list);
```

按照以上思维编写代码，一旦遇到不熟悉的接口中需要释放内存的问题，就完全没有释放内存的意识，内存泄漏问题就自然产生了。

# 内存泄漏问题检视方法

检视内存泄漏问题，关键还是要养成良好的编码检视习惯。与内存泄漏三要素对应，需

要做到如下三点：

1） 在函数中看到有局部指针，就要警惕内存泄漏问题，养成进一步排查的习惯

2） 分析对局部指针的赋值操作，是否属于前面所说的“两种堆内存获取方法”之一，如果是，就要分析函数返回的指针到底指向啥？

是全局数据、静态数据还是堆内存？对于不熟悉的接口，要找到对应的接口文档或源代码分析；又或者看看代码中其它地方对该接口的引用，是否进行了内存释放；

3） 如果确认对局部指针存在内存申请操作，就需要分析该内存的去向，是会被保存在全局变量吗？又或者会被作为函数返回值吗？如果都不是，就需要排查函数所有有”return“的地方，保证内存被正确释放。

*原文：* *https://my.oschina.net/u/4526289/blog/4539592*