---
tags:
  - K210
---

# 第一个程序：使用屏幕和摄像头

```python
import sensor, lcd
#首先导入内置的`sensor`（摄像头）库和`lcd`（屏幕）库

sensor.reset()						#初始化摄像头，这里失败需要检查硬件
sensor.set_pixformat(sensor.RGB565)	#设置摄像头为`RGB565`格式，默认都是用`RGB565`即可
sensor.set_framesize(sensor.QVGA)	#分辨率为`QVGA`，即`320x240`
sensor.run(1)#开始运行，在现在的版本中也可以不调用，在上面设置完成后，摄像头会自动开始运行
sensor.skip_frames()			#摄像头刚启动时，图像质量还没稳定，所以跳过一些图像

lcd.init(freq=15000000)#初始化 LCD， 这里传了一个参数叫`freq`即频率， 是指定驱动 LCD 的时钟频率，这里是`15MHz`，可以根据硬件性能调整

while(True):
    lcd.display(sensor.snapshot())
#`sensor.snapshot()`:从摄像头取一帧图像数据，返回值是一张图像的对象
#`lcd.display()`： 显示图像到 LCD
```

除了以上的函数，你可能还需要设置图像为镜像（`hmirror`)，比如前置摄像头；或者上下翻转(`vflip`)，以及白平衡等等，具体看 [[sensor-摄像头]]

# 第二个程序：点亮 LED 灯

## 1. 外设到引脚的映射： FPIOA(现场可编程 IO 阵列， Field Programmable Input and Output Array)

可能你曾经用过一些单片机，在手册上都规定了引脚和片上外设功能（就是芯片内部集成的外设，比如 `GPIO`、`I2C`、`SPI` 等）的绑定，或者重映射。比如规定了 `I2C` 只能用 `Pin9` 和 `Pin10`，启动了重映射功能后，只能用 `Pin11` 和 `Pin12`

但是 MaixPy 所使用的硬件 K210 的片上外设对应的引脚（硬件引脚）是可以**任意映射**的，相比之下 K210 硬件设计和软件设计的自由度更大。比如 `I2C` 可以使用 `Pin11` 和 `Pin12`，也可以改成其它任意引脚

> 注意要区分 `GPIO` 和 `IO` 的区别， `IO` 也可以叫 `Pin` 也就是引脚，是芯片引出来的硬件引脚，而 `GPIO` 是一种外设，可以控制这些 `Pin/IO` 的外设

因为有了这个强大的映射功能，所以在使用引脚时，需要增加一步映射的步骤：

```python
from fpioa_manager import fm    # 导入库
fm.register(28, fm.fpioa.GPIO0)
```

这里我们将引脚 `28` 映射为了 `GPIO0` 的功能, 执行了这句命令后，引脚`28`和`GPIO0`就映射（绑定）好了，要取消映射（解绑），则需要调用`fm.unregister`函数，具体看`API`文档，这里不介绍

另外，`Pin` 和外设只能**唯一**对应，不能一对多，需要对同一个外设或者引脚重复映射，否则程序可能产生难以发现的错误（`BUG`）

## 2. 代码

>  `board_info` 与板卡相关，不同板卡配置不同，使用前需要[手动配置](https://wiki.sipeed.com/soft/maixpy/zh/api_reference/builtin_py/board_info.html)。

程序如下：

```python
from fpioa_manager import fm
from Maix import GPIO

io_led_red = 13
fm.register(io_led_red, fm.fpioa.GPIO0)

led_r=GPIO(GPIO.GPIO0, GPIO.OUT)
led_r.value(0)
```

接下来我们分析代码：

- 从 `fpioa_manager` 包导入`fm` 对象，主要用于引脚和外设的映射
- 从包 `Maix` 导入了 `GPIO` 这个类， GPIO 外设相关操作
- 定义一个变量`io_led_red`，值为`13`，即`Pin13/IO13`, 具体 LED 的引脚连接到了芯片的哪个引脚，请在前面的开发板介绍中看原理图
- 使用`fm`(fpioa manager 的缩写)这个内置的对象来注册芯片的外设和引脚的对应关系，　这里　`fm.fpioa.GPIO0` 是　K210 的一个 GPIO 外设（`注意区分 GPIO（外设） 和引脚（实实在在的硬件引脚）的区别` ）， 所以把 `fm.fpioa.GPIO0` 注册到了 引脚 `IO13`；
- 然后定义一个 `GPIO` 对象`led_r`， 具体参数看 `GPIO` API 文档， 在左边侧边栏查找。
- 使用 `led_r.value(1)` 或者 `led_r.value(0)` 来设置高低电平即可, 因为这里设置了低电平，根据上面的原理图可知低电平导通，LED 灯亮

# MaixPy 语法基础知识

## 1. 关于 MicroPython

MicroPython 是编程语言 Python3 的精简高效实现，语法和 Python3 保持一致，但只实现了 Python 标准库的一小部分，并且经过优化，可以在 MCU ， WIFI SOC 上等资源受限的环境中使用，所以我们在使用 MicroPython 需要了解其语法。

如果之前有 C/C++/Java (或任何其他语言)的编程经验，推荐  
[《廖雪峰的 Python 教程》](https://www.liaoxuefeng.com/wiki/1016959663602400)

## 2. REPL 和串口

断开开发板与 MaixPy IDE 的连接，否则串口会冲突！

## 3. MicroPython 基本语法

- [[01_Python基础#2. 变量|变量]]
- [[01_Python基础#`list` 和 `tuple`|list列表 和 tuple元组]]
- [[01_Python基础#条件判断|条件判断]]
- [[01_Python基础#循环|循环]]

- [[02_函数|函数]]
- [[03_高级特性#切片|切片]]
- [[06_面对对象编程|对象]]
- [[05_模块|模块]]

# 图像处理背景知识

## 1. 什么是摄像头？

什么是摄像头，说到底，就是一个将光学信号转变成电信号的一个装置。在计算机视觉中，最简单的相机模型是`小孔成像模型`：

![|375](https://wiki.sipeed.com/soft/maixpy/assets/other/Pinhole-camera.svg)

小孔模型是一种理想相机模型，没有考虑实际相机中存在的场曲、畸变等问题。但是在实际使用时，这些问题可以通过在标定的过程中引入 `畸变参数` 解决，所以小孔模型仍然是目前最广泛使用的相机模型。

图像透过镜头，照在一个感光芯片上，感光芯片可以把光照的波长和强度等信息转成计算机(数字电路)可以识别的数字信号，`感光元件` 是长这样的：

图像透过镜头，照在一个感光芯片上，感光芯片可以把光照的波长和强度等信息转成计算机(数字电路)可以识别的数字信号，`感光元件`是长这样的：

![camera sensor|475](https://wiki.sipeed.com/soft/maixpy/assets/other/sensor.png)

## 2. 什么是像素和分辨率？

感光元件是有很多个感光点构成的，比如有 `640` x `480` 个点，每个点就是一个像素，把每个点的像素收集整理起来，就是一副图片，那么这张图片的分辨率就是 640x480

## 3. 什么是帧率

帧率(FPS)就是每秒钟处理的图片数量，如果超过20帧，人眼就基本分辨不出卡顿。当然，如果用在机器上，帧率越高越好。

## 4. 什么是颜色

物理上，颜色就是不同波长的电磁波。

![sRGB rendering of the spectrum of visible light](https://wiki.sipeed.com/soft/maixpy/assets/other/1920px-Linear_visible_spectrum.svg.png)

|颜色|频率|波长|
|---|---|---|
|紫色|668–789 THz|380–450 nm|
|蓝色|631–668 THz|450–475 nm|
|青色|606–630 THz|476–495 nm|
|绿色|526–606 THz|495–570 nm|
|黄色|508–526 THz|570–590 nm|
|橙色|484–508 THz|590–620 nm|
|红色|400–484 THz|620–750 nm|

但是，根据人眼的视觉效果，可以通过 RGB，CMYK，HSB，LAB 色域，来将可见光的颜色描述出来。

## 5. RGB 三原色

三原色的原理不是物理原因，而是由于人的生理原因造成的。人的眼睛内有几种辨别颜色的锥形感光细胞，分别对黄绿色、绿色和蓝紫色(或称紫罗兰色)的光最敏感(波长分别为564、534和420纳米)。

所以 RGB 经常用于显示器上，用来显示图片。

- LAB 亮度-对比度

Lab颜色空间中，L亮度；a的正数代表红色，负端代表绿色；b的正数代表黄色，负端代表兰色。不像RGB色彩空间，Lab颜色被设计来接近人类视觉。

因此L分量可以调整亮度对，修改a和b分量的输出色阶来做精确的颜色平衡。

注意：在MaixPy的查找色块的算法中，运用的就是这个LAB模式！

- 光源的选择

如果你的机器是在工业上，或者24小时长时间运行的设备，保持一个稳定的光源是至关重要的，尤其在颜色算法中。亮度一变，整个颜色的值会变化的很大！

## 6. 镜头的焦距

因为图像是通过镜头的光学折射，照到感光元件上的。那么镜头就决定了，整个画面的大小和远近。一个最重要的参数就是焦距。

![focal_distance](https://wiki.sipeed.com/soft/maixpy/assets/other/focal_distance.jpg)

**镜头焦距**：是指镜头光学后主点到焦点的距离，是镜头的重要性能指标。镜头焦距的长短决定着拍摄的成像大小，视场角大小，景深大小和画面的透视强弱。当对同一距离远的同一个被摄目标拍摄时，镜头焦距长的所成的象大，镜头焦距短的所成的象小。注意焦距越长，视角越小。

还有一点是镜头的畸变，因为光学原理，在感光芯片上不同的位置，与镜头的距离不同的，简单说就是近大远小，所以在边缘会出现鱼眼效果(桶型畸变)。为了解决这个问题，可以在代码中使用算法来矫正畸变，注：MaixPy中使用image.lens_corr(1.8)来矫正2.8mm焦距的镜头。也可以直接使用无畸变镜头。无畸变镜头加入了额外的矫正透镜部分，价格自然会高不少。

## 7. 镜头的滤片

在镜头上，通常会有一个滤片。  

![camera sensor](https://wiki.sipeed.com/soft/maixpy/assets/other/sensor_1.png)

这个滤片是做什么的呢？

我们知道，不同颜色的光，是波长不一样。在正常环境中，除了可见光，还有很多红外光，在夜视中，用的就是红外光。

但是，在正常颜色应用中，是不需要红外光的，因为红外光也会使感光元件受到反应，就使得整个画面泛白。所以我们在镜头上放一个只能通过波长 650nm 以内的滤光片，将红外光进行过滤。

# 音频处理背景知识

[音频处理背景知识 - Sipeed Wiki](https://wiki.sipeed.com/soft/maixpy/zh/get_started/knowledge_audio.html)

# 存储系统介绍

MaixPy 存储系统大致如下图所示：

![](https://wiki.sipeed.com/soft/maixpy/assets/get_started/memory.png)

由上图可知，MaixPy 中的存储介质主要由 `Flash`，`SD` 卡组成，`flash` 分为三块区域，分别是 MaixPy.bin 固件区，xxx.kmodel 模型区，文件系统区：Flash 上为 [`spiffs`](https://github.com/pellepl/spiffs)（SPI Flash File System），SD 卡为 Fatfs （FAT file system）。

## 1. MaixPy.Bin 固件区

用来存储 MaixPy.bin 固件，起始于 0x000000，因为 K210 会从 0x000000 地址开始运行程序。

## 2. xxx.kmodel 模型区

通常起始于 0x300000，模型文件之所以不烧录在 `Flash` 的文件系统（文件系统会后续解释）中，原因有下：

1. `Flash` 中文件系统拥有的内存并不够大，不足以放入大模型，更大的模型可以放入 `SD` 卡中。
2. 直接读取模型文件比经过文件系统读取速率更快。

该区域没有文件系统管理，需要根据烧录时的起始地址操作文件，例如当模型烧录在 0x500000 时的读取方法：

```python
KpuTask = kpu.load(0x500000)
```

## 3. 文件系统区

通常从 0xD00000 开始，该区域交由文件系统管理，我们预留了 `Flash` 末尾的 `3MiB` 空间，交由 [`spiffs`](https://github.com/pellepl/spiffs) 管理，另外也支持 `FAT32`（Fatfs） 的 `SD` 卡。这些文件系统提供接口使我们通过 **文件名** 便可对文件进行读写操作，而不必像模型区那样使用 **文件起始地址** 操作。同时还能帮助我们有效管理存储介质，例如磨损均衡（Flash 是有磨损寿命的，相关知识请自行搜索）可以充分发挥 Flash 的寿命。

### 3.1. MaixPy 文件系统的使用

由于 `Flash` 和 `SD` 卡的文件系统各不相同，接口不一致，使得操作不同文件系统需要调用不同接口，此时 MaixPy 中的虚拟文件系统（VFS）正是用于解决该问题，`VFS` 可以挂载多个不同类型文件系统，并为用户操作这些文件系统提供统一接口，用户使用这些接口时可以忽略不同文件系统之间的差异。这些接口在 `os` 模块中实现，使用示例如下：

```python
import uos

print("files:", uos.listdir("/flash"))

with open("/flash/test.txt", "w") as f:
    f.write("hello text")

print("files:", uos.listdir("/flash"))

with open("/flash/test.txt", "r") as f:
    content = f.read()

print("read:", content)
```

以上示例中，`spiffs` 文件系统开机被自动挂载到 `/flash` 目录，用户只需要在使用 `os` 的接口时传入 `"/flash"` 目录名作为参数便可访问该文件系统。

解读：

- 导入 `uos` 模块
- 列出 `/flash` 目录下所有文件
- 向 `/flash` 目录写入一个名为 `test.txt` 的文件，内容为 `hello text`,
- 列出 `/flash` 目录下所有文件，会发现 `test.txt` 的存在
- 读取文件内容到 `content` 变量
- 打印 `content` 变量， 输出 `hello text`，也就是刚刚写入文件的内容
- 这个内容在开发板断电之后再上电，仍然能读到正确的内容（Flash 断电后不会丢失内容）

当然也支持 SD 卡， 如果你需要使用， SD 卡需要满足以下几点：

- 支持 `SPI` 模式, 市面上大多数正版卡都支持
- 分区为 `MBR （msdos）`
- 格式化为 `FAT32`
- 大小测试过最大 **`1TB`** 可用

断电插入 `SD` 后， 上电，`SD` 卡会被挂载在 `/sd`，如果有多个分区，第二个分区名是`/sd2`

注意`/`（根目录）不能写入数据，只能往`/flash`或者`/sd`写入数据  
开机如果有 `SD` 卡，会自动将当前目录切换到 `/sd`，如果没有，则会自动切换到 `/flash`

# 编辑并执行文件

## 1. MaixPy 内置了文件系统

前面说了， `MaixPy` 支持 `Flash` 使用的 `SPIFFS`（目前不支持创建目录）, 默认分配了 `3MB` 给 `SPIFF`（从`flash` `0xD00000`地址开始 `3M`）, 开机自动挂载到 `/flash` 目录下

也支持 `FAT32` 格式`MBR`分区的 `Micro SD （TF）`卡 ,开机自动挂在到 `/sd` 目录下

需要注意的是, 根目录只是用来挂载 Flash 或者 SD 卡, 具体的文件在 `/flash` 或者 `/sd` 目录下

## 2. 为什么需要编辑并执行文件

在前面的实验中,我们直接在终端里面敲代码来一句一句执行,这样也简单方便,我们输入命令后会立即执行并及时得到返回的结果,这种交互方式称为 **`REPL（Read Eval Print Loop：交互式解释器）`**,  这种方式的好处就是简单方便,使用起来和 Linux 终端十分相似,只是使用的语法换成了 MaixPy(Micropython)的语法。

但是在实际运行的时候，我们希望代码保存在文件系统，需要运行是直接运行文件，这样我们不用每次都敲代码,减少了很多麻烦

### 2.1. 方法一： 使用内置编辑器 [Micropython Editor(pye)](https://github.com/robert-hh/Micropython-Editor)

在 MaixPy 中, 我们内置了一款编开源编辑器 Micropython Editor(pye)

使用 `os.listdir()` 可以查看当前目录下的文件,

使用 `pye("hello.py")` 可以创建文件并进入编辑模式, 快捷键等使用说明可以在[这里查看](https://github.com/robert-hh/Micropython-Editor/blob/master/Pyboard%20Editor.pdf)

比如我们写入代码

```python
print("hello maixpy")
```

Copy

然后按 `Ctrl+S` 按 `Enter` 键保存, 按 `Ctrl+Q` 退出编辑

**注意**： 使用这款编辑器对使用的串口工具有一定要求, 必须将 `BackSpace` 按键设置为 `DEL` 功能, 否则按 `BackSpace` 调用的是 `Ctrl+H` 一样的功能（即字符替换）。

Linux 下推荐使用 `minicom`, 需要使用 `sudo minicom -s` 来设置,参考 [[K210_00_搭建开发环境]]

Windows 下也一样, 根据自己使用的工具上网搜设置方法, 比如 `xshell` 搜 `xshell如何设置backspace为del` 得到结果：

`文件` -> `属性` -> `终端` -> `键盘`,  
把 delete 和 backspace 序列改为 ASCII 127 即可.

### 2.2. 方法二： 使用 MaixPy IDE

打开 `MaixPy IDE`， 连接开发板

编辑文件，然后在顶端`Tool`（工具）菜单中，点击`将打开的文件保存为 boot.py` 来将代码保存到开发板的`boot.py`文件，中，下次开发板开机上电会自动执行这个文件

当然也可以使用顶端`Tool`(工具)菜单中的`发送文件`功能来发送文件，会保存到开发板并且文件名和电脑上的文件名相同，（除了脚本也可以上传其它文件，不要太大）

![](https://wiki.sipeed.com/soft/maixpy/assets/maixpy/maixpy_ide_tools.png)

### 2.3. 方法三： 使用工具 [uPyLoader](https://github.com/BetaRavener/uPyLoader) 读取到 PC（电脑)上编辑后再保存到开发板

下载可执行文件:[release](https://github.com/BetaRavener/uPyLoader/releases)

![uPyLoader](https://wiki.sipeed.com/soft/maixpy/assets/other/uPyLoader.png)

选择串口并点击 `Connect` 按钮来连接板子

第一次运行该软件需要初始化, 点击 `File->Init transfer files` 来完成初始化,这会在板子里创建两个文件,分别是 `__upload.py` 和 `__download.py`。

然后双击文件名即可打开文件并编辑,编辑完成后点击 `save` 来保存到开发板即可

### 2.4. 方法四： 使用工具 [rshell](https://github.com/dhylands/rshell) 读取到 PC（电脑)上编辑后再保存到开发板

按照 `rshell` [项目主页](https://github.com/dhylands/rshell)的说明安装好 `rshell`

```shell
sudo apt-get install python3-pip
sudo pip3 install rshell
rshell -p /dev/ttyUSB1 # 这里根据实际情况选择串口
```

编辑文件

```python
ls /flash
edit /flash/boot.py
# 编辑器使用方法和 vim 一样
```

## 3. 执行文件

使用 `os.chdir()` 切换当前目录到文件的目录,比如 `os.chdir("/flash")`

### 3.1. 方法一： `import`

然后执行 `import hello`

即可看到输出 `hello maixpy`

使用此方法简单易用,但是需要注意的是, 目前 `import` 只能使用一次, 如果第二次 `import`, 则文件不会再执行, 如果需要多次执行,建议使用下面的方法  
而且 `import` 也不会执行 `if __name__ == "__main__":` 条件下的代码，需要注意

### 3.2. 方法二： `exec()`

使用 `exec()` 函数来执行

```python
with open("hello.py") as f:
    exec(f.read())
```

### 3.3. 方法三： 使用 **MaixPy IDE** 来执行

打开文件, 然后点击执行按钮来执行，**注意**：这样执行代码和 `REPL`执行代码类似，只是将程序发送到开发板，并没有保存到文件系统，是一次性执行的

![|525](https://wiki.sipeed.com/soft/maixpy/assets/maixpy/maixpy_connect-success.png)

### 3.4. 方法四： 使用 uPyLoader 来执行

连接好后选中文件, 点击 `excute` 按钮来执行文件

### 3.5. 方法五： 使用 ampy 来直接运行电脑上的文件

[ampy](https://github.com/pycampers/ampy)

执行命令 `ampy run file_in_PC.py` 来执行位于电脑上的文件（文件不会保存到开发板）

## 4. MaixPy 支持挂载文件系统到电脑么

不支持，因为使用的芯片 k210 没有 USB 功能，无法模拟 U 盘设备，所以不能像 Microbit 和 STM32 的 Micropython 一样虚拟一个 U 盘

# 上传脚本&模块到开发板

前面我们接触到了直接执行 `pye("filename.py")` 命令可以打开一个编辑器，可以直接编辑文件系统中的文件

但是慢慢我们会发现，这样的方法只适合用来改少量的代码，当代码量庞大或者我们需要高亮支持时，它就不适用了，我们需要在电脑上写完代码，然后上传到板子的文件系统里面

目前有以下几种方法：

### 0.1. [[#2.2. 方法二： 使用 MaixPy IDE|使用 MaixPy IDE 上传脚本到开发板]]

## 1. 使用图形工具 uPyLoader 上传、运行脚本

[uPyLoader](https://github.com/BetaRavener/uPyLoader) 是一款开源软件，使用它可以方便地连接 MaixPy 并且上传、下载、执行文件，同时监控输出等等功能，功能比较完善

下载可执行文件:[release](https://github.com/BetaRavener/uPyLoader/releases)

![uPyLoader](https://wiki.sipeed.com/soft/maixpy/assets/other/uPyLoader.png)

选择串口并点击 `Connect` 按钮来连接板子

第一次运行该软件需要初始化， 点击 `File->Init transfer files` 来完成初始化，这会在板子里创建两个文件，分别是 `__upload.py` 和 `__download.py`。

左边选中需要上传的文件，点击 `Transfer` 即可上传到板子的文件系统。

右边是板子里面的文件， 点击 `List files` 可以刷新文件列表， 选中 文件名， 点击 `Execute` 即可执行该脚本文件

点击上面的 `View -> terminal` 可以打开终端用来查看运行时的输出或者发送命令

## 2. 使用命令行工具

[mpfshell-lite](https://github.com/junhuanchen/mpfshell-lite) 是一个简单易用的命令行上传、下载、执行文件 的工具， 而且开源

注意这个工具是运行在电脑端的，而不是运行在板子上的

使用 `mpfs --help` 来查看帮助信息

使用 `mpfs put file_in_PC.py` 命令还可以不上传脚本到板子而是直接在板子上运行该脚本

除此之外还有 ampy rshell 这些。

## 3. SD（TF） 直接运行

拷贝到 SD 卡后，在终端中执行 `import 文件名` 或者 `exec()` 来运行脚本

## 4. SD 卡自动拷贝到 Flash 文件系统

为了方便将 SD 卡的内容拷贝到 Flash 文件系统，只需要将要拷贝到 Flash 文件系统的文件重命名为 `cover.boot.py` 或者 `cover.main.py`, 然后放到 `SD` 卡根目录，开发板断电插入 `SD` 卡，然后开发板上电，程序就会自动将这两个文件拷贝到 `/flash/boot.py` 或者 `/flash/main.py`，这样就算后面取出了 `SD` 卡，程序已经在 `/flash/boot.py` 或者 `/flash/main.py` 了

# 开机自启动脚本

系统会在 `/flash` 或者 `/sd`(优先) 目录创建 `boot.py` 文件和`main.py`， 开机会自动先执行`boot.py`，然后执行`main.py`（如果检测到SD卡则执行SD卡里的）， 编辑这两个脚本的内容即可实现开机自启，如果在 `boot.py` 里面写死循环（While True）程序，将会导致 `main.py` 不能运行（**先调用 `boot.py` 后调用 `main.py`**），重新发送不带死循环的 `boot.py` 即可解决。

> [!NOTE]
> - boot.py 主要用于配置硬件，只配置一次即可。
> - main.py 可以用于主要的运行的程序。

对应的具体执行的[代码在此](https://github.com/sipeed/MaixPy-v1/blob/972059491227ece63fbfc2cd0e78fe13ee78427d/components/micropython/port/src/maixpy_main.c#L586-L595)，有疑问就直接看源码。

注意:  
* Micro SD 卡应该被格式化为 FAT(FAT32) 文件系统  
* FAT 格式的储存卡会被挂载到 `/sd`, 内部 Flash 中的 SPIFFS 会被挂载到 `/flash`

# 开发板配置文件

这是一个 MaixPy 板级配置模块，它可以在用户层统一 Python 代码，从而屏蔽许多硬件的引脚差异。

效果如下：

```python
from Maix import GPIO
from fpioa_manager import fm
from board import board_info
print(board_info.LED_R)
fm.register(board_info.LED_R, fm.fpioa.GPIO0, force=True)
led_r = GPIO(GPIO.GPIO0, GPIO.OUT)
led_r.value(0)
```

而这份代码同时支持 MaixPy 所有硬件运行，并且打印的 board_info.LED_R 都不尽相同，通过它保证示例代码的一致性。

## 1. board 的配置方法

将以下链接对应的 python 代码复制出来（如 config_maix_bit.py），放到 IDE 编辑框中运行，即可完成对『你的硬件』配置项（config.json）的导入，它会在 flash 上存储该配置文件。  
选择自己对应的开发板类型

1. Maix Bit

[config_maix_bit.py](https://github.com/sipeed/MaixPy-v1_scripts/tree/master/board/config_maix_bit.py)

运行配置代码后会自动重启，此时代码中才可以调用 board_info.BOOT_KEY , 实际上 board_info.BOOT_KEY 就是指 IO 16 ，对应的定义在 config.json 中可以得知，如果不存在的资源将会报错，如没有 LED 定义的硬件，运行 LED 点亮的时候就会报错。

```python
from board import board_info
# see board/readme.md to config your sipeed's hardware.
print(board_info.BOOT_KEY, board_info.BOOT_KEY == 16)
```

## 2. board 的使用方法

导入配置：

```python
from board import board_info
board_info.load({
    'PIN10': 10,
    'BOOT_KEY': 16,
    'WIFI_TX': 6,
    'WIFI_RX': 7,
    'WIFI_EN': 8,
})
print('PIN10:', board_info.PIN10)
print('BOOT_KEY:', board_info.BOOT_KEY)
print('WIFI_TX:', board_info.WIFI_TX)
print('WIFI_RX:', board_info.WIFI_RX)
print('WIFI_EN:', board_info.WIFI_EN)
```

Copy

调用结果：

```shell
PIN10: 10
BOOT_KEY: 16
WIFI_TX: 6
WIFI_RX: 7
WIFI_EN: 8
```

