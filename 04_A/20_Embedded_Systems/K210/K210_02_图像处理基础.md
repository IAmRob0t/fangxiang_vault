---
tags:
  - K210
---
# 获得图像

可以从摄像头获得图像，也可以从文件系统读取图片文件，也可以从网络获取图片

## 1. 从摄像头获取

这部分已经在前面的教程有提过

[[K210_01_准备上手运行程序#第一个程序：使用屏幕和摄像头]]

## 2. 从文件读取

```python
import image

img = image.Image("/sd/test.jpg")
print(img)
```

当然你也可以把图片保存到文件系统`

```python
img.save("/sd/test2.jpg", quality=95)
```

## 3. 从内读取（或者网络读取）

可以先将文件读取到内存， 具体是从哪里读取的看你的应用了， 比如网络，或者串口 SPI 等等，  
构造一个 `bytes`对象

```python
import image

jpeg_buff = b'\xFF'   # jpeg buffer
img = image.Image(jpeg_buff, from_bytes = True)
print(img)
```

## 4. 直接创建一个空白图像

```python
import image

img = image.Image(size=(320, 240))
```

这张图片是全黑的空白图像

# 显示图片

显示图片很简单， 直接使用 `lcd` 模块，调用函数进行显示即可， 如下：

```python
import lcd, image

lcd.init()

img = image.Image("/sd/test.jpg")
lcd.display(img)
```

但是不同的屏幕初始化序列可能不一样， 在`lcd.init`的时候有很多可选参数， 具体看 API 文档的描述，常见的如下

对于 IPS 屏幕，需要反色：

```python
lcd.init(type=2)
```

对于屏幕体质不是很好， 需要降低频率，或者体质很好需要超频：

```python
lcd.init(freq = 15000000)
```

另外， 也可是设置屏幕的旋转方向：

```python
lcd.rotation(2)
```

参数是 `0～3`, 分别代表顺时针旋转 `0度` `90度` `180度` `270度`

更多方法，请参考 [[lcd-屏幕显示]]

# 图像处理基础

这里简单介绍一些经常用到的图像的基本变换操作

旋转：

```python
img.rotation_corr()
```

改变图像尺寸：

```python
img.resize()
```

更多的图像变换请看 [[image-图像处理]]

## 1. 图像缓冲区介绍

MaixPy 为图像设计了两个缓冲区，

- 一个是`RGB565`缓冲区，顾名思义， 是以`RGB565`的格式存放这图片的信息的一块内存。注意在内存中的排序是`[像素1 RGB, 像素2 RGB...]`
- 另一个是 `RGB888` 缓冲区，顾名思义，是以 `RGB88` 的格式存放这图片的信息的一块内存。注意在内存中的排序是 `[所有像素 R, 所有像素 G， 所有像素 B]`, 我们也称之为 `AI` 内存

这里使用两个内存块主要的原因是底层代码所有图片操作以及`LCD`显示均是基于`RGB565`， 但是`KPU`又需要`RGB888`的输入。

```none
                   +---------------+
                   |               |
          +--------+ camera(sensor)+-------+
          |        |               |       |
          |        +---------------+       |
          |                                |
+---------v------+                +--------v---------+
|                | img.pix_to_ai()|                  |
|      RGB565    +--------------->+      RGB888      |
|                |                |                  |
+--------+-------+                +------+-----------+
         ^                               |
         |                               |
         |                               v
+--------+----------+             +------+-----------+
|                   |             |                  |
|     image ops     |             |   KPU            |
|                   |             |                  |
+-------------------+             +------------------+
```

只有摄像头采集图片时，硬件会自动放一份数据到`RGB888`内存区域， 其它的都不会自动填充`RGB888`内存块， 软件操作只会对`RGB565`内存进行操作，不会自动更新`RGB888`，（因为更新需要消耗时间） 这很值得注意，  
这意味着，每次我们用更改了`RGB565`内存块，比如执行了`img = img.resize((224, 224))`，如果希望`KPU`使用更改过后的图片， 需要执行`img.pix_to_ai()`来将`RGB565`的图像手动更新到`RGB888`的区域，然后才可以调用`kpu`相关的函数进行模型推理！

同样反方向更新也提供 API： `img.ai_to_pix()`，这会将 `RGB888` 区域的数据更新到 `RGB565` 区域

## 2. resize 修改分辨率

```python
import image
img = image.Image(size=(100, 100))
img2 = img.resize(50, 50)
print(img)
print(img2)
```

## 3. 获取和修改像素值

```python
import image
img = image.Image(size=(10, 10))
print("pixel 0:", img[0], img.get_pixel(0, 0))
img[0] = (255, 0, 0)
img = img.set_pixel(1, 0, (255, 255, 10))
print("after pixel 0 change:", img[0], img[1])
```

这里设置的第二个像素点 `B` 为 `10`，实际发现读出来是 `8`，这是正常现象，因为前面说了，在内存中储存是用了 `RGB565` 进行储存，所以会有误差

## 4. 复制图像

```python
import image
img = image.Image(size=(10, 10))
img2 = img.copy()
img2[0] = (255, 0, 0)
print(img[0], img2[0])
```

## 5. 剪裁图像

同样使用`copy`函数

```python
import image
img = image.Image(size=(10, 10))
img2 = img.copy(roi=(0, 0, 5, 5))
img2[0] = (255, 0, 0)
print(img)
print(img2)
print(img[0], img2[0])
```

## 6. 转换成 bytes 对象

转换成 `RGB565` 字符串

```python
import image
img = image.Image(size=(10, 10))
img[0] = (255, 0, 0)
img_bytes = img.to_bytes()
print("bytes length: %d bytes[0]: %x%x" %(len(img_bytes), img_bytes[0], img_bytes[1]))
```

这里输出的值为`RGB565`格式，以两个字节表示一个像素点储存

另外， 也可以先将图片压缩为 `JPEG` 格式，然后再转换成`bytes`

```python
import image
img = image.Image(size=(10, 10))
img = img.compressed(quality=20)
jpeg_bytes = img.to_bytes()
print("bytes length: %d bytes[0]: %x%x" %(len(jpeg_bytes), jpeg_bytes[0], jpeg_bytes[1]))
```

这里使用 `compressed` 函数不会修改原图，使用 `compress()` 函数则会修改原图，但是压缩后的大小如果比原图占用的空间还大，就会失败

## 7. 转换为灰度图像

```python
img = img.to_grayscale(copy=False)
```

这里 `copy` 参数的意思就是是否要重新申请一片内存，不修改原图的意思

## 8. 转换为 RGB565 彩图

转换为 彩图， 注意只是格式成为了彩图， 画面并不是彩图， 如果需要将灰度图转换为彩图，使用`img.to_rainbow()`

```python
img = img.to_rgb565(copy=True)
```

这里 `copy` 参数的意思就是是否要重新申请一片内存， 不修改原图的意思  
如果原图是灰度图，必须是 `True`

## 9. 转换为彩图

```python
img = img.to_rainbow(copy=True)
```

这里 `copy` 参数的意思就是是否要重新申请一片内存， 不修改原图的意思  
如果原图是灰度图，必须是 `True`

## 10. 保存到文件系统

```python
img.save("/sd/test.jpg", quality=95)
img.save("/sd/test.bmp")
```

## 11. 旋转

```python
img.rotation_corr([x_rotation=0.0[, y_rotation=0.0[, z_rotation=0.0[, x_translation=0.0[, y_translation=0.0[, zoom=1.0]]]]]])
```

中括号为可选参数，即沿着哪个轴旋转一定的角度，如果 `minimum` 版本的固件里面没有这个函数，可以用完全版本的固件

# 如何在图像上写字

有两种方式，推荐第二种

## 1. 第一种， 使用`lcd`模块直接在屏幕上画

```python
import image, lcd

lcd.init()

lcd.draw_string(0, 0, "hello")
```

更多的函数和参数，参见 [[lcd-屏幕显示]]

## 2. 第二种， 使用`image` 模块在内存中画，画完后使用`lcd.display`函数将整张图片展示到屏幕

```python
import image, lcd

lcd.init()

img = image.Image(size=(320, 240))
img.draw_string(0,0, "hello")
lcd.display(img)

```

更多的函数和参数，可以看 [[image-图像处理]] , 在页面搜索 `image.draw` 可以找到所有画图函数

# 硬件加速图像模块

使用硬件替换某些软件部分， 可以让计算更加快速，已经做了加速优化的方法如下：

如下代码， 分别对图像进行了`边缘查找`，`锐化`，`浮雕化`， 利用了卷积计算快速得到结果。

```python
import sensor
import image
import lcd
import time

lcd.init(freq=15000000)
sensor.reset()
sensor.set_pixformat(sensor.RGB565)
sensor.set_framesize(sensor.QVGA)
sensor.run(1)
origin = (0,0,0, 0,1,0, 0,0,0)
edge = (-1,-1,-1,-1,8,-1,-1,-1,-1)
sharp = (-1,-1,-1,-1,9,-1,-1,-1,-1)
relievo = (2,0,0,0,-1,0,0,0,-1)

tim = time.time()
while True:
    img=sensor.snapshot()
    img.conv3(edge)
    lcd.display(img)
    if time.time() -tim >10:
        break
tim = time.time()
while True:
    img=sensor.snapshot()
    img.conv3(sharp)
    lcd.display(img)
    if time.time() -tim >10:
        break
tim = time.time()
while True:
    img=sensor.snapshot()
    img.conv3(relievo)
    lcd.display(img)
    if time.time() -tim >10:
        break

lcd.clear()
```