---
tags:
  - 硬件
---

```asm
    22:   a = 123; 
0x0800019E 207B      MOVS     r0,#0x7B
0x080001A0 490C      LDR      r1,[pc,#48]  ; @0x080001D4
0x080001A2 6008      STR      r0,[r1,#0x00]					// 写内存 将 R0 写到 R1 中，即写到变量 a 的地址

// CPU 怎么知道 0x2000 0000 是内存？

    23:   d = a; 
    24:  
0x080001A4 4608      MOV      r0,r1							// R0 = R1 = 0x2000 0000
0x080001A6 6800      LDR      r0,[r0,#0x00]					// R0 = [R0] = a = 123
0x080001A8 490B      LDR      r1,[pc,#44]  ; @0x080001D8	// R1 = 读 0x080001D8 = 0x2000 001C，即变量 d 的地址
0x080001AA 6008      STR      r0,[r1,#0x00]					// R0(123) 写入到 R1 存的地址中，即写入到变量 d 中
.
.
.
0x080001D4 0000      DCW      0x0000
0x080001D6 2000      DCW      0x2000
0x080001D8 001C      DCW      0x001C
0x080001DA 2000      DCW      0x2000
```

`d = a`

1. 读 a，读内存
2. 读 Flash，得到地址
3. 写内存，写 d

> [!question] 1 和 2 都是读内存 `LDR` 指令，CPU 如何区分读取内存和读取 Flash？
> 实际上，CPU 本身并不区分读取的是内存还是 Flash。CPU 在执行 `LDR` 等读取指令时，只是发出地址信号并等待数据返回，而不关心数据来自哪个设备。CPU 只关注地址和获取的数据，不关心数据的来源设备。

> [!question] 那么谁负责将 CPU 的地址请求路由到正确的设备？
> 内存控制器（Memory Controller）负责这一工作。它根据 CPU 发出的地址信号，决定将请求路由到哪个设备（如 RAM、Flash、外设等），并将相应设备返回的数据传送回 CPU。这种地址映射机制使 CPU 能够通过统一的地址空间访问不同的硬件设备。

# 访问单个设备

![[CPU与外设_01.png|597]]

# 访问多个设备：冲突

![[CPU与外设_02.png|592]]

# 访问多个设备：通过内存控制器

![[CPU与外设_03.png|603]]

> [!question] 什么是地址空间？
> 地址空间是CPU可以访问的所有内存地址的集合。在计算机系统中，地址空间定义了CPU能够寻址的范围。例如，32位CPU通常可以访问2^32（4GB）的地址空间，而64位CPU可以访问2^64的地址空间。

> [!question] CPU 发出的 0 地址和 SPIO 发出的 0 地址是同一个地址吗？
> CPU发出的0地址和SPI0发出的0地址不是同一个地址。这是因为：
> 
> **不同的地址空间**：CPU和外设（如SPI控制器）通常有各自独立的地址空间。CPU的地址空间是全局的，覆盖整个系统；而SPI控制器访问的是连接到它的SPI设备（如Flash、EEPROM等）的地址空间。
> 
> 当CPU需要访问SPI设备时，它会通过访问映射到系统地址空间中的SPI控制器寄存器来实现。例如，CPU可能通过访问地址0x4000_1000处的SPI控制器寄存器来发送命令和数据。SPI控制器接收到CPU的命令后，会将其转换为SPI协议的命令和地址，然后发送给SPI设备。此时，SPI控制器发出的地址0是相对于SPI设备自身地址空间的起始位置。
> 
> 因此，当CPU想要访问SPI设备的地址0时，它实际上是通过访问系统地址空间中的SPI控制器寄存器，然后由SPI控制器转发相应的命令到SPI设备的地址0。

