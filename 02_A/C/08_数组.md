---
tags:
  - c
---
到目前为止，我们所见的变量都只是标量（scalar）：标量具有保存单一数据项的能力。 C 语言也支持聚合（aggregate）变量，这类变量可以存储成组的数值。在 C 语言中一共有两种聚合类型：数组（array）和结构（structure）。

# 一维数组

数组的元素可以是任何类型，数组的长度可以用任何 [[05_选择语句#`switch` 语句|（整数）常量表达式（ 5.3 节）]] 指定。因为程序以后改变时可能需要调整数组的长度，所以较好的方法是用宏来定义数组的长度：

```c
#define N	10
...
int a[N];
```

## 数组下标

> [!warning] 
> C 语言不要求检查下标的范围。当下标超出范围时，程序可能执行不可预知的行为。

> [!warning] 
> 当数组下标有副作用时一定要注意。
> 例如，下面这个循环想把数组 b 中的元素复制到数组 a 中，但它可能无法正常工作：
> ```c
> i = 0;
> while (i < N)
> 	a[i] = b[i++];
> ```
> 表达式 `a[i]=b[i++]` 访问并修改 i 的值，如 [[04_表达式#子表达式的求值顺序|4.4 节]] 所述，这样会导致未定义的行为。当然，通过从下标中移走自增操作可以很容易地避免此类问题的发生：
> ```c
> for (i = 0; i < N; i++)
> 	a[i] = b[i];
> ```

## 数组初始化



## 指示器 (C99)

```c
int a[15] = {[2] = 29, [9] = 7, [14] = 48};
```

方括号和其中的常量表达式一起，组成一个指示器。

除了可以使赋值变得更简短、更易读之外，指示器还有一个优点：赋值的顺序不再是一个问题，我们也可以将先前的例子重写为：

```c
int a[15] = {[14] = 48 , [9] = 7, [2] = 29};
```

初始化器中可以同时使用老方法（逐个元素初始化）和新方法（指示器）：

```c
int c[10] = {5, 1, 9, [4] = 3, 7, 2, [8] = 6};
```

### 检查数中重复出现的数字

```c
/* Checks numbers for repeated digits */
#include <stdbool.h> /* C99 only */
#include <stdio.h>

int main(void) {
	bool digit_seen[10] = {false};
	int digit;
	long n;
	
	printf("Enter a number: ");
	scanf("%ld", &n);
	
	while (n > 0) {
		digit = n % 10;
		if (digit_seen[digit])
			break;
		digit_seen[digit] = true;
		n /= 10;
	}
	if (n > 0)
		printf("Repeated digit\n");
	else
		printf("No repeated digit\n");
	
	return 0;
}
```

## 对数组使用 `sizeof` 运算符

可以用 `sizeof` 来计算数组元素（如 `a[0]`）的大小。用数组的大小除以数组元素的大小可以得到数组的长度：

```c
sizeof(a) / sizeof(a[0])
```

---

有些编译器会对表达式 `i < sizeof (a) / sizeof (a[0])` 给出一条警告消息，这稍微有点烦人。变量 `i` 的类型可能是 `int`（有符号类型），而 `sizeof` 返回的值类型为 `size_t`（无符号类型）。由 7.4 节可知，把有符号整数与无符号整数相比较是很危险的，尽管在本例中这样做没问题（因为 `i` 和 `sizeof (a) / sizeof (a[0]` ) 都是非负值）。为了避免出现这一警告，可以将 i 的类型改成 t，或者像下面这样，将 `sizeof (a) / sizeof (a[0]` ) 强制转换为有符号整数：

```c
for (i = 0; i < (int) (sizeof(a) / sizeof(a[10])); i ++)
	a[i] = 0;
```

表达式 `(int) (sizeof (a) / sizeof (a[0]))` 写起来不太方便，定义一个宏来表示它常常是很有帮助的：

```c
#define SIZE ((int) (sizeof(a) / sizeof(a[0])))

for (i = 0; i < SIZE; i++)
	a[i] = 0;
```

但是，返回来使用宏的话，`sizeof` 的优势哪里去了呢？后面的某章将对这个问题进行回答［窍门是给宏加上“参数”，即带参数的宏（ 14.3 节）］。

# 多维数组

数组可以有任意维数。

## 多维数组初始化

> [!warning] 
> 在多维数组中省略内层的花括号可能是很危险的，因为额外的元素（更糟的情况是丢失的元素）会影响剩下的初始化器。省略花括号会导致某些编译器产生类似 “missing braces around initializer”这样的警告消息。

C99 的指示器对多维数组也有效。例如，可以这样创建 2×2 的单位矩阵：

```c
double ident[2][2] = {[0][0] = 1.0, [1][1] = 1.0};
```

## 常量数组

const 类型限定符（ 18.3 节）

### 发牌

> [!PDF|note] [[C语言程序设计：现代方法（第2版•修订版）.pdf#page=154&selection=8,0,8,2&color=note|C语言程序设计：现代方法（第2版•修订版）, p.133]]
> > 发牌
> 
> 

# C99 中的变长数组

变长数组的主要限制是它们不具有静态存储期（ 18.2 节；目前我们还没有发现具有这一特性的数组），另一个限制是变长数组没有初始化器。

变长数组常见于除 `main` 函数以外的其他函数。对于函数 f 而言，变长数组的最大优势就是每次调用 f 时长度可以不同。9.3 节将讲述这一特性。

# 问与答

> [!question] 如果试图用赋值运算符把一个数组复制到另一个数组中，编译器将给出出错消息。哪里错了？
> 赋值语句
> ```c
> a = b; /* a and b are arrays */
> ```
> 看似合理，但它确实是非法的。非法的理由不是显而易见的，这需要用到 C 语言中数组和指针之间的特殊关系，这一点将在第 12 章探讨。
> 把一个数组复制到另一个数组中的最简单的实现方法之一是，利用循环对数组元素逐个进行复制：
> ```c
> for (i = 0; i < N; i++)
> 	a[i] = b[i];
> ```
> 另一种可行的方法是使用来自 `<string.h>` 头的函数 `memcpy`（意思是“内存复制”）。`memcpy` 函数 （ 23.6 节）是一个底层函数，它把字节从一个地方简单地复制到另一个地方。为了把数组 b 复制到数组 a 中，使用函数 `memcpy` 的格式如下：
> ```c
> memcpy(a, b, sizeof(a));
> ```
> 许多程序员倾向于使用 `memcpy` 函数（特别是处理大型数组时），因为它潜在的速度比普通循环更快。

> [!question] [[06_循环#`goto` 语句|6.4 节]] 提到，C99 不允许 `goto` 语句绕过变长数组的声明。为什么会有这一限制呢？
> 在程序执行过程中，遇到变长数组声明时通常就为该变长数组分配内存空间了。用 `goto` 语句绕过变长数组的声明可能会导致程序对未分配空间的数组中的元素进行访问。
