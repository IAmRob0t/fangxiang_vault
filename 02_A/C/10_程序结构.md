---
tags:
  - c
---

# 局部变量

我们把在函数体内声明的变量称为该函数的局部变量。

默认情况下，局部变量具有下列性质。
- **自动存储期**。变量的存储期（storage duration，也称为延续）是程序执行时，能够确保变量的存储空间必定存在的那一部分时间。通常来说，局部变量的存储空间是在包含该变量的函数被调用时“自动”分配的，函数返回时收回分配，所以称这种变量具有自动存储期。包含局部变量的函数返回时，局部变量的值无法保留。当再次调用该函数时， 无法保证变量仍拥有原先的值。
- **块作用域**。变量的作用域是可以引用该变量的那一部分程序文本。局部变量拥有块作用域：从变量声明的点开始一直到所在函数体的末尾。因为局部变量的作用域不能延伸到其所属函数之外，所以其他函数可以把同名变量用于别的用途。

C99 不要求在函数一开始就进行变量声明，所以局部变量的作用域可能非常小。

## 静态局部变量

在局部变量声明中放置单词 [[18_声明#`static` 存储类型|static]] 可以使变量具有静态存储期而不再是自动存储期。因为**具有静态存储期的变量拥有永久的存储单元**，所以在整个程序执行期间都会保留变量的值。思考下面的函数：

```c
void f (void)
{
	static int i;		/* static local variable */
	...
}
```

因为局部变量 `i` 已经声明为 `static`，所以在程序执行期间它所占据的内存单元是不变的。在 `f` 返回时，变量 `i` 不会丢失其值。

静态局部变量始终有块作用域，所以它对其他函数是不可见的。概括来说，静态变量是对其他函数隐藏数据的地方，但是它会为将来同一个函数的再调用保留这些数据。

## 形式参数

形式参数拥有和局部变量一样的性质，即自动存储期和块作用域。事实上，形式参数和局部变量唯一真正的区别是，在每次函数调用时对形式参数自动进行初始化（调用中通过赋值获得相应实际参数的值）。

# 外部变量

传递参数是给函数传送信息的一种方法。函数还可以通过外部变量（external variable）进行通信。外部变量是声明在任何函数体外的。

外部变量（有时称为全局变量）的性质不同于局部变量的性质：
- 静态存储期。就如同声明为 `static` 的局部变量一样，外部变量拥有静态存储期。存储在外部变量中的值将永久保留下来。
- 文件作用域。外部变量拥有文件作用域：从变量被声明的点开始一直到所在文件的末尾。因此，跟随在外部变量声明之后的所有函数都可以访问（并修改）它。

## 示例：用外部变量实现栈

为了说明外部变量的使用方法，一起来看看称为栈（stack）的数据结构。（栈是抽象的概念， 它不是 C 语言的特性。大多数编程语言都可以实现栈。）像数组一样，栈可以存储具有相同数据类型的多个数据项。然而，栈操作是受限制的：只可以往栈中压入数据项（把数据项加在一端——“栈顶”）或者从栈中弹出数据项（从同一端移走数据项）。禁止测试或修改不在栈顶的数据项。

C 语言中实现栈的一种方法是把元素存储在数组中，我们称这个数组为 contents。命名为 top 的一个整型变量用来标记栈顶的位置。栈为空时，top 的值为 0。为了往栈中压入数据项，可以把数据项简单存储在 contents 中由 top 指定的位置上，然后自增 top。弹出数据项则要求自减 top，然后用它作为 contents 的索引取回弹出的数据项。

基于上述这些概要，这里有一段代码（不是完整的程序）为栈声明了变量 contents 和 top 并且提供了一组函数来表示对栈的操作。全部 5 个函数都需要访问变量 top，而且其中 2 个函数还都需要访问 contents，所以接下来把 contents 和 top 设为外部变量。

```c
#include <stdbool.h>	/* c99 only*/

#define STACK_SIZE	100

/* external variables */
int contents[STACK_SIZE];
int top = 0;

void make_empty (void)
{
	top = 0;
}

bool is_empty (void)
{
	return top == 0;
}

bool is_full (void)
{
	return top == STACK_SIZE
}

void push (int i)
{
	if (is_full())
		stack_underflow()
	else
		contents[top++] = i;
}

int pop (void)
{
	if (is_empty())
		stack_underflow();
	else
		return contents[--top];
}
```

## 外部变量的利与弊

在大多数情况下，对函数而言，通过形式参数进行通信比通过共享变量的方法更好，原因列举如下。
- 在程序维护期间，如果改变外部变量（比方说改变它的类型），那么将需要检查同一文件中的每个函数，以确认该变化如何对函数产生影响。
- 如果外部变量被赋了错误的值，可能很难确定出错的函数，就好像侦察大型聚会上的谋杀案时很难缩小嫌疑人范围一样。
- 很难在其他程序中复用依赖外部变量的函数。依赖外部变量的函数不是“独立的”。为了在另一个程序中使用该函数，必须带上此函数需要的外部变量。

许多 C 程序员过于依赖外部变量。一个普遍的陋习是，在不同的函数中为不同的目的使用同一个外部变量。假设几个函数都需要变量 i 来控制 for 语句。一些程序员不是在使用变量 i 的每个函数中都声明它，而是在程序的顶部声明它，从而使得该变量对所有函数都是可见的。这种方式除了前面提到的几个缺点外，还会产生误导：以后阅读程序的人可能认为变量的使用彼此关联，而实际并非如此。

使用外部变量时，要确保它们都拥有有意义的名字。（局部变量不是总需要有意义的名字的，因为往往很难为 `for` 循环中的控制变量起一个比 `i` 更好的名字。）如果你发现为外部变量使用的名字就像 `i` 和 `temp` 一样，这可能意味着这些变量其实应该是局部变量。

### 程序：猜数

( [[C语言程序设计：现代方法（第2版•修订版）.pdf#page=195&selection=151,0,151,2&color=note|📖]])
猜数

# 程序块

[[05_选择语句#复合语句|5.2 节]] 遇到过复合语句，一个复合语句也是一个块（block），但块并非只有复合语句这一种形式。块也叫程序块。下面是程序块的示例：

```c
if (i > j) {
	/* swap values of i and j */
	int temp = i;
	i = j;
	j = temp;
}
```

这里，整个 `if` 语句是一个程序块；`if` 语句的每一个子句也是程序块。默认情况下，声明在程序块中的变量的存储期是自动的：进入程序块时为变量分配存储单元，退出程序块时收回分配的空间。变量具有块作用域，也就是说，不能在程序块外引用。

函数体是程序块。在需要临时使用变量时，函数体内的程序块也是非常有用的。在上面这个例子中，我们需要一个临时变量以便可以交换 i 和 j 的值。在程序块中放置临时变量有两个好处：
1. 避免函数体起始位置的声明与只是临时使用的变量相混淆；
2. 减少了名字冲突。在此例中，名字 `temp` 可以根据不同的目的用于同一函数中的其他地方，在程序块中声明的变量 `temp` 严格属于局部程序块。

C99 允许在程序块的任何地方声明变量，就像允许在函数体内的任何地方声明变量一样。

# 作用域

下面是最重要的作用域规则：当程序块内的声明命名一个标识符时，如果此标识符已经是可见的（因为此标识符拥有文件作用域，或者因为它已在某个程序块内声明），新的声明临时 “隐藏”了旧的声明，标识符获得了新的含义。在程序块的末尾，标识符重新获得旧的含义。

---

思考下面这个（有点极端的）例子，例子中的标识符 i 有 4 种不同的含义。
- 在声明 1 中，i 是具有静态存储期和文件作用域的变量。
- 在声明 2 中，i 是具有块作用域的形式参数。
- 在声明 3 中，i 是具有块作用域的自动变量。
- 在声明 4 中，i 也是具有块作用域的自动变量。

![[C语言程序设计：现代方法（第2版•修订版）.pdf#page=199&rect=177,52,358,266&color=note|📖]]

一共使用了 5 次 i。 C 语言的作用域规则允许确定每种情况中 i 的含义。
- 因为声明 2 隐藏了声明 1，所以赋值 i = 1 引用了声明 2 中的形式参数，而不是声明 1 中的变量。
- 因为声明 3 隐藏了声明 1，而且声明 2 超出了作用域，所以判定 i > 0 引用了声明 3 中的变量。
- 因为声明 4 隐藏了声明 3，所以赋值 i = 3 引用了声明 4 中的变量。
- 赋值 i = 4 引用了声明 3 中的变量。声明 4 超出了作用域，所以不能引用。
- 赋值 i = 5 引用了声明 1 中的变量。

# 构建 C 程序

我们已经看过构成 C 程序的主要元素，现在应该为编排这些元素开发一套方法了。目前只考虑单个文件的程序，第 15 章会说明如何组织多个文件的程序。

最后的建议：在每个函数定义前放盒型注释可以给出函数名、描述函数的目的、讨论每个形式参数的含义、描述返回值（如果有的话）并罗列所有的副作用（如修改了外部变量的值）。

### 程序：给一手牌分类

( [[C语言程序设计：现代方法（第2版•修订版）.pdf#page=201&selection=15,0,15,6&color=note|📖]])
给一手牌分类

# 问与答

> [!question] 具有静态存储期的局部变量会对递归函数产生什么影响？（p.172）
> 当函数是递归函数时，每次调用它都会产生其自动变量的新副本。静态变量就不会发生这样的情况， 相反，所有的函数调用都共享同一个静态变量。

# 编程题

( [[C语言程序设计：现代方法（第2版•修订版）.pdf#page=208&selection=41,0,72,10&color=note|📖]])
把数组 `num_in_rank`、`num_in_suit` 和 `card_exists` 从 10.5 节的 `poker.c` 程序中去掉。程序改用 5×2 的数组来存储牌。数组的每一行表示一张牌。例如，如果数组名为 hand，则 `hand[0][0]`存储第一张牌的点数，`hand[0][1]`存储第一张牌的花色。

http://knking.com/books/c2/answers/c10.html

---

( [[C语言程序设计：现代方法（第2版•修订版）.pdf#page=208&selection=101,0,126,2&color=note|📖]])
修改 10.5 节的 poker.c 程序，使其能识别“小 A 顺”（即 A、2、3、4 和 5）。
