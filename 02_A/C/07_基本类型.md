---
tags:
  - c
---

>  请别搞错：计算机处理的是数而不是符号。我们用对行为的算术化程度来衡量我们的理解力（和控制力）。

**对象**、**函数** 和 **表达式** 拥有称为类型的属性，它确定存储于对象或表达式求值所得的二进制值的转译方式。

C 类型系统由下列类型组成：
- `void`
- 基本类型
	- `char`
	- 有符号整数类型
		- 标准：`signed char` 、 `short` 、 `int` 、 `long` 、 `long long`
		- 扩展：实现定义，例如 `__int128`
	- 无符号整数类型
		- 标准： `_Bool` 、 `unsigned char` 、 `unsigned short` 、 `unsigned int` 、 `unsigned long` 、`unsigned long long`
		- 扩展：实现定义，例如 `__uint128`
	- 浮点类型
		- 实浮点类型： `float` 、 `double` 、 `long double`
		- 十进制实浮点类型： `_Decimal32` 、 `_Decimal64` 、 `_Decimal128`
		- 复数类型： `float _Complex` 、 `double _Complex` 、 `long double _Complex`
		- 虚数类型： `float _Imaginary` 、 `double _Imaginary` 、 `long double _Imaginary`
- 枚举类型
- 派生类型
	- 数组类型
	- [[16_结构、联合和枚举|结构体类型]]
	- 联合体类型
	- 函数类型
	- [[11_指针|指针类型]]
	- 原子类型（C11 起）

对于上面列出的每个类型，可以存在数种其类型的限定版本，对应 const 、 [[20_底层程序设计#`volatile` 类型限定符|volatile]] 和 restrict 限定符的一、二或全部三个组合（在限定符的语义所允许处）。

# 整数类型

> [!NOTE] 有符号整数和无符号整数
> **有符号**整数如果为正数或零，那么最左边的位（符号位）为 0；如果是负数，则符号位为 1。因此，最大的 16 位整数的二进制表示是 `0111 1111 1111 1111`，对应的数值是 32 767（即 $2^{15}-1$）。最大的 32 位整数的二进制表示是 `0111 1111 1111 1111 1111 1111 1111 1111`，对应的数值是 2 147 483 647（即 $2^{31}-1$）。
> 默认情况下，C 语言中的整型变量都是有符号的，也就是说最左位保留为符号位。若要告诉编译器变量没有符号位，需要把它声明成 `unsigned` 类型。无符号整数主要用于系统编程和底层与机器相关的应用。第 20 章将讨论无符号整数的常见应用。

C 语言的整数类型有不同的大小。`int` 类型通常为 32 位，但在老的 CPU 上可能是 16 位。

C 语言允许通过省略单词 `int` 来缩写整数类型的名字。例如，`unsigned short int` 可以缩写为 `unsigned short`，而 `long int` 可以缩写为 `long`。**C 程序员经常会省略 `int`** 。

C 标准要求 `short int`、`int` 和 `long int` 中的每一种类型都要覆盖一个确定的最小取值范围（详见 23.2 节）。其次，标准要求 `int` 类型不能比 `short int` 类型短，`long int` 类型不能比 `int` 类型短。但是，`short int` 类型的取值范围有可能和 `int` 类型的范围是一样的，`int` 类型的取值范围也可以和 `long int` 的一样。

### 16 位机的整数类型

注意 `short int` 和 `int` 有相同的取值范围。

| 类型                   | 最小值            | 最大值           |
| -------------------- | -------------- | ------------- |
| `short int`          | -32 768        | 32 767        |
| `unsigned short int` | 0              | 65 535        |
| `int`                | -32 768        | 32 767        |
| `unsigned int`       | 0              | 65 535        |
| `long int`           | -2 147 483 648 | 2 147 483 647 |
| `unsigned long int`  | 0              | 4 294 967 295 |

### 32 位机的整数类型

这里的 `int` 和 `long int` 有着相同的取值范围。

| 类型                 | 最小值            | 最大值           |
| ------------------ | -------------- | ------------- |
| `short int`          | -32 768        | 32 767        |
| `unsigned short int` | 0              | 65 535        |
| `int`                | -2 147 483 648 | 2 147 483 647 |
| `unsigned int`       | 0              | 4 294 967 295 |
| `long int`           | -2 147 483 648 | 2 147 483 647 |
| `unsigned long int`  | 0              | 4 294 967 295 |

### 64 位机的整数类型

| 类 型                | 最 小 值                      | 最大 值                       |
| ------------------ | -------------------------- | -------------------------- |
| `short int`          | -32 768                    | 32 767                     |
| `unsigned short int` | 0                          | 65 535                     |
| `int`                | -2 147 483 648             | 2 147 483 647              |
| `unsigned int`       | 0                          | 4 294 967 295              |
| `long int`           | -9 223 372 036 854 775 808 | 9 223 372 036 854 775 807  |
| `unsigned long int`  | 0                          | 18 446 744 073 709 551 615 |

对于特定的实现，确定整数类型范围的一种方法是检查`<limits.h>`头（ 23.2 节）。该头是标准库的一部分，其中定义了表示每种整数类型的最大值和最小值的宏。

## C99 中的整数类型

# C99 额外整数类型

C99 标准提供了两个额外的标准整数类型：`long long int` 和 `unsigned long long int` 一是满足日益增长的对超大型整数的需求，二是适应支持 64 位运算的新处理器的能力。这两个 `long long` 类型要求至少 64 位宽。所以 `long long int`：通常范围为  (-9,223,372,036,854,775,808) 到  (9,223,372,036,854,775,807)；`unsigned long long int`：通常范围为 $0$ 到 $2^{64}-1$ (18,446,744,073,709,551,615)

## 整型常量

C 语言允许用十进制（基数为 10）、八进制（基数为 8）和十六进制（基数为 16）形式书写整型常量。

- 十进制常量包含 0~9 中的数字，但是一定不能以零开头：
- 八进制常量只包含 0~7 中的数字，而且必须要以零开头：
	- 017
	- 0377
	- 077777
- 十六进制常量包含 0~9 中的数字和 a~f 中的字母，而且总是以 0x 开头：
	- 0xf
	- 0xff
	- 0x7fff
	- 十六进制常量中的字母既可以是大写字母也可以是小写字母，甚至是大小写字母混合。

请记住八进制和十六进制只是书写数的方式，它们不会对数的实际存储方式产生影响。（整数都是以二进制形式存储的，跟表示方式无关。）任何时候都可以从一种书写方式切换到另一种书写方式，甚至可以混合使用：10 + 015 + 0x20 的值为 55（十进制）。八进制和十六进制更适用于底层程序的编写，本书直到第 20 章才会较多地用到它们。

十进制整型常量的类型通常为 `int`，但如果常量的值大得无法存储在 `int` 型中，那就用 `long int` 类型。如果出现 `long int` 不够用的罕见情况，编译器会用 `unsigned long int` 做最后的尝试。确定八进制和十六进制常量的规则略有不同：编译器会依次尝试 `int`、`unsigned int`、 `long int` 和 `unsigned long int` 类型，直至找到能表示该常量的类型。

要强制编译器把常量作为长整数来处理，只需在后边加上一个字母 `L`（或 `l`）：
- `15L`
- `0377L`
- `0x7fffL`

要指明是无符号常量，可以在常量后边加上字母 `U`（或 `u`）:
- `15U`
- `0377U`
- `0x7fffU`

## C99 中的整型常量

在 C99 中，以 `LL` 或 `ll`（两个字母大小写要一致）结尾的整型常量是 `long long int` 型的。如果在 `LL` 或 `ll` 的前面或后面增加字母 `U`（或 `u`），则该整型常量为 `unsigned long long int` 型。

C99 确定整型常量类型的规则与 C89 有些不同。对于没有后缀（`U`、`u`、`L`、`l`、`LL`、`ll`）的十进制常量，其类型是 `int`、`long int` 或 `long long int` 中能表示该值的“最小”类型。对于八进制或者十六进制常量，可能的类型顺序为 `int`、`unsigned int`、`long int`、`unsigned long int`、`long long int` 和 `unsigned long long int`。

## 整数溢出

整数溢出时的行为要根据操作数是有符号型还是无符号型来确定。

有符号整数运算中发生溢出时，程序的行为是未定义的。回顾 [[04_表达式#子表达式的求值顺序|4.4 节]] 的介绍可知，未定义行为的结果是不确定的。最可能的情况是，仅仅是运算的结果出错了，但程序也有可能崩溃，或出现其他意想不到的状况。

无符号整数运算过程中发生溢出时，结果是有定义的：正确答案 **对 $2^n$ 取模**，其中 n 是用于存储结果的位数。例如，如果对无符号的 16 位数 65 535 加 1，其结果可以保证为 0。

## 读/写 整数

- 读写无符号整数时，使用字母 `u`、`o` 或 `x` 代替转换说明中的 `d`。如果使用 `u` 说明符， 该数将按十进制读写，`o` 表示八进制，`x` 表示十六进制。
- 读写短整数时，在 `d`、`o`、`u` 或 `x` 前面加上字母 `h`
- 读写长整数时，在 `d`、`o`、`u` 或 `x` 前面加上字母 `l`
- 读写长长整数时（仅限 C99），在 `d`、`o`、`u` 或 `x` 前面加上字母 `ll`

# 浮点类型

C 语言提供了 3 种浮点类型，对应三种不同的浮点格式。 
- `float`：单精度浮点数。
- `double`：双精度浮点数。
- `long double`：扩展精度浮点数。

在 C99 中，浮点类型分为两种：一种是实浮点类型，包括 `float`、`double` 和 `long double` 类型；另一种是 C99 新增的复数类型（ 27.3 节，包括 `float _Complex`、`double _Complex` 和 `long double _Complex`）。

C 标准没有说明 `float`、`double` 和 `long double` 类型提供的精度到底是多少，因为不同计算机可以用不同方法存储浮点数。大多数现代计算机遵循 IEEE 754 标准（即 IEC 60559）

> [!NOTE] IEEE 浮点标准
> 由 IEEE 开发的 IEEE 标准提供了两种主要的浮点数格式：单精度（32 位）和双精度（64 位）。数值以科学记数法的形式存储，每一个数都由三部分组成：符号、指数和小数。指数部分的位数说明了数值的可能大小程度，而小数部分的位数说明了精度。单精度格式中，指数长度为 8 位，而小数部分占了 23 位。因此，单精度数可以表示的最大值大约是 $3.40×10^{38}$，其中精度是 6 个十进制数字。
> 
> IEEE 标准还描述了另外两种格式：单扩展精度和双扩展精度。标准没有指明这些格式中的位数，但要求单扩展精度类型至少为 43 位，而双扩展精度类型至少为 79 位。想要获得更多有关 IEEE 标准和浮点算术的信息，可以参阅 David Goldberg 在 1991 年 3 月发表的文章“What Every Computer Scientist Should Know About Floating-Point Arithmetic”一文（刊载于 ACM Computing Surveys，第 23 卷第 1 期，第 5~48 页）。

### 表 7-4 浮点类型的特征（IEEE 标准）

| 类 型      | 最小正值                 | 最大值                 | 精度     |
| -------- | -------------------- | ------------------- | ------ |
| `float`  | $1.175 49×10^{38}$   | $3.402 82×10^{38}$  | 6 个数字  |
| `double` | $2.225 07×10^{-308}$ | $1.797 69×10^{308}$ | 15 个数字 |

在不遵循 IEEE 标准的计算机上，表 7-4 是无效的。事实上，在一些机器上，`float` 可以有和 `double` 相同的数值集合，或者 `double` 可以有和 `long double` 相同的数值集合。可以在头 `<float.h>`（ 23.1 节）中找到定义浮点类型特征的宏。

## 浮点常量

浮点常量可以有许多种书写方式。例如，下面这些常量全都是表示数 57.0 的有效方式：
- `57.0`
- `57.`
- `57.0e0`
- `57E0`
- `5.7e1`
- `5.7e+1`
- `.57e2`
- `570.e-1`

浮点常量必须包含小数点或指数；其中，指数指明了对前面的数进行缩放所需的 10 的幂次。如果有指数，则需要在指数数值前放置字母 E（或 e）。可选符号+或-可以出现在字母 E（或 e） 的后边。

默认情况下，浮点常量以双精度数的形式存储。换句话说，当 C 语言编译器在程序中发现常量 57.0 时， 它会安排数据以 `double` 类型变量的格式存储在内存中。这条规则通常不会引发任何问题，因为在需要时 `double` 类型的值可以自动转换为 `float` 类型值。

在某些极个别的情况下，可能会需要强制编译器以 float 或 long double 格式存储浮点常量。为了表明只需要单精度，可以在常量的末尾处加上字母 F 或 f（如 57.0F）；而为了说明常量必须以 long double 格式存储，可以在常量的末尾处加上字母 L 或 l（如 57.0L）。

C99 提供了十六进制浮点常量的书写规范。十六进制浮点常量以 `0x` 或 `0X` 开头 （跟十六进制整型常量类似）。这一特性很少用到。

## 读/写 浮点数

- 读取 `double` 类型的值时，在 `e`、`f` 或 `g` 前放置字母 `l`
	- 只能在 `scanf` 函数格式串中使用 `l`，不能在 `printf` 函数格式串中使用。在 `printf` 函数格式串中，转换 `e`、`f` 和 `g` 可以用来写 float 类型或 `double` 类型的值。 （ C99 允许 `printf` 函数调用中使用`%le`、`%lf` 和`%lg`，不过字母 `l` 不起作用。）
- 读写 `long double` 类型的值时，在 `e`、`f` 或 `g` 前放置字母 `L`

# 字符类型

`char` 类型的值可以根据计算机的不同而不同，因为不同的机器可能会有不同的字符集。

> [!NOTE] 字符集
> 当今最常用的字符集是美国信息交换标准码（ASCII）字符集（ [[附录E_ASCII 字符集]]），它用 7 位代码表示 128 个字符。在 ASCII 码中，数字 0~9 用 0110000~0111001 码来表示，大写字母 A~Z 用 1000001~1011010 码来表示。ASCII 码常被扩展用于表示 256 个字符，相应的字符集 Latin-1 包含西欧语言和许多非洲语言中的字符。

注意，字符常量需要用 **单引号** 括起来，而不是双引号。

## 字符操作

在 C 语言中字符的操作非常简单，因为存在这样一个事实：C 语言把字符当作小整数进行处理。毕竟所有字符都是以二进制的形式进行编码的，而且无须花费太多的想象力就可以将这些二进制代码看成整数。例如，在 ASCII 码中，字符的取值范围是 000 0000~111 1111，可以看成 0~127 的整数。

在 C 语言中，字符和整数之间的关联是非常强的，字符常量事实上是 int 类型而不是 char 类型（这是一个非常有趣的现象，但对我们并无影响）。当计算中出现字符时，C 语言只是使用它对应的整数值。

以数的方式处理字符可能会导致编译器无法检查出来的多种编程错误，还可能会导致我们编写出 `'a' * 'b' / 'c'` 这类无意义的表达式。此外，这样做也可能会妨碍程序的可移植性，因为程序可能基于一些对字符集的假设。

## 有符号字符和无符号字符

既然 C 语言允许把字符作为整数来使用，那么 `char` 类型应该像整数类型一样存在符号型和无符号型两种。通常有符号字符的取值范围是 -128~127，无符号字符的取值范围是 0~255。

C 语言标准没有说明普通 char 类型数据是有符号型还是无符号型，有些编译器把它们当作有符号型来处理，有些编译器则将它们当作无符号型来处理。（甚至还有一些编译器，允许程序员通过编译器选项来选择把 char 类型当成有符号型还是无符号型。）

> [!NOTE] 可移植性技巧
> 不要假设 `char` 类型默认为 `signed` 或 `unsigned`。如果有区别，用 `signed char` 或 `unsigned char` 代替 `char`。

由于字符和整数之间的密切关系，C89 采用术语整值类型（integral type）来统称整数类型和字符类型。枚举类型（ 16.5 节）也属于整值类型。

C99 不使用术语“整值类型”，而是扩展了整数类型的含义，使其包含字符类型和枚举类型。C99 中的 `_Bool` 型（ 5.2 节）是无符号整数类型。

## 算术类型

( [[C语言程序设计：现代方法（第2版•修订版）.pdf#page=126&selection=328,0,328,4&color=note|📖]])

## 转义序列

转义序列共有两种：字符转义序列（character escape）和数字转义序列（numeric escape）。

### 表 7-5 字符转义序列

| 名称      | 转义序列 |
| ------- | ---- |
| 警报（响铃）符 | `\a`   |
| 回退符     | `\b`   |
| 换页符     | `\f`   |
| 换行符     | `\n`   |
| 回车符     | `\r`   |
| 水平制表符   | `\t`   |
| 垂直制表符   | `\v`   |
| 反斜杠     | `\\`   |
| 问号      | `\?`   |
| 单引号     | `\'`   |
| 双引号     | `\"`   |

### 数字转义序列

字符转义序列使用起来很容易，但是它们有一个问题：转义序列列表没有包含所有无法打印的 ASCII 字符，只包含了最常用的字符。字符转义序列也无法用于表示基本的 128 个 ASCII 字符以外的字符。数字转义序列可以表示任何字符，所以它可以解决上述问题。

为了把特殊字符书写成数字转义序列，首先需要在类似 [[附录E_ASCII 字符集]] 那样的表中查找字符的八进制或十六进制值。例如，ASCII 码中的 ESC 字符（十进制值为 27）对应的八进制值为 33，对应的十六进制值为 1B。上述八进制或十六进制码可以用来书写转义序列。
- **八进制转义序列** 由字符 `\`  和跟随其后的一个最多含有三位数字的八进制数组成。（此数必须表示为无符号字符，所以最大值通常是八进制的 377。）例如，可以将转义字符写成 `\33` 或 `\033`。跟八进制常量不同，转义序列中的八进制数不一定要用 0 开头。
- **十六进制转义序列** 由 `\x` 和跟随其后的一个十六进制数组成。虽然标准 C 对十六进制数的位数没有限制，但其必须表示成无符号字符（因此，如果字符长度是 8 位，那么十六进制数的值不能超过 `FF`）。若采用这种表示法，可以把转义字符写成 `\x1b` 或 `\x1B` 的形式。 **字符 `x` 必须小写**，但是十六进制的数字（例如 `b`）不限大小写。

作为字符常量使用时，转义序列必须用一对单引号括起来。例如，表示转义字符的常量可以写成 `'\33'`（或 `'\x1b'` ）的形式。转义序列可能有点隐晦，所以采用 `#define` 的方式给它们命名通常是个不错的主意：

```c
#define ESC '\33' /* ASCII escape character */
```

转义序列不是唯一一种用于表示字符的特殊表示法。三联序列（ 25.3 节）提供了一种表示字符 `#、[、\、]、^、{、|、}、~` 的方法，这些字符在一些语言的键盘上是打不出来的。 C99 增加了通用字符名（ 25.4 节）。通用字符名跟转义序列相似，不同之处在于通用字符名可以用在标识符中。

## 字符处理函数

一种更快捷且更易于移植的转换方法是调用 C 语言的 `toupper` 库函数：

```c
ch = toupper(ch); /* converts ch to upper case */
```

`toupper` 函数在被调用时检测参数（本例中为 ch）是否为小写字母。如果是，它会把参数转换成相应的大写字母；否则，`toupper` 函数会返回参数的值。

调用 `toupper` 函数的程序需要在顶部放置下面这条 `#include` 指令：

```c
#include <ctype.h>
```

23.5 节会描述全部字符处理函数，并且给出了使用示例。 

## 用 `scanf` 和 `printf` 读/写 字符

```c
char ch;
scanf("%c", &ch); /* reads a single character */
printf("%c", ch); /* writes a single character */
```

在读入字符前，`scanf` 函数不会跳过空白字符。如果下一个未读字符是空格，那么在前面的例子中，`scanf` 函数返回后变量 `ch` 将包含一个空格。为了强制 `scanf` 函数在读入字符前跳过空白字符，需要在格式串中的转换说明 `%c` 前面加上一个空格：

```c
scanf(" %c", &ch); /* skips white space, then reads ch */
```

因为通常情况下 `scanf` 函数不会跳过空白，所以它很容易检查到输入行的结尾：检查刚读入的字符是否为换行符。例如，下面的循环将读入并且忽略掉当前输入行中剩下的所有字符：

```c
do {
	scanf("%c", &ch)
} while (ch != '\n');
```

下次调用 `scanf` 函数时，将读入下一输入行中的第一个字符。

## 用 `getchar` 和 `putchar` 读/写 字符

事实上，`getchar` 函数返回的是一个 `int` 类型的值而不是 `char` 类型的值（原因将在后续章节中讨论）。因此，如果一个变量用于存储 `getchar` 函数读取的字符，其类型设置为 `int` 而不是 `char` 也没啥好奇怪的。

执行程序时，使用 `getchar` 函数和 `putchar` 函数（胜于 `scanf` 函数和 `printf` 函数）可以节约时间。`getchar` 函数和 `putchar` 函数执行速度快有两个原因。第一个原因是，这两个函数比 `scanf` 函数和 `printf` 函数简单得多，因为 `scanf` 函数和 `printf` 函数是设计用来按不同的格式读/写多种不同类型数据的。第二个原因是，为了额外的速度提升，通常 `getchar` 函数和 `putchar` 函数是作为宏（ 14.3 节）来实现的。

`getchar` 函数还有一个优于 `scanf` 函数的地方：因为返回的是读入的字符，所以 `getchar` 函数可以应用在多种不同的 C 语言惯用法中，包括搜索字符或跳过所有出现的同一字符的循环：

```c
do {
	ch = getchar();
} while (ch != '\n');
```

把 `getchar` 函数调用移到控制表达式中，可以精简循环：

```c
while ((ch = getchar()) != '\n')
	;
```

实际上我们并不需要变量 `ch`，可以把 `getchar` 函数的返回值与换行符进行比较：

```c
[惯用法] while (getchar() != '\n')	/* skips rest of line */
	;
```

这个循环是非常著名的 C 语言惯用法，虽然这种用法的含义是十分隐晦的，但是值得学习。

>  在嵌入式系统中，此惯用法并非主流，直接移植可能带来风险。建议根据实际硬件和协议设计数据接收逻辑（如状态机解析、超时处理、中断驱动），而非依赖文本行的假设。

> [!warning] 
> 如果在同一个程序中混合使用 `getchar` 函数和 `scanf` 函数，请一定要注意。`scanf` 函数倾向于遗留下它“扫视”过但未读取的字符（包括换行符）。思考一下，如果试图先读入数再读入字符的话，下面的程序片段会发生什么：
> ```c
> printf("Enter an integer: ");
> scanf("%d", &i);
> printf("Enter a command: ");
> command = getchar();
> ```
> 在读入 `i` 的同时，`scanf` 函数调用将留下没有消耗掉的任意字符，包括（但不限于） 换行符。`getchar` 函数随后将取回第一个剩余字符，但这不是我们所希望的结果。

### 确定消息的长度

```c
/* Determines the length of a message */

#include <stdio.h>
int main(void) {
	int len = 0;
	
	printf("Enter a message: ");
	while (getchar() != '\n')
		len++;
	printf("Your message was %d character(s) long.\n", len);
	
	return 0;
}
```

# 类型转换

当发生下列情况时会进行**隐式转换**：
- 当算术表达式或逻辑表达式中操作数的类型不相同时。（C 语言执行所谓的常规算术转换。）
- 当赋值运算符右侧表达式的类型和左侧变量的类型不匹配时。
- 当函数调用中的实参类型与其对应的形参类型不匹配时。
- 当 return 语句中表达式的类型和函数返回值的类型不匹配时。

这里讨论前两种情况，其他情况留到第 9 章再介绍。

## 常规算术转换

整数始终可以转换为 `float` 类型；可能发生的最糟糕的事是精度会有少量损失。相反，把浮点数转换为 `int` 类型，将有小数部分的损失；更糟糕的是，如果原始数大于最大可能值或者小于最小可能值，那么将得到一个完全没有意义的结果。

常规算术转换的策略是把操作数转换成可以安全地适用于两个数值的“最狭小的”数据类型。（粗略地说，如果某种类型要求的存储字节比另一种类型少，那么这种类型就比另一种类型更狭小。）为了统一操作数的类型，通常可以将相对较狭小类型的操作数转换成另一个操作数的类型来实现（这就是所谓的提升）。最常用的提升是 **整值提升（integral promotion）** ，它把字符或短整数转换成 `int` 类型（或者某些情况下是 `unsigned int` 类型）。

执行常规算术转换的规则可以划分成两种情况：
- 任一操作数的类型是浮点类型的情况。
	- `float -> double -> long double`
- 两个操作数的类型都不是浮点类型的情况。
	- `int -> unsigned int -> long int -> unsigned long int`
	- 有一种特殊情况，只有在 `long int` 类型和 `unsigned int` 类型长度相同（比如 32 位） 时才会发生。在这类情况下，如果一个操作数的类型是 `long int`，而另一个操作数的类型是 `unsigned int`，那么两个操作数都会转换成 `unsigned long int` 类型。

> [!warning] 
> 当有符号操作数和无符号操作数组合起来时，有符号操作数会被“转换”为无符号的值。转换过程中需要加上或者减去 n+1 的倍数，其中 n 是无符号类型能表示的最大值。这条规则可能会导致某些隐蔽的编程错误。
> 假设 `int` 类型的变量 `i` 值为-10，而 `unsigned int` 类型的变量 `u` 值为 10。如果用 `<` 运算符比较变量 `i` 和变量 `u`，那么期望的结果应该是 1（真）。但是，在比较前，变量 `i` 转换为 `unsigned int` 类型。因为负数不能被表示成无符号整数，所以转换后的值将不再为-10，而是加上 4 294 967 296 的结果（假定 4 294 967 295 是最大的无符号整数），即 4 294 967 286。因而 `i < u` 比较的结果将为 0。有些编译器会在程序试图比较有符号数与无符号数时给出一条类似“comparison between signed and unsigned” 的警告消息。
> 因为此类陷阱的存在，所以最好尽量避免使用无符号整数，特别是不要把它和有符号整数混合使用。

## 赋值过程中的转换

常规算术转换不适用于赋值运算。C 语言会遵循另一条简单的转换规则，那就是把赋值运算右边的表达式转换成左边变量的类型。

把某种类型的值赋给类型更狭小的变量时， 如果该值在变量类型范围之外，那么将得到无意义的结果（甚至更糟）。

如果浮点常量被赋值给 `float` 型变量，那么建议在浮点常量尾部加上后缀 `f` ：

```c
f = 3.14159f;
```

如果没有后缀，常量 `3.14159` 将是 `double` 类型，可能会触发警告消息。

## C99 中的隐式转换

C99 中的隐式转换和 C89 中的隐式转换略有不同，这主要是因为 C99 增加了一些类型 （`_Bool`、`long long` 类型、扩展的整数类型和复数类型）。

为了定义转换规则，C99 允许每个整数类型具有“整数转换等级”。下面按从最高级到最低级的顺序排列：
1. `long long int`、`unsigned long long int`
2. `long int`、`unsigned long int`
3. `int`、`unsigned int`
4. `short int`、`unsigned short int`
5. `char`、`signed char`、`unsigned char`
6. `_Bool`

简单起见，这里忽略了扩展的整数类型和枚举类型。

C99 用整数提升（integer promotion）取代了 C89 中的整值提升（integral promotion），可以将任何等级低于 `int` 和` unsigned int` 的类型转换为 `int`（只要该类型的所有值都可以用 `int` 类型表示）或 `unsigned int`。

与 C89 一样，C99 中执行常规算术转换的规则可以分为两种情况：
- 任一操作数的类型是浮点类型的情况。只要两个操作数都不是复数型，规则与前面一样 （复数类型转换规则将在 27.3 节讨论）。
- 两个操作数的类型都不是浮点类型的情况。首先对两个操作数进行整数提升。如果这时两个操作数的类型相同，过程结束。否则，依次尝试下面的规则，一旦遇到可应用的规则就不再考虑别的规则。
	- 如果两个操作数都是有符号型或者都是无符号型，将整数转换等级较低的操作数转换为等级较高的操作数的类型。
	- 如果无符号操作数的等级高于或等于有符号操作数的等级，将有符号操作数转换为无符号操作数的类型。
	- 如果有符号操作数类型可以表示无符号操作数类型的所有值，将无符号操作数转换为有符号操作数的类型。
	- 否则，将两个操作数都转换为与有符号操作数的类型相对应的无符号类型。

另外，所有算术类型都可以转换为 `_Bool` 类型。如果原始值为 0 则转换结果为 0，否则结果为 1。

## 强制类型转换

C 语言把 ( 类型名) 视为一元运算符。

---

有些时候，需要使用强制类型转换来避免溢出。思考下面这个例子：

```c
long i;
int j = 1000;

i = j * j; /* overflow may occur */
```

乍看之下，这条语句没有问题。表达式 `j * j` 的值是 1 000 000，并且变量 `i` 是 `long int` 类型的， 所以 `i` 应该能很容易地存储这种大小的值，不是吗？问题是，当两个 int 类型值相乘时，结果也应该是 `int` 类型的，但是 `j * j` 的结果太大，以致在某些机器上无法表示为 `int` 型，从而导致溢出。幸运的是，可以使用强制类型转换避免这种问题发生：

```c
i = (long) j * j;
```

# 类型定义

[[05_选择语句#C89 中的布尔值|5.2 节]] 中，我们使用 `#define` 指令创建了一个宏，可以用来定义布尔型数据。但是， 一个更好的设置布尔类型的方法是利用所谓的类型定义（type definition）特性：

```c
typedef int Bool;
```

注意，`Bool` 是新类型的名字。还要注意，我们使用首字母大写的单词 `Bool`。将类型名的首字母大写不是必需的，只是一些 C 语言程序员的习惯。

采用 `typedef` 定义 `Bool` 会导致编译器在它所识别的类型名列表中加入 `Bool`。现在，`Bool` 类型可以和内置的类型名一样用于变量声明、强制类型转换表达式和其他地方了。

## 类型定义的优点

类型定义使程序更加易于理解（假定程序员仔细选择了有意义的类型名）。例如，假设变量 `cash_in` 和变量 `cash_out` 将用于存储美元数量。把 `Dollars` 声明成

```c
typedef float Dollars;
Dollars cash_in, cash_out;

/*
 * 这样的写法比下面的写法更有实际意义：
 * float cash_in, cash_out;
 */
```

类型定义还可以使程序更容易修改。如果稍后决定 `Dollars` 实际应该定义为 `double` 类型， 那么只需要改变类型定义就足够了：

```c
typedef double Dollars;
```

## 类型定义和可移植性

类型定义是编写可移植程序的一种重要工具。程序从一台计算机移动到另一台计算机可能引发的问题之一就是不同计算机上的类型取值范围可能不同。如果 `i` 是 `int` 类型的变量，那么赋值语句 `i = 100000;`

在使用 32 位整数的机器上是没问题的，但是在使用 16 位整数的机器上就会出错。

> [!NOTE] 可移植性技巧
> 为了更大的可移植性，可以考虑使用 typedef 定义新的整数类型名。

假设编写的程序需要用变量来存储产品数量，取值范围在 0~50 000。我们可以定义自己的“数量”类型，而避免使用 `int` 类型声明数量变量：

```c
typedef int Quantity;

Quantity q;

/* 当把程序转到使用较短整数的机器上时，需要改变 Quantity 的定义： */
typedef long Quantity;
```

可惜的是，这种技术无法解决所有的问题，因为 `Quantity` 定义的变化可能会影响 `Quantity` 类型变量的使用方式。我们至少需要改动使用了 `Quantity` 类型变量的 `printf` 函数调用和 `scanf` 函数调用，用转换说明`%ld` 替换`%d`。

C 语言库自身使用 `typedef` 为那些可能因 C 语言实现的不同而不同的类型创建类型名。这些类型的名字经常以 `_t` 结尾，比如 `ptrdiff_t`、`size_t` 和 `wchar_t`。这些类型的精确定义不尽相同，下面是一些常见的例子：

```c
typedef long int ptrdiff_t;
typedef unsigned long int size_t;
typedef int wchar_t;
```

在 C99 中，`<stdint.h>` 头使用 `typedef` 定义占用特定位数的整数类型名。例如， `int32_t` 是恰好占用 32 位的有符号整型。这是一种有效的定义方式，能使程序更易于移植。

# `sizeof` 运算符

表达式 `sizeof ( 类型名)` 的值是一个无符号整数，代表存储属于类型名的值所需要的字节数。表达式 `sizeof (char)` 的值始终为 1，但是对其他类型计算出的值可能会有所不同。在 32 位的机器上，表达式 `sizeof (int)` 的值通常为 4。注意，`sizeof` 运算符是一种特殊的运算符， 因为编译器本身通常就能够确定 `sizeof` 表达式的值。

通常情况下，`sizeof` 运算符也可以应用于常量、变量和表达式。跟应用于类型时不同，`sizeof` 应用于表达式时不要求圆括号，我们可以用 `sizeof i` 代替 `sizeof (i)`。但是， 由于运算符优先级的问题，圆括号有时还是需要的。编译器会把表达式 `sizeof i + j` 解释为 `(sizeof i) + j`，这是因为 `sizeof` 作为一元运算符的优先级高于二元运算符+。

显示 `sizeof` 值时要注意，这是因为 `sizeof` 表达式的类型是 `size_t`，一种由实现定义的类型。在 C89 中，最好在显示前把表达式的值转换成一种已知的类型。`size_t` 一定是无符号整型，所以最安全的方法是把 `sizeof` 表达式强制转换成 `unsigned long` 类型（C89 中最大的无符号类型），然后使用转换说明 `%lu` 显示：

```c
printf("Size of int: %lu\n", (unsigned long) sizeof(int));
```

在 C99 中，`size_t` 类型可以比 `unsigned long` 更长。但 C99 中的 `printf` 可以直接显示出 `size_t` 类型值而不需要强制转换。方法是在转换说明中的一般整数（通常用 `u`）代码前使用字母 `z`：

```c
printf("Size of int: %zu\n", sizeof(int)); /* C99 only */
```

# 问与答

( [[C语言程序设计：现代方法（第2版•修订版）.pdf#page=138&selection=267,0,278,1&color=note|📖]])
7.1 节说到%o 和%x 分别用于以八进制和十六进制书写无符号整数。那么如何以八进制和十六进制书写普通的（有符号）整数呢？（p.101）

> [!question] 浮点常量为什么存储成 `double` 格式而不是 `float` 格式？
> 由于历史的原因，C 语言更倾向于使用 `double` 类型，`float` 类型则被看作次要的。思考 Kernighan 和 Ritchie 的 The C Programming Language 一书中关于 `float` 的论述：“使用 `float` 类型的主要原因是节省大型数组的存储空间，或者有时是为了节省时间，因为在一些机器上双精度计算的开销格外大。”经典 C 要求所有浮点计算都采用双精度的格式。（C89 和 C99 没有这样的要求。）

> [!question] 十六进制的浮点常量是什么样子？使用这种浮点常量有什么好处？（p.103）
> 十六进制浮点常量以 `0x` 或 `0X` 开头，且必须包含指数（指数跟在字母 `P` 或 `p` 后面）。指数可以有符号，常量可以以 `f`、`F`、`l` 或 `L` 结尾。指数以十进制数表示，但代表的是 2 的幂而不是 10 的幂。例如：`0x1.Bp3` 表示 $(1.6875 \times 2^3 = 13.5)$。十六进制位 `B` 对应的位模式为 `1011`；因为 `B` 出现在小数点的右边，所以其每一位代表一个 2 的负整数幂，把它们 $((2^{-1} + 2^{-3} + 2^{-4}))$ 相加得到 0.6875。
> 十六进制浮点常量主要用于指定精度要求较高的浮点常量（包括 e 和 π 等数学常量）。十进制数具有精确的二进制表示，而十进制常量在转换为二进制时则可能受到舍入误差的些许影响。十六进制数对于定义极值（例如 `<float.h>` 头中宏的值）常量也是很有用的，这些常量很容易用十六进制表示，但难以用十进制表示。

> [!question] 为什么使用 `%lf` 读取 `double` 类型的值，却用`%f` 显示它呢？
> 这是一个很难回答的问题。首先注意，`scanf` 函数和 `printf` 函数都是不同寻常的函数，因为它们都没有将函数的参数限制为固定数量。`scanf` 函数和 `printf` 函数有可变长度的参数列表（ 26.1 节）。当调用带有可变长度参数列表的函数时，编译器会安排 `float` 参数自动转换成为 `double` 类型，其结果是 `printf` 函数无法区分 `float` 类型和 `double` 类型的参数。这解释了在 `printf` 函数调用中为何可以用%f 既表示 `float` 类型又表示 `double` 类型的参数。
> 另外，`scanf` 函数是通过指针指向变量的。`%f` 告诉 `scanf` 函数在所传地址位置上存储一个 `float` 类型值，而`%lf` 告诉 `scanf` 函数在该地址上存储一个 `double` 类型值。这里 `float` 和 `double` 的区别是非常重要的。如果给出了错误的转换说明，那么 `scanf` 函数将可能存储错误的字节数量（更不用说 `float` 类型的位模式可能不同于 `double` 类型的位模式）。

> [!question] `char` 的正确发音是什么？（p.104）
> 没有普遍接受的发音。一些人把 `char` 发音成“character”的第一个音节`[Kæ]`，还有一些人把它念成 `[t∫a: (r)]`，就像在 `char broiled;` 中那样。

> [!question] 我无法理解换行（new-line）符怎么会是 ASCII 码的回行（line-feed）符。当用户输入内容并且按下回车键时，程序不会把它作为回车符或者回车加回行符读取吗？（p.106）
> 不会的。作为 C 语言的 UNIX 继承部分，行的结束位置标记一直被看作单独的回行符。［在 UNIX 文本文件中，单独一个回行符（但不是回车符）会出现在每行的结束处。］C 语言函数库会把用户的按键翻译成回行符。当程序读文件时，输入/输出函数库将文件的行结束标记（不管它是什么）翻译成单个的回行符。与之相对应的反向转换发生在将输出往屏幕或文件中写的时候。（详见 22.1 节。）
> 虽然这些翻译可能看上去很混乱，但是它们都为了一个重要的目的：使程序不受不同操作系统的影响。

> [!question] 使用转义序列 `\?` 的目的是什么？（p.106）
> 转义序列 `\?` 与三联序列（ 25.3 节）有关，因为三联序列以 `??` 开头。如果需要在字符串中加入 `??`，那么编译器很可能会把它误认为三联序列的开始。用 `\?` 代替第二个 `?` 可以解决这个问题。

> [!question] 在什么情况下，整值提升会把字符或短整数转换成 `unsigned int` 类型？（p.111）
> 如果 `int` 类型整数没有大到足以包含所有可能的原始类型值，那么整值提升会产生 `unsigned int` 类型。因为字符的长度通常是 8 位，所以几乎总会转换为 `int` 类型（可以保证 `int` 类型至少为 16 位长度）。有符号短整数也总可以转换为 `int` 类型，但无符号短整数是有疑问的。如果短整数和普通整数的长度相同（例如在 16 位机上），那么无符号短整数必须被转换为 `unsigned int` 类型，因为最大的无符号短整数（在 16 位机上为 65 535）要大于最大的 `int` 类型数（即 32 767）。

> [!question] 如果把超出变量取值范围的值赋值给变量，究竟会发生什么？（p.113）
> 粗略地讲，如果值是整值类型并且变量是无符号类型，那么会丢掉超出的位数；如果变量是有符号类型，那么结果是由实现定义的。把浮点数赋值给整型或浮点型变量的话，如果变量太小而无法承受，会产生未定义的行为：任何事情都可能发生，包括程序终止。

> [!question] 为什么 C 语言要提供类型定义呢？定义一个 `BOOL` 宏不是和用 `typedef` 定义一个 `Bool` 类型一样好用吗？（p.115）
> 类型定义和宏定义存在两个重要的不同点。首先，类型定义比宏定义功能更强大。具体来说，数组和指针类型是不能定义为宏的。假设我们试图使用宏来定义一个“指向整数的指针”类型：
> ```c
> #define PTR_TO_INT int *
> 
> PTR_TO_INT p, q, r;
> 
> /* 在处理以后会变成 */
> int * p, q, r;
> ```
> 可惜的是，只有 `p` 是指针，`q` 和 `r` 都成了普通的整型变量。类型定义不会有这样的问题。
> 其次，`typedef` 命名的对象具有和变量相同的作用域规则；定义在函数体内的 `typedef` 名字在函数外是无法识别的。另外，宏的名字在预处理时会在任何出现的地方被替换。

> [!question] 本书中提到“编译器本身通常就能够确定 `sizeof` 表达式的值”。难道编译器不总能确定 `sizeof` 表达式的值吗？（p.117）
> 在 C89 中编译器总是可以的，但在 C99 中有一个例外。编译器不能确定变长数组（ 8.3 节）的大小， 因为数组中的元素个数在程序执行期间是可变的。

# 练习题

下列语句是否总是可以正确地计算出 f 的小数部分（假设 f 和 frac_part 都是 float 类型的变量）？

```c
frac_part = f – (int) f;
```

如果不是，那么出了什么问题？

不行。如果存储在变量 f 中的值超过了整型的最大值，那么将其转换为整型的操作将会失败。

---

