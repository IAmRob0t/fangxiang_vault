---
tags:
  - c
---

> [!NOTE] 变量，能变，就是可读可写，必定保存在内存里

# 程序怎么操作变量

ARM 芯片属于精简指令集计算机 (RISC：Reduced Instruction Set Computing)，它所用的指令比较简单，有如下特点：

1. 对内存只有读、写指令
2. 对于数据的运算是在CPU内部实现
3. 使用RISC指令的CPU复杂度小一点，易于设计

比如对于 a=a+b 这样的算式，需要经过下面 4 个步骤才可以实现：

1. 读 a
2. 读 b
3. 在 CPU 中运算 a + b
4. 写 a + b

细看这几个步骤，有些疑问：

1. 读 a，那么 a 的值读出来后保存在 CPU 里面哪里？
2. 读 b，那么 b 的值读出来后保存在 CPU 里面哪里？
3. a + b 的结果又保存在哪里？

![[c_变量_01.png|563]]

CPU 运行时，先去取得指令，再执行指令：

1. 把内存 a 的值读入 CPU 寄存器 R0
2. 把内存 b 的值读入 CPU 寄存器 R1
3. 把 R0、R1 累加，存入 R0
4. 把 R0 的值写入内存 a

我们通过查看程序的 Disassembly 可以看到：

```asm
    20:   a = 123; 
    21:    
0x0800019E 207B      MOVS     r0,#0x7B						// R0 = 123
0x080001A0 490A      LDR      r1,[pc,#40]  ; @0x080001CC	// 读 内存/Flash 中 0x080001CC 地址中的值，R1 = 0x2000 0000，即变量 a 的地址，编译程序链接程序时才确定
0x080001A2 6008      STR      r0,[r1,#0x00]					// 写内存 将 R0 写到 R1 中，即写到变量 a 的地址
```

[[CPU与外设]]

# 变量的地址分配

在编译调试上面那段 `.c` 代码我们会发现，变量 `a` 的地址刚好就是内存的首地址相同。如果对 C 语言的本质并不了解的人肯定会说这是编译器帮我们自动分配的，真的是自动的吗？

> [!question] 程序中变量的地址是编译器帮我们自动分配的吗？
> 并非自动。这是由链接器根据我们在设置中填写的只读基地址以及可读可写的基地址来决定变量地址。
> 在 Keil5v 中，我们可以在 Options  for Target 中的 Linker 中查看。

# 局部变量的分配、初始化以及生命周期

- [[04_A/Data Structure/栈#栈是什么？|栈是什么？]]
- [[04_A/Data Structure/栈#谁分配栈 / 如何分配栈？|谁分配栈 / 如何分配栈？]]
- [[04_A/Data Structure/栈#栈的使用|栈的使用]]

---

```asm
     7: { 
0x0800000C B501      PUSH     {r0,lr}			// 入栈
0x0800000E B081      SUB      sp,sp,#0x04
     8:   volatile int a = 321; 
     9:    
0x08000010 F2401041  MOVW     r0,#0x141
0x08000014 9000      STR      r0,[sp,#0x00]
    10:   v += a; 
    11:    
0x08000016 E9DD1000  LDRD     r1,r0,[sp,#0]
0x0800001A 4408      ADD      r0,r0,r1
0x0800001C 9001      STR      r0,[sp,#0x04]
    12:   return v; 
0x0800001E 9801      LDR      r0,[sp,#0x04]
    13: } 
    14:  
    15: int mymain() 
0x08000020 BD0C      POP      {r2-r3,pc}		// 出栈
0x08000022 0000      MOVS     r0,r0
```

---

- 局部变量
	- 内存分配：在函数调用时，**在栈上分配空间**
	- 初始化：不会自动初始化，若无显式初始化则包含随机值（垃圾值）
	- 生命周期：从声明点到所在代码块结束

## 局部变量的初始化

```c
void main()
{
    int a = 1;
    int b = 0x12345678;
    char c = 'A';
    char str[] = "A";
    char str2[] = "absadfsadfjsdfsadfsdfasdfasdfads";
    char *str3 = "absadfsadfjsdfsadfsdfasdfasdfads";
}
```

> [!question] 上述局部变量的初始化是如何完成的？
> 局部变量的初始值通常在编译时就确定，并作为指令的一部分。简单的初始值直接通过指令加载到寄存器；而复杂的初始值则存储在程序的只读数据段（通常在Flash中），然后在运行时复制到栈上。

# 全局变量和静态变量的分配、初始化以及生命周期

```c

#include "main.h"

int g_a = 123;					// 未被初始化

int add_val(volatile int v)
{
  volatile int a = 321;
  
  v += a;
  
  return v;
}

int mymain()
{
  static volatile int s_a = 1;	//未被初始化
  
  volatile int b = 456;
  
  volatile char name[100];
  
  b = add_val(s_a);
  
  name[0] = 'A';
  
  return 0;
}
```

假设一个极端的例子，如果我们有 10000 个全局变量，像局部变量一样初始化它们，难道我们要有 20000 条指令来初始化它们？

Flash 中包含代码段、数据段 DATA（保存有初始值的全局/静态变量）
而ZI段（Zero Initialized）只在RAM中分配：

- ZI
	- 无初始值的全局/静态变量
	- 初始为 0 的全局/静态变量

 在调用 `main()` 之前，我们就需要初始化全局变量，通过调用一个 [[copy函数]] 把 Flash 中的初始值拷贝到内存 RAM 中就好了

复制到哪里？[[#变量的地址分配]]
 
```asm
    19:   volatile int b = g_a; 
    20:    
    21:   volatile char name[100]; 
    22:    
0x08000028 4806      LDR      r0,[pc,#24]  ; @0x08000044	// r0 = 0x2000 0000
0x0800002A 6800      LDR      r0,[r0,#0x00]					// r0 = [r0]，即 r0 = g_a1
0x0800002C 9019      STR      r0,[sp,#0x64]
.
.
.
0x08000044 0000      DCW      0x0000
0x08000046 2000      DCW      0x2000
```

因为我在链接器中指定了具体的地址。

静态变量也是跟全局变量是一样的操作

- 全局变量、静态变量
	- 内存分配：在程序启动前，编译器在静态数据区分配空间
	- 初始化：若有显式初始化则使用指定值；若无，则自动初始化为0（数值类型）、NULL（指针）或'\0'（字符）
	- 生命周期：整个程序运行期间

但是有一些例外，我们继续假设一个极端的例子，当我们有 10000 个初始值为 0 或者没有给初始值的变量，我需要在二进制文件中保存这 10000 个 0 吗？

我们调用 [[memset]] （自己写）

---

对多任务系统，应该尽量少用全局变量，因为这是非线程安全的；即使对于裸机，也应该尽量少用。

> [!NOTE] 线程安全
> 线程安全是指在多线程环境下，代码能够正确地处理共享资源，不会因为多个线程同时访问而导致数据损坏或产生不可预期的结果。

---

