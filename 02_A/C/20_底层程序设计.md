---
tags:
  - c
---
>  如果程序要关心不该关心的事，那这门语言就是低级的。

# 位运算符

## 移位运算符

| 符号   | 含义  |
| ---- | --- |
| `<<` | 左移位 |
| `>>` | 右移位 |

运算符 `<<` 和运算符 `>>` 的操作数可以是任意整数类型（包括 `char` 型）。这两个运算符对两个操作数都会进行整数提升，返回值的类型是左操作数提升后的类型。

---

> [!tip] 可移植性技巧
> 为了可移植性，最好仅对无符号数进行移位运算。

在 C 语言里，逻辑移位、算术移位都是使用 `<<` 和 `>>` ，无法区分。一般来说，无符号类型的数值移位时是“逻辑移位”，“有符号”的数值移位时是“算术移位”。

> [!tip] Tips
> 在嵌入式开发中，我们只涉及逻辑移位：不关心符号位，都是补 0。

---

如果要通过移位改变变量，需要使用复合赋值运算符 `<<=` 和 `>>=` ：

```c
i = 13;		/* i is now 13 (binary 0000000000001101) */
i <<= 2;	/* i is now 52 (binary 0000000000110100) */
i >>= 2;	/* i is now 3 (binary 0000000000000011) */
```

> [!warning] 移位运算符的优先级比算术运算符的优先级低
> 因此可能产生意料之外的结果。例如，`i << 2 + 1` 等同于 `i << (2 + 1)`，而不是 `(i << 2) + 1`

### 逻辑左移

```c
unsigned int a = 0x123;// a = 0b 0001 0010 0011
unsigned int b = a<<2; // b = 0b 0100 1000 1100 = 0x48C
```

逻辑左移两位就是在二进制数位后添加两个 0 ，前面多余的位删除

`0x48c = 0x123 * 2^2 = 0x123 * 4`

### 逻辑右移

```c
unsigned int a = 0x123;// a = 0b 0001 0010 0011
unsigned int b = a>>2; // b = 0b 0000 0100 1000 = 0x48
```

逻辑右移两位就相当于在二进制数位前添加两个 0

`0x48 = 0x123 / 2^2 = 0x123 / 4`

> [!NOTE] 每次左移，相当与乘以 2；每次右移，相当于除以 2。

## 按位求反运算符、按位与运算符、按位异或运算符和按位或运算符

| 符号   | 含义   |
| ---- | ---- |
| `~`  | 按位取反 |
| `&`  | 按位与  |
| `^`  | 按位异或 |
| `\|` | 按位或  |

运算符 `~` 、 `&` 、 `^` 和 `|` 对操作数的每一位执行布尔运算。

运算符 `~` 、 `&` 、 `^` 和 `|` 有不同的优先级：
- 最高 `~` 、 `&` 、 `^`
- 最低 `|`

> [!warning] Title
> 运算符 `&` 、 `^` 和 `|` 的优先级比关系运算符和判等运算符低（见附录 A 的 [[附录A_C语言运算符|运算符表]] ）。因此，下面的语句不会得到期望的结果：
> ```c
> if (status & 0x4000 != 0) ...
> ```
> 这条语句会先计算 `0x4000 != 0`（结果是 1），接着判断 `status & 1` 是否非 0，而不是判断 `status & 0x4000` 是否非 0。

### 取反

`~` 运算符会产生对操作数求反的结果， 即将每一个 0 替换为 1，将每一个 1 替换为 0。

对运算符 `~` 需要特别注意，因为它可以帮助我们使底层程序的可移植性更好。假设我们需要一个整数，它的所有位都为 1。最好的方法是使用 `~0` ，因为它不会依赖于整数所包含的位的个数。类似地，如果我们需要一个整数，除了最后 5 位其他的位全都为 1，我们可以写成 `~0x1f` 。

### 按位与

运算符 `&` 对两个操作数相应的位执行逻辑与运算。

两位相与，结果如下：

```
1 & 1 = 1
1 & 0 = 0
0 & 1 = 0
0 & 0 = 0
```

### 按位或

运算符 `^` 和 `|` 相似（都是对两个操作数执行逻辑或运算），不同的是，当两个操作数的位都是 1 时，`^` 产生 0 而 `|` 产生 1。

两位相或，结果如下：

```
1 | 1 = 1
1 | 0 = 1
0 | 1 = 1
0 | 0 = 0
```

## 用位运算符访问位

在进行底层编程时，经常会需要将信息存储为单个位或一组位。例如，在编写图形程序时， 可能会需要将两个或更多个像素挤在一个字节中。使用位运算符就可以提取或修改存储在少数几个位中的数据。

### 位的设置（置位）

```c
unsigned int a = 0x123;
unsigned int b = a | (1<<7) | (1<<8); // 设置a的bit7, bit8, 赋给b
```

`(1<<7) | (1<<8)` 就是位掩码

> [!NOTE] 位掩码
> 是一种利用二进制数的各个位来表示特定状态或选项的技术，通过位运算（如与、或、异或）快速操作或检查这些状态，常用于高效管理多个布尔标志或权限控制，节省内存且提升运算效率。

### 位的清除（清位）

```c
unsigned int a = 0x123;
unsigned int b = a & ~((1<<7) | (1<<8)); // 清除a的bit7, bit8, 赋给b
```

### 把某几位设置为某值

比如要把 bit 7 设置为 1，把 bit 8 清除为 0，这可以分两步操作：先设置 bit 7，再清除 bit 8。还有一种情况：`bit[8:7]= val`, 不知道 `val` 的取值是多少，怎么办？先清除 bit 8、bit 7，再或上 val，代码如下：

```c
unsigned int a = 0x123;
unsigned int b = a & ~(3<<7); /* 清除bit7, bit8 */
b = b | (val << 7); /* 设置bit7, bit8为val */
```

### 位的测试

如果要测试第 j 位是否被设置，可以使用下面的语句：

```c
if (i & 1 << j)...		/* tests bit j */
```

---

为了使针对位的操作更容易，经常会给位命名。例如，如果想要使一个数的第 0、1 和 2 位分别对应蓝色（BLUE）、绿色（GREEN）和红色（RED）。

```c
// 首先，定义分别代表这三个位的位置的名字：
#define BLUE	1
#define GREEN	2
#define RED		4

// 设置、清除或测试 BLUE 位可以如下进行：
i |= BLUE;			/* sets BLUE bit */
i &= ~BLUE;			/* clears BLUE bit */
if (i & BLUE) ...	/* tests BLUE bit */

// 同时设置、清除或测试几个位也一样简单：
i |= BLUE | GREEN;			/* sets BLUE and GREEN bits */
i &= ~(BLUE | GREEN);		/* clears BLUE and GREEN bits */
if (i & (BLUE | GREEN)) ...	/* tests BLUE and GREEN bits */
```

## 用位运算符访问位域

位域就是 **在结构体里按指定位数划分存储空间，用来紧凑地表示多个小范围数值或标志位的一种语法**。

处理一组连续的位（位域）比处理单个位要复杂一点。下面是两种最常见的位域操作的例子。

> [!PDF|note] [[C语言程序设计：现代方法（第2版•修订版）.pdf#page=422&selection=167,0,167,9&color=note|C语言程序设计：现代方法（第2版•修订版）, p.401]]
> > 用位运算符访问位域
> 
> 

### 修改位域

### 获取位域

# 结构中的位域

> [!question] 什么是位域？
> **位域**（bit-field）是 C 语言中一种特殊的结构体成员定义方式，它允许程序员精确控制结构体中某个成员所占用的**位数**。
> 通过位域，可以在结构体中为成员指定占用的位宽，而不是完整的字节，这样能更高效地利用内存空间。
> 位域常用于**硬件寄存器映射**、**通信协议头解析**以及**需要紧凑数据表示的场景**，因为这些场合往往对内存布局或位级表示有严格要求。

虽然 [[#用位运算符访问位域|20.1 节]] 的方法可以操作位域，但这些方法不易使用，而且可能会引起一些混淆。幸运的是，C 语言提供了另一种选择——声明其成员表示位域的结构。

---

例如， 来看看 MS-DOS 操作系统（通常简称为 DOS）是如何存储文件的创建和最后修改日期的。由于日、月和年都是很小的数，将它们按整数存储会很浪费空间。DOS 只为日期分配了 16 位，其中 5 位用于日（day），4 位用于月（month），7 位用于年（year）。利用位域，可以定义相同形式的 C 结构：

```c
struct file_date {
	unsigned int day:		5;
	unsigned int month:		4;
	unsigned int year:		7;
};
```

由于所有的成员的类型都一样，如果需要，我们可以简化声明：

```c
struct file_date {
	unsigned int day: 5, month: 4, year: 7;
};
```

位域的类型必须是 `int`、`unsigned int` 或 `signed int`。使用 `int` 会引起二义性，因为有些编译器将位域的最高位作为符号位，另一些编译器则不会。

> [!tip] 可移植性技巧
> 将所有的位域声明为 `unsigned int` 或 `signed int` 。

从 C99 开始，位域也可以具有类型 `_Bool`，以及其他额外的位域类型。可以将位域像结构的其他成员一样使用，如下面的例子所示：

```c
struct file_date fd;

fd.day = 28;
fd.month = 12;
fd.year = 8;		/* represents 1988 */
```

注意，year 成员是根据其相距 1980 年（根据微软的描述，这是 DOS 出现的时间）的时间而存储的。在这些赋值语句之后，变量 `fd` 的形式如下所示：

![[C语言程序设计：现代方法（第2版•修订版）.pdf#page=425&rect=128,492,402,528&color=note|C语言程序设计：现代方法（第2版•修订版）, p.404]]

使用位运算符可以达到同样的效果，甚至可能使程序更快些。然而，使程序更易读通常比节省几微秒更重要。

## 位域是如何存储的

位域的操作效率很低，能不用就不用。

# 其他底层技术

## 定义依赖机器的类型

## 用联合提供数据的多个视角

## 将指针作为地址使用

## `volatile` 类型限定符

- 声明：告诉编译器不要优化此指令
- 作用：每次都从原始地址读取值，防止编译器优化导致错误。确保每次读写寄存器都是真正执行。

---

在一些计算机中，一部分内存空间是“易变”的，保存在这种内存空间的值可能会在程序运行期间发生改变，即使程序自身并未试图存放新值。

例如，一些内存空间可能被用于保存直接来自输入设备的数据。

`volatile` 类型限定符使我们可以通知编译器，程序中的某些数据是 “易变”的。

为了了解为什么要使用 `volatile` ，我们假设指针 `p` 指向的内存空间用于存放用户通过键盘输入的最近一个字符。这个内存空间是易变的：每次用户输入一个新字符，这里的值都会发生改变。我们可能使用下面的循环获取键盘输入的字符，并将它们存入一个缓冲区数组中：

```c
while (缓冲区未满) {
	等待输入;
	buffer[i] = *p;
	if (buffer[i++] == '\n')
		break;
}
```

比较好的编译器可能会注意到这个循环既没有改变 p ，也没有改变 `*p` ，因此编译器可能会对程序进行优化，使 `*p` 只被取一次：

```c
在寄存器中存储*p;
while (缓冲区未满) {
	等待输入;
	buffer[i] = 存储在寄存器中的值;
	if (buffer[i++] == '\n')
		break;
}
```

优化后的程序会不断复制同一个字符来填满缓冲区，这并不是我们想要的程序。将 p 声明成指向易变的数据的指针可以避免这一问题的发生，因为 `volatile` 限定符会通知编译器 `*p` 每一次都必须从内存中重新取。

---

### 一、volatile的三大应用场景

1. ​**​共享访问（Shared Access）​**​
    
    - 多线程环境下全局变量可能被异步修改（如RT-Thread示例）
        
    - 典型问题：O3优化将`while(flag==0)`编译为单次读取寄存器值（r3），导致线程死循环
        
    - 解决方案：`volatile int flag`强制每次从内存读取
        
    
2. ​**​触发访问（Trigger Access）​**​
    
    - 内存映射寄存器（如UART数据寄存器）
        
    - 硬件特性：读取动作本身可能改变寄存器状态
        
    - 必须声明为`volatile uint32_t *reg`避免缓存旧值
        
    
3. ​**​意外修改（Modified Access）​**​
    
    - 内核态/用户态共享内存
        
    - DMA传输等硬件直接修改的内存区域
        
    

### 二、编译器优化对抗策略

|现象|本质原因|解决方案|
|---|---|---|
|循环变量不更新|寄存器缓存|volatile修饰/插入内存屏障|
|外部调用后恢复正常|函数调用阻止优化|添加`asm volatile("":::"memory")`|
|优化等级影响行为|内存布局变化|关键变量统一volatile声明|

### 三、实战调试技巧

1. ​**​优化敏感型BUG定位​**​
    
    - 对比O0/O3编译的反汇编代码（如ARM的`ldr`指令差异）
        
    - 使用`rt_kprintf`等I/O函数打破优化（编译器无法推断副作用）
        
    
2. ​**​GCC内联汇编屏障​**​
    
    ```
    asm volatile("":::"memory"); // 强制内存同步
    ```
    
    - 原理：告知编译器内存可能被未知方式修改
        
    - 比volatile更细粒度的控制
        
    

### 四、设计原则

1. ​**​外设寄存器必须volatile​**​
    
    包括：状态寄存器、数据缓冲区、中断标志等
    
2. ​**​多线程共享数据双重保护​**​
    
    ```
    volatile int shared_val;  // 防止优化
    rt_mutex_t lock;          // 防止竞态
    ```
    
3. ​**​内存映射场景验证​**​
    
    - 检查MMU配置确保物理地址一致性
        
    - 混合使用volatile与`__attribute__((section))`
        
    

该技术本质是建立编译器与硬件的"契约"，在实时系统、驱动开发等领域具有不可替代性。正确使用需结合具体架构特性（如ARM的弱内存模型），是嵌入式工程师的核心能力之一。