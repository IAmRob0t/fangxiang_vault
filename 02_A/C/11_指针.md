---
tags:
  - c
---

# 变量的使用过程

SoC 芯片里面有：CPU、内存 （RAM）、Flash、GPIO 等各种模块。这些模块有各自的特性：
1. CPU：读取指令、运行指令
2. RAM：往指定地址里写入数据，再读同一个地址必定得到同样的数据，RAM 起暂存的作用。
3. Flash：CPU 能像读 RAM 一样读 Flash，但是不能像写 RAM 一样写 Flash（要先擦除才能执行特定的操作去烧写，保证 Flash 上的数据不会被轻易地破坏。
4. GPIO：CPU 也能像读写 RAM 一样读写 GPIO 模块，但是写入的数据有特定的作用（配置引脚、设置引脚电平、读取引脚电平）。

简化的硬件结构如下：

![[HAL快速入门与项目实战.pdf#page=42&rect=144,125,449,394&color=note|HAL快速入门与项目实战(基于DshanMCU-103)_20240130, p.42]]

CPU 根据程序通过访问不同的地址来访问不同的设备

---

`a`、`p` 都是“变量”，可以变化，就是可读可写，必定在内存里。

> [!important] 变量可读可写，必定在内存里


# 指针变量

**大多数现代计算机将内存分割为字节（byte），每个字节可以存储 8 位的信息。**

![[C语言程序设计：现代方法（第2版•修订版）.pdf#page=209&rect=187,355,344,385|C语言程序设计：现代方法（第2版•修订版）, p.188]]

每个字节都有唯一的地址（address），用来和内存中的其他字节相区别。如果内存中有 n 个字节，那么可以把地址看作 0~n-1 的数。

![[C语言程序设计：现代方法（第2版•修订版）.pdf#page=209&rect=221,186,306,321|C语言程序设计：现代方法（第2版•修订版）, p.188]]

可执行程序由代码（原始 C 程序中与语句对应的机器指令）和数据（原始程序中的变量） 两部分构成。程序中的每个变量占有一个或多个字节内存，把第一个字节的地址称为变量的地址。下图中，变量 i 占有地址为 2000 和 2001 的两个字节，所以变量 i 的地址是 2000：

![[C语言程序设计：现代方法（第2版•修订版）.pdf#page=209&rect=218,55,313,133|C语言程序设计：现代方法（第2版•修订版）, p.188]]

这就是指针的出处。虽然用数表示地址，但是地址的取值范围可能不同于整数的范围，所以一定不能用普通整型变量存储地址。但是，可以用特殊的指针变量（pointer variable）存储地址。在用指针变量 p 存储变量 i 的地址时，我们说 p “指向” i。换句话说，指针就是地址，而指针变量就是存储地址的变量。

## 指针变量的声明

```c
int *p;
```

上述声明说明 p 是指向 `int` 类型对象的指针变量。这里我们用术语对象来代替变量，是因为 p 可以指向不属于变量的内存区域（见第 17 章）。（注意，在第 19 章讨论程序设计时“对象” 一词将有不同的含义。）

指针变量可以和其他变量一起出现在声明中。

C 语言要求每个指针变量只能指向一种特定类型（引用类型）的对象。

至于引用类型是什么类型则没有限制。事实上，指针变量甚至可以指向另一个指针，即指向指针的指针（ 17.6 节）。

## 指针变量的大小

```c
char c;		// 大小为1字节
short b;	// 大小为2字节
int a;		// 大小为4字节
long i;		// 对于32位处理，大小为4字节；对于64位处理器，大小为8字节
char *p1;	// 指针用来保存地址，无论是何种指针，对于32位处理器，指针变量的大小都是4字节
short *p2;	// 指针用来保存地址，无论是何种指针，对于32位处理器，指针变量的大小都是4字节
int *p3;	// 指针用来保存地址，无论是何种指针，对于32位处理器，指针变量的大小都是4字节
long *p4;	// 指针用来保存地址，无论是何种指针，对于32位处理器，指针变量的大小都是4字节
```

---

long 类型在不同位宽的 CPU 里，它占据的字节数不一样。为了屏蔽不同 CPU 位宽的差别，我们经常使用 [[27_C99对数学计算的新增支持|定宽整数类型]]

# 取地址运算符和间接寻址运算符

为使用指针，C 语言提供了一对特殊设计的运算符。为了找到变量的地址，可以使用 `&`（取地址）运算符。如果 `x` 是变量，那么 `&x` 就是 `x` 在内存中的地址。为了获得对指针所指向对象的访问，可以使用 `*`（间接寻址）运算符。如果 `p` 是指针，那么 `*p` 表示 `p ` 当前指向的对象。

## 取地址运算符

在使用前初始化 p 是至关重要的。一种初始化指针变量的方法是使用&运算符把某个变量的地址赋给它，或者更常采用 [[04_表达式#左值|左值（ 4.2 节）]] ：

```c
int i, *p;
...
p = &i;
```

在声明指针变量的同时对它进行初始化是可行的：

```c
int i;
int *p = &i;
```

甚至可以把 i 的声明和 p 的声明合并，但是需要首先声明 i：

```c
int i, *p = &i;
```

## 间接寻址运算符

一旦指针变量指向了对象，就可以使用 `*` 运算符访问存储在对象中的内容。

习惯于数学思维的读者可能希望把 `*` 想象成 `&` 的逆运算。对变量使用 `&` 运算符产生指向变量的指针，而对指针使用 `*` 运算符则可以返回到原始变量：

```c
j = *&i;	/* same as j = i; */
```

只要 p 指向 i，`*p` 就是 i 的别名。

> [!warning] 
> 不要把间接寻址运算符用于未初始化的指针变量。如果指针变量 p 没有初始化，那么试图使用 p 的值会导致未定义的行为：
> ```c
> int *p;
> printf ("%d", *p); /*** WRONG ***/
> ```
> 给 `*p` 赋值尤其危险。如果 p 恰好具有有效的内存地址，下面的赋值会试图修改存储在该地址的数据：
> ```c
> int *p;
> *p = 1; /*** WRONG ***/
> ```
> 如果上述赋值改变的内存单元属于该程序，那么可能会导致出乎意料的行为；如果改变的内存单元属于操作系统，那么很可能会导致系统崩溃。编译器可能会给出警告消息，告知 p 未初始化，所以请留意收到的警告消息。

# 指针赋值

C 语言允许使用赋值运算符进行指针的复制，前提是两个指针具有相同的类型：

```c
int i, j, *p, *q;
p = &i;
q = p;
*p = 1;
*q = 2;
```

![[C语言程序设计：现代方法（第2版•修订版）.pdf#page=212&rect=220,123,328,190|C语言程序设计：现代方法（第2版•修订版）, p.191]]

# 指针作为参数

声明相应的形式参数 p 为指针。调用函数时，p 的值为 `&x` ，因此 `*p`（p 指向的对象） 将是 x 的别名。函数体内 `*p` 的每次出现都将是对 x 的间接引用，而且函数既可以读取 x 也可以修改 x。

用指针作为函数的实际参数实际上并不新鲜，从第 2 章开始你就已经在 `scanf` 函数调用中使用了。思考下面的例子：

```c
int i;
...
scanf("%d", &i);
```

必须把 `&` 放在 i 的前面以便给 `scanf` 函数传递指向 i 的指针，指针会告诉 `scanf` 函数把读取的值放在哪里。如果没有 `&` 运算符，传递给 `scanf` 函数的将是 i 的值。

虽然 `scanf` 函数的实际参数必须是指针，但并不总是需要 `&` 运算符。在下面的例子中，我们向 `scanf` 函数传递了一个指针变量：

```c
int i, *p;
...
p = &i;
scanf("%d", p);
```

> [!question] 
> 向函数传递需要的指针却失败了，这可能会产生严重的后果。假设我们在调用 decompose 函数时没有在 i 和 d 前面加上 `&` 运算符：
> ```c
> decompose (3.14159, i, d);
> ```
> `decompose` 函数期望第二个和第三个实际参数是指针，传入的却是 i 和 d 的值。 `decompose` 函数没有办法区分，所以它会把 i 和 d 的值当成指针来使用。当 `decompose` 函数把值存储到 `*int_part` 和 `*frac_part` 中时，它会修改未知的内存地址，而不是修改 i 和 d。
> 如果已经提供了 `decompose` 函数的原型（当然，应该始终这样做），那么编译器将告诉我们实际参数的类型不对。然而，在 `scanf` 的例子中，编译器通常不会检查出传递指针失败，因此 `scanf` 函数特别容易出错。

### 程序：找出数组中的最大元素和最小元素

## 用 const 保护参数

当调用函数并且把指向变量的指针作为参数传入时，通常会假设函数将修改变量（否则， 为什么函数需要指针呢？）。例如，如果在程序中看到语句

```c
f (&x);
```

大概是希望 f 改变 x 的值。但是，f 也可能仅需要检查 x 的值而不是改变它的值。指针可能高效的原因是，如果变量需要大量的存储空间，那么传递变量的值会浪费时间和空间。（12.3 节会更详细地介绍这方面的内容。）

可以使用单词 `const` 来表明函数不会改变指针参数所指向的对象。`const` 应放置在形式参数的声明中，后面紧跟着形式参数的类型说明：

```c
void f (const int *p)
{
	*p = 0; /*** WRONG ***/
}
```

# 指针作为返回值

我们不仅可以为函数传递指针，而且还可以编写返回指针的函数。返回指针的函数是相对普遍的。

> [!warning] 永远不要返回指向自动局部变量的指针：
> ```c
> int *f (void)
> {
> 	int i;
> 	...
> 	return &i;
> }
> ```
> 一旦 f 返回，变量 i 就不存在了，所以指向变量 i 的指针将是无效的。有的编译器会在这种情况下给出类似“function returns address of local variable”的警告。

# 问与答

> [!question] 指针总是和地址一样吗？（p.189）
> 通常是，但不总是。考虑用字而不是字节划分内存的计算机。字可能包含 36 位、60 位等。如果假设字包含 36 位，那么内存将有如下显示：
> ![[C语言程序设计：现代方法（第2版•修订版）.pdf#page=218&rect=184,554,372,686|C语言程序设计：现代方法（第2版•修订版）, p.197]]
> 当用字划分内存时，每个字都有一个地址。通常整数占一个字长度，所以指向整数的指针可以就是一个地址。但是，字可以存储多于一个的字符。例如，36 位的字可以存储 6 个 6 位的字符：
> ![[C语言程序设计：现代方法（第2版•修订版）.pdf#page=218&rect=185,494,365,521|C语言程序设计：现代方法（第2版•修订版）, p.197]]
> 或者 4 个 9 位的字符：
> ![[C语言程序设计：现代方法（第2版•修订版）.pdf#page=218&rect=185,446,366,474|C语言程序设计：现代方法（第2版•修订版）, p.197]]
> 由于这个原因，可能需要用不同于其他指针的格式存储指向字符的指针。指向字符的指针可以由地址（存储字符的字）加上一个小整数（字符在字内的位置）组成。
> 在一些计算机上，指针可能是“偏移量”而不完全是地址。例如，Intel x86 CPU（用于许多个人计算机）可以在多种模式下执行程序。最老的模式称为实模式（real mode），可以追溯到 1978 年的 8086 处理器。在这种模式下，地址有时用一个 16 位数（偏移量）表示，有时用两个 16 位数（段—偏移量对）表示。偏移量不是真正的内存地址，CPU 必须把它和存储在专用寄存器中的段值结合起来。为了支持实模式，旧的 C 语言编译器通常提供两种指针：近指针（16 位偏移量）和远指针（32 位段 — 偏移量对）。这些编译器通常保留单词 near 和 far 作为非标准关键字，用于指针变量的声明。

> [!question] 如果指针可以指向程序中的数据，那么使指针指向程序代码是否可能？
> 可能。17.7 节将介绍指向函数的指针。

> [!question] 有没有办法显示变量的地址？（p.189）
> 任何指针（包括变量的地址）都可以通过调用 `printf` 函数并在格式串中使用转换说明 `%p` 来显示。详见 22.3 节。

> [!question] 下列声明使人糊涂：`void f (const int *p);` 这是说函数 f 不能修改 p 吗？
> 不是。这说明不能改变指针 p 指向的整数，但是并不阻止 f 改变 p 自身。
> ```c
> void f (const int *p)
> {
> 	int j;
> 	*p = 0; /*** WRONG ***/
> 	p = &j; /* legal */
> }
> ```
> 因为实际参数是值传递的，所以通过使指针指向其他地方的方法给 p 赋新值不会对函数外部产生任何影响。

> [!question] 声明指针类型的形式参数时，像下面这样在参数名前面放置单词 `const` 是否合法？`void f(int * const p);`
> 是合法的。然而效果不同于把 const 放在 p 的类型前面。在 [[#用 const 保护参数|11.4 节]] 中已经见过在 p 的类型前面放置 const 可以保护 p 指向的对象。在 p 的类型后面放置 const 可以保护 p 本身：
> ```c
> void f (int * const p)
> {
> 	int j;
> 	
> 	*p = 0; /* legal */
> 	p = &j; /*** WRONG ***/
> }
> ```
> 这一特性很少用到。因为 p 仅仅是另一个指针（调用函数时的实际参数）的副本，所以极少有什么理由保护它。
> 更罕见的一种情况是需要同时保护 p 和它所指向的对象，这可以通过在 p 类型的前后都放置 `const` 来实现：
> ```c
> void f (const int * const p)
> {
> 	int j;
> 	
> 	*p = 0; /*** WRONG ***/
> 	p = &j; /*** WRONG ***/
> }
> ```

