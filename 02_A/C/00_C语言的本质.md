---
deadline: 2025-04-27
tags:
  - c
  - freeRTOS
---
# C 语言的本质

## ARM 架构与汇编简明教程

```c
int a;
a++;	// a = a + 1，涉及读操作，累加操作，写操作
```

1. CPU 会从内存中读数据，然后保存到 CPU 中的某个寄存器中，假设存入 R0
	- R0~R15
	- R15 是 PC 寄存器，程序计数器，想去执行某个函数的时候，可以把函数的地址扔给这个寄存器，CPU 就可以跳过去执行了
	- R13 是 SP 寄存器（别名），栈寄存器
	- R14 是 LR 寄存器，保存返回地址
	- R15 是 PC 寄存器，保存当前指令地址
2. CPU 中的 ALU 执行累加操作，R0 = R0 + 1
3. CPU 将 R0 的数据写到内存中的 address A 中

### 重定位

```c
#include "main.h"

volatile int a = 123;

int mymain()
{
	volatile int b;
	
	b = a;
	
	return 0;
}
```

通过编译调试以上程序我们发现，当程序执行到最后，变量 `a == b == 0`，可以推断出在 `main` 函数执行之前，并没有执行 `a = 123`。这是为什么？

因为一上电执行的是以下这段汇编码：

```asm
; Vector Table Mapped to Address 0 at Reset
                AREA    RESET, DATA, READONLY
				EXPORT  __Vectors
					
__Vectors       DCD     0                  
                DCD     Reset_Handler              ; Reset Handler

				AREA    |.text|, CODE, READONLY

; Reset handler
Reset_Handler   PROC
				EXPORT  Reset_Handler             [WEAK]
                IMPORT  mymain

				LDR SP, =(0x20000000+0x10000)
```

```asm
				BL mymain
            	ENDP 
            	
            	END
```

它在设置了栈之后就去调用了，`mymain` 函数，根本没有去操作全局变量，Flash 可能有"123"这个值，但是我们的程序并没有去把"123"搬到内存中 a 的位置。

所以我们要在这段汇编代码中增加一段用 Flash 上的初始值，初始化全局变量 `a` 的代码，这叫做**重定位**。

### 不同类型变量汇编语言的读操作差异

```c
#include "main.h"

volatile int a = 123;

int mymain()
{
  volatile int b;
  volatile char c;
  volatile int d;
  
  b = 1;
  c = 2;
  
  d = b;
  b = c;
  
  return 0;
}
```

编译调试以上程序

```asm
    10:   b = 1; 
0x08000016 2001      MOVS     r0,#0x01		// r0 = 1
0x08000018 9001      STR      r0,[sp,#0x04]	// store r0 到 sp + 4 中，即变量 b 的地址
    11:   c = 2; 
    12:    
0x0800001A 2002      MOVS     r0,#0x02		// r0 = 2
0x0800001C 9000      STR      r0,[sp,#0x00]	// 我的变量 c 是字符型，却帮我写了四个字节进去
// 这是进行取巧了，写就这么写了，但是读一定不能这么读

    14:   d = b; 
0x0800001E 9802      LDR      r0,[sp,#0x08]	// 读 int b
0x08000020 9000      STR      r0,[sp,#0x00]
    15:   b = c; 
    16:    
0x08000022 F89D0004  LDRB     r0,[sp,#0x04]	// 读 char c，这个 LDRB 的 B 表示 byte 
0x08000026 9002      STR      r0,[sp,#0x08]
```

## [[变量]]是什么

## [[04_A/Data Structure/栈]]、[[04_A/Data Structure/堆]]是什么

| 对比项    | 栈（Stack）                      | 堆（Heap）                                      |
| ------ | ----------------------------- | -------------------------------------------- |
| 分配方式   | 由编译器自动分配和释放（函数调用时分配，返回时释放）    | 由程序员手动分配和释放（如 malloc/free，或由 GC 自动回收）        |
| 生命周期   | 局部变量的生命周期仅限于其所在的函数或代码块        | 只要不手动释放（或 GC 回收），堆上分配的内存会一直存在                |
| 管理方式   | 后进先出（LIFO），由系统自动管理            | 无特定顺序，需程序员或 GC 自行管理                          |
| 访问速度   | 较快（由 CPU 直接支持，通常为寄存器 + 偏移寻址）  | 较慢（需要指针间接寻址）                                 |
| 空间大小   | 较小，受限于系统设置（如嵌入式常见几 KB 到几十 KB） | 较大，仅受限于系统可用内存                                |
| 主要用途   | 保存函数调用信息、局部变量、返回地址、上下文切换等     | 动态分配大块内存、如动态数组、链表、缓存等                        |
| 分配失败后果 | 通常导致栈溢出（stack overflow），程序崩溃  | malloc 返回 NULL，若未处理可能导致空指针异常                 |
| 地址增长方向 | **通常**从高地址向低地址增长              | **通常**从低地址向高地址增长                             |
| 典型分配方式 | 直接声明变量，如 int a;               | malloc/calloc/realloc/free（C++ 的 new/delete） |
| 释放方式   | 自动释放（函数返回时）                   | 需要手动释放（free）或等待 GC 回收，否则会造成内存泄漏              |
| 线程安全性  | 每个线程有独立的栈，天然线程安全              | 多线程共享堆，需加锁等手段保证线程安全                          |
| 典型错误   | 栈溢出、访问超出作用域的栈变量               | 内存泄漏、野指针、重复释放                                |

## FreeRTOS 相关

### 保存现场

> 在 FreeRTOS 里，保存“现场” ≈ 保存 **CPU 寄存器状态 + 程序计数器 + 程序状态寄存器**  
> 这样任务恢复后，CPU 能继续从上次中断的指令执行。

#### 1️⃣ Cortex-M 架构的“现场”具体包含什么

当任务切换时，内核需要把当前任务的上下文（context）保存到该任务的任务栈中，以便下次恢复时能继续执行。 

这些上下文主要包括：

- 自动压栈（硬件保存的寄存器）：
    - `R0–R3`
    - `R12`
    - `LR` (R14)
    - `PC` (R15)
    - `xPSR`  
        （这是异常进入时硬件自动压栈的部分）
- 手动压栈（FreeRTOS保存的寄存器）：
    - `R4–R11`
    - 可选：`LR` (R14) 的任务返回值

合起来就差不多是 ARM Cortex-M 架构的全部通用寄存器 + 程序计数器 + 程序状态寄存器。

#### 2️⃣ “现场” ≈ CPU的瞬时状态

- 狭义：就是当前 CPU 所有需要恢复的寄存器值（上下文）。
- 广义：还可以包含当前任务的堆栈指针SP、控制寄存器（如BASEPRI、PRIMASK等）和一些特定内核需要的状态（比如FPU寄存器，如果开启FPU）。


所以，“保存现场” 不只是16个寄存器，而是 CPU 在此时恢复任务继续执行所必需的所有状态信息。

### 什么是任务

> [!NOTE]
> 在 FreeRTOS 中，一个任务由**任务函数**、**任务栈**以及一些任务控制块信息（**TCB**：Task Control Block）组成。TCB记录了任务栈指针、状态、优先级、延时等管理信息。
> 所以从内核角度看，**任务 = 任务函数 + 任务栈 + TCB**。  
> 从用户角度（写应用）看，可以**简单理解成“一个函数 + 它自己的独立栈”**。

| 项目         | 内容                            |
| ---------- | ----------------------------- |
| **全称**     | Task Control Block            |
| **作用**     | 存储任务的所有状态信息，供调度器管理            |
| **典型字段**   | 栈顶指针、优先级、任务名、状态链表项            |
| **与调度的关系** | 每次任务切换都会更新和使用对应的 TCB          |
| **关键全局变量** | `pxCurrentTCB`：指向当前正在运行的任务控制块 |
