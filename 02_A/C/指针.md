---
tags:
  - c
---
# 变量的使用过程

SoC 芯片里面有：CPU、内存 （RAM）、Flash、GPIO 等各种模块。这些模块有各自的特性：
1. CPU：读取指令、运行指令
2. RAM：往指定地址里写入数据，再读同一个地址必定得到同样的数据，RAM 起暂存的作用。
3. Flash：CPU 能像读 RAM 一样读 Flash，但是不能像写 RAM 一样写 Flash（要先擦除才能执行特定的操作去烧写，保证 Flash 上的数据不会被轻易地破坏。
4. GPIO：CPU 也能像读写 RAM 一样读写 GPIO 模块，但是写入的数据有特定的作用（配置引脚、设置引脚电平、读取引脚电平）。

简化的硬件结构如下：

![[HAL快速入门与项目实战.pdf#page=42&rect=144,125,449,394&color=note|HAL快速入门与项目实战(基于DshanMCU-103)_20240130, p.42]]

CPU 根据程序通过访问不同的地址来访问不同的设备

---

`a`、`p` 都是“变量”，可以变化，就是可读可写，必定在内存里。

> [!important] 变量可读可写，必定在内存里

# 指针变量的大小

```c
char c; // 大小为1字节
short b; // 大小为2字节
int a; // 大小为4字节
long i; // 对于32位处理，大小为4字节；对于64位处理器，大小为8字节
char *p1; // 指针用来保存地址，无论是何种指针，对于32位处理器，指针变量的大小都是4字节
short *p2; // 指针用来保存地址，无论是何种指针，对于32位处理器，指针变量的大小都是4字节
int *p3; // 指针用来保存地址，无论是何种指针，对于32位处理器，指针变量的大小都是4字节
long *p4; // 指针用来保存地址，无论是何种指针，对于32位处理器，指针变量的大小都是4字节
```

---

long 类型在不同位宽的 CPU 里，它占据的字节数不一样。为了屏蔽不同 CPU 位宽的差别，我们经常使用[[定宽整数类型（C99 起）|定宽整数类型]]

# [[20_底层程序设计#`volatile` 类型限定符|volatile]] 指针的双重修饰

```c
volatile char c;
volatile char *p1;

c = 1;

p1 = &c;
```

> [!question] 使用 `volatile` 的 p1 为什么在内存中，还是不显示
> 答案是被优化掉了，应该使用 `volatile char * volatile p` （当变量很多的时候可能就没法优化了，现在只是为了观察一下指针的操作）

进入调试可以看到：

|       | Value         | Type    |
| ----- | ------------- | ------- |
| `c`   | `0x02`        | Char    |
| `&c`  | `0x2000 0660` | Pointer |
| `p1`  | `0x2000 0660` | Char *  |
| `&p1` | `0x2000 0664` | Pointer |

# 函数指针


对于一个函数，它也是一个数据，也要存放在内存里面。我们能定义一个指针，指向变量的地址，是否也可以定义一个指针，指向函数的地址？

```c
void fun(void);
void fun(void){;}

void (*pfun)(void);
pfun = fun;
```

`pfun` 实质上还是一个指针变量，但是它指向函数的地址

|      | 普通指针                             | 函数指针                                                      |
| ---- | -------------------------------- | --------------------------------------------------------- |
| 声明   | `int *p;`<br>`char *p;`          | `void (*pfun)(void);`<br>`int (*pfun)(int, char);`        |
| 赋值   | `p = &a;`<br>`p = addr;`         | `pfun = &fun;` <br>**`pfun = fun;`**<br>**函数的标识符就是函数的地址** |
| 使用   | `*p = value`                     | `(pfun)();`<br>**`pfun();`**<br>**通常直接调用就可以**             |
| 类型别名 | `typedef int *P;`<br>`P p1, p2;` | `typedef void (*PFUN)(void)`<br>`PFUN f1, f2;`            |

```c
//加法函数
int add(int a,int b)
{
  return a+b;
}

//减法函数
int sub(int a,int b)
{
  return a-b;
}

# if 1

//定义函数指针别名
typedef int (*pfun)(int, int); 

//计算函数
int calc(pfun fp, int a, int b)  
{
  return fp(a,b);
}

#else

  //不定义函数指针别名
  //typedef int (*pfun)(int, int); 

  //计算函数
  int calc(int (*pfun)(int, int), int a, int b)  
  {
    return pfun(a,b);
  }

#endif

int main(void)
{
  int c;

  c=calc(add, 5, 3); //加法

  c=calc(sub, 5, 3); //减法

  return 0;
}
```