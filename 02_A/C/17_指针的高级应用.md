---
tags:
  - c
---
# 动态存储分配

## 内存分配函数

## 空指针

# 动态分配字符串

## 使用 malloc 函数为字符串分配内存

## 在字符串函数中使用动态存储分配

## 动态分配字符串的数组

# 动态分配数组

## 使用 `malloc` 函数为数组分配存储空间

## `calloc` 函数

## `realloc` 函数

# 释放存储空间

## `free` 函数

## “悬空指针”问题

# [[04_A/Data Structure/链表]]

# 指向指针的指针

# 指向函数的指针  

对于一个函数，它也是一个数据，也要存放在内存里面。我们能定义一个指针，指向变量的地址，是否也可以定义一个指针，指向函数的地址？

```c
void fun(void);
void fun(void){;}

void (*pfun)(void);
pfun = fun;
```

`pfun` 实质上还是一个指针变量，但是它指向函数的地址

|      | 普通指针                             | 函数指针                                                      |
| ---- | -------------------------------- | --------------------------------------------------------- |
| 声明   | `int *p;`<br>`char *p;`          | `void (*pfun)(void);`<br>`int (*pfun)(int, char);`        |
| 赋值   | `p = &a;`<br>`p = addr;`         | `pfun = &fun;` <br>**`pfun = fun;`**<br>**函数的标识符就是函数的地址** |
| 使用   | `*p = value`                     | `(pfun)();`<br>**`pfun();`**<br>**通常直接调用就可以**             |
| 类型别名 | `typedef int *P;`<br>`P p1, p2;` | `typedef void (*PFUN)(void)`<br>`PFUN f1, f2;`            |

```c
//加法函数
int add(int a,int b)
{
  return a+b;
}

//减法函数
int sub(int a,int b)
{
  return a-b;
}

# if 1

//定义函数指针别名
typedef int (*pfun)(int, int); 

//计算函数
int calc(pfun fp, int a, int b)  
{
  return fp(a,b);
}

#else

  //不定义函数指针别名
  //typedef int (*pfun)(int, int); 

  //计算函数
  int calc(int (*pfun)(int, int), int a, int b)  
  {
    return pfun(a,b);
  }

#endif

int main(void)
{
  int c;

  c=calc(add, 5, 3); //加法

  c=calc(sub, 5, 3); //减法

  return 0;
}
```

## 函数指针作为参数

## `qsort` 函数

## 函数指针的其他用途

# 受限指针（C99）

# 灵活数组成员（C99）