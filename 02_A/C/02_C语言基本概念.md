---
tags:
  - c
---
 编写一个简单的 C 程序

# 编译和链接

程序转化为机器可以执行的形式。对于 C 程序来说，通常包含下列 3 个步骤：
- **预处理**。首先程序会被送交给预处理器（preprocessor）​。预处理器执行以 `#` 开头的命令（通常称为指令）​。预处理器有点类似于编辑器，它可以给程序添加内容，也可以对程序进行修改。
- **编译**。修改后的程序现在可以进入编译器（compiler）了。编译器会把程序翻译成机器指令（即目标代码）​。然而，这样的程序还是不可以运行的。
- **链接**。在最后一个步骤中，链接器（linker）把由编译器产生的目标代码和所需的其他附加代码整合在一起，这样才最终产生了完全可执行的程序。这些附加代码包括程序中用到的库函数（如 `printf` 函数）​。

事实上，由于预处理器通常会和编译器集成在一起，所以人们甚至可能不会注意到它在工作。

在 UNIX 系统环境下，通常把 C 编译器命名为 cc。为了编译和链接 pun. C 程序，需要在终端或命令行窗口录入如下命令：

```js
% cc pun.c
```

在编译和链接好程序后，编译器 cc 会把可执行程序放到默认名为a.out 的文件中。编译器 cc 有许多选项，其中有一个选项（-o 选项）允许为含有可执行程序的文件选择名字。例如，假设要把文件 pun. C 生成的可执行文件命名为 pun，那么只需录入下列命令：

```js
% cc -o pun pun.c
```

# 简单程序的一般形式

即使是最简单的 C 程序也依赖 3 个关键的语言特性：指令（在编译前修改程序的编辑命令）​、函数（被命名的可执行代码块，如 main 函数）和语句（程序运行时执行的命令）​。

## 指令

在编译 C 程序之前，预处理器会首先对其进行编辑。我们把预处理器执行的命令称为**指令**。

所有指令都是以字符 `#` 开始的 。这个字符可以把 C 程序中的指令和其他代码区分开来。指令默认只占一行，每条指令的结尾没有分号或其他特殊标记。

## 函数

事实上，C 程序就是函数的集合。

## 语句

C 语言规定每条语句都要以分号结尾。​

# 变量和赋值

## 赋值

当我们把一个包含小数点的常量赋值给 `float` 型变量时，最好在该常量后面加一个字母 `f`（代表 `float`）​：

```c
profit = 2150.48f;
```

## 显示变量的值

如果要强制 `%f` 显示小数点后 $p$ 位数字，可以把 $.p$ 放置在 `%` 和 `f` 之间。例如，为了显示信息

```c
Profit: $2150.48
```

可以把 `printf` 写为如下形式：

```c
printf("Profit: $%.2f\n", profit);
```

# 标识符

在 C 语言中，**标识符可以含有字母、数字和下划线，但是必须以字母或者下划线开头**。​（在 C99 中，标识符还可以使用某些“通用字符名”​，25.4 节。​）

# 关键字

| auto     | enum               | restrict<sup>①</sup> | unsigned                |
| -------- | ------------------ | -------------------- | ----------------------- |
| break    | extern             | return               | void                    |
| case     | float              | short                | volatile                |
| char     | for                | signed               | while                   |
| const    | goto               | sizeof               | _Bool<sup>①</sup>       |
| continue | if                 | static               | __Complex<sup>①</sup>   |
| default  | inline<sup>①</sup> | struct               | __Imaginary<sup>①</sup> |
| do       | int                | switch               |                         |
| double   | long               | typedef              |                         |
| else     | register           | union                |                         |

① 仅 C99 有

# Q & A

> [!question] 问：GCC 发现程序中错误的能力如何
> 答：GCC 有多个命令行选项来控制程序检查的彻底程度。使用这些选项可以帮助我们有效地找出程序中潜在的故障区域。下面是一些比较常用的选项。

| 编译选项                       | 功能说明                                                                                                         |
| :------------------------- | :----------------------------------------------------------------------------------------------------------- |
| `-W`                       | 使编译器在检测到可能的错误时生成警告消息  <br>（`-W`后面可以加上具体的警告代码，`-Wall`表示"所有的`-W`选项"）  <br>​**​注意​**​：为了获得最好的效果，该选项应与`-O`选项结合使用 |
| `-pedantic`                | 根据C标准的要求生成警告消息  <br>避免在程序中使用非标准特性                                                                            |
| `-ansi`                    | 禁用GCC的非标准C特性  <br>启用一些不太常用的标准特性                                                                              |
| `-std=c89`  <br>`-std=c99` | 指明使用哪个版本的C标准检查程序                                                                                             |

> [!question] 问：在某些 C 语言书中，main 函数的结尾使用的是 exit (0) 而不是 return 0，二者是否一样呢？
> 答：当出现在 main 函数中时，这两种语句是完全等价的：二者都终止程序执行，并且向操作系统返回 0 值。使用哪种语句完全依据个人喜好而定。

> [!question] 问：编译器是完全移除注释还是用空格替换掉注释呢？
> 答：一些早期的编译器会删除每条注释中的所有字符，使得语句
> ```c
> a/**/b = 0;
> ```
> 可能被编译器理解成
> ```c
> ab = 0;
> ```
> 然而，依据 C 标准，编译器必须用一个空格字符替换每条注释语句，因此上面提到的技巧并不可行。我们实际上会得到下面的语句：
> ```c
> a b = 0;
> ```

> [!question] 问：为什么浮点常量需要以字母 f 结尾？​（p.14）
> 答：完整的解释见第 7 章。这里只简单回答一下：包含小数点但却不以 f 结尾的常量是 `double`（double precision 的缩写）型的。`double` 型的值比 `float` 型的值存储得更精确，并且可以存储比 `float` 型更大的值，因此在给 `float` 型变量赋值时需要加上字母 f。如果不加 f，编译器可能会生成一条警告消息，告诉你存储到 `float` 型变量中的数可能超出了该变量的取值范围。

> [!question] *对标识符的长度真的没有限制吗？​
> 是，又不是。C89 标准声称标识符可以任意长，但却只要求编译器记住前 31 个字符（C99 中是 63 个字符）​。因此，如果两个名字的前 31 个字符都相同，编译器可能会无法区别它们。
> 更复杂的情况是，C标准对于具有外部链接（➤18.2节）的标识符有特殊的规定，而大多数函数名都属于这类标识符。因为链接器必须能识别这些名字，而一些早期的链接器又只能处理短名字，所以在C89中只有前6个字符才是有效的。此外，还不区分字母的大小写。因此ABCDEFG和abcdefg可能会被作为相同的名字处理。​（C99中，前31个字符有效，且字母区分大小写。​）
> 大多数编译器和链接器都比标准所要求的宽松，所以实际使用中这些规则都不是问题。不要担心标识符太长，还是注意不要把它们定义得太短吧。

