---
tags:
  - c
---

> [!important] 16 进制数中每位数值占据 4 bit ，在内存中，是以 8 个 bit 作为 1 byte，因此 `0x12345678` 中每两位作为 1 byte。

假设 `int a = 0x12345678;` ，其中 `0x78` 是低 byte，`0x12` 是高 byte。 

![[HAL快速入门与项目实战.pdf#page=48&rect=110,97,426,263|HAL快速入门与项目实战, p.48]]

`0x12345678` 的低位（`0x78`）存在低地址，即方式 1，叫做 **小端序（Little-Endian）**
`0x12345678` 的高位（`0x12`）存在低地址，即方式 2，叫做 **大端序（Big-Endian）**
一般的 arm 芯片都是小字节序，有些处理器，可以置某个寄存器，让整个系统使用大字节序或小字节序。

# 编写 C app 判断当前 CPU 的字节序

要编写一个 C 程序来判断当前 CPU 的字节序（Endianness），可以通过检查一个整数的内存布局来确定。

以下是一个简单的 C 程序，用于判断当前 CPU 的字节序：

```c
#include <stdio.h>

int main() {
    unsigned int num = 0x1;
    unsigned char *byte = (unsigned char *)&num;

    if (*byte == 0x1) {
        printf("Little-endian\n");
    } else {
        printf("Big-endian\n");
    }

    return 0;
}
```