---
tags:
  - c
  - 字节序
  - endianness
---

> 字节序，即 Endianness，是指在多字节数据类型（如 `int`, `float`）在内存中存储时，其字节的排列顺序。

# 1. 高低字节与地址

对于一个多字节的数据，例如 `int a = 0x12345678;`：
*   **高位字节 (High Byte)**：`0x12`
*   **低位字节 (Low Byte)**：`0x78`

内存地址也有高低之分，例如，一个变量存储在从 `0x1000` 到 `0x1003` 的地址空间中，`0x1000` 就是低地址，`0x1003` 就是高地址。

# 2. 字节序的类型

字节序主要分为两种：小端序和大端序。

![[HAL快速入门与项目实战.pdf#page=48&rect=110,97,426,263|HAL快速入门与项目实战, p.48]]

## 小端序 (Little-Endian)

**规则**：数据的 **低位字节** 存储在内存的 **低地址** 中。
*   这是目前最常见的模式，例如 Intel x86 和 ARM 架构的处理器默认都使用小端序。

## 大端序 (Big-Endian)

**规则**：数据的 **高位字节** 存储在内存的 **低地址** 中。
*   常用于一些网络协议和部分RISC架构处理器。

> **注意**：有些处理器（如部分ARM）可以通过设置特定寄存器来切换大小端模式。

# 3. 使用C代码判断当前CPU的字节序

我们可以通过检查一个整数在内存中的首个字节来判断当前系统的字节序。

**原理**：
创建一个值为 `1` 的整数。在小端序中，其低位字节 `0x01` 会被存储在低地址处；而在大端序中，其高位字节 `0x00` 会被存储在低地址处。

**示例代码**：
```c
#include <stdio.h>

int main() {
    unsigned int num = 0x1;
    // 将整数指针强转为字符指针，从而可以访问其首个字节
    unsigned char *byte = (unsigned char *)&num;

    // 如果首个字节是1，说明是小端序
    if (*byte == 0x1) {
        printf("Little-endian\n");
    } else {
        printf("Big-endian\n");
    }

    return 0;
}
```
