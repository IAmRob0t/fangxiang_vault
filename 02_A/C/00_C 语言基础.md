---
deadline: 2025-04-22
tags:
  - c
---

# 位、字节、字的关系

- 位（bit）：计算机中最基本的单位，对应 0 或 1
- 字节（Byte）：计算机中数据存储的基本单位，8 位 = 1 字节
- 字（Word）：计算机进行数据处理和运算的单位。32 位机中，4 字节 = 1 字；64 位机种，8 字节 = 1 字

# 进制

> 在单片机开发中，掌握 C 语言的进制操作是理解底层硬件控制的关键。

## 硬件视角的进制本质

1. 晶体管物理层：MOS 管开关对应二进制 0/1，[[04_A/STM32/STM32数据的存储和表示|STM32数据的存储表示是基于MOS管的电学特性实现的]]
2. 总线架构：8/16/32 位总线宽度决定最大寻址范围
3. 内存映射：地址空间的十六进制表示特性
	- 例：0x20000000~0x2000FFFF 为 STM32F1 的 SRAM 区域

## 进制表示与转换

- 10 进制这样写：`123456789`，每位最大值为 9
- 16 进制这样写：`0x12ABCDEF`, 每位最大值为 15
	- A 表示 10
	- B 表示 11，C 表示 12，D 表示 13，E 表示 14，F 表示 15
- 8 进制这样写：`01234`，每位最大值为 7
- 2 进制这样写：`0b0110`，每位最大值为 1 (注意：**C89/C90 标准** 不支持 `0b` 二进制字面量)

# 封装寄存器

```c
/*
    lesson4: 封装寄存器
*/

int mian(void)
{
  volatile unsigned int *pGpiobOdr = (volatile unsigned int *)(0x40010c00 + 0x0c);
  
  /* 置 1 实验 */
  *pGpiobOdr |= (1<<7) | (1<<9);  // *pGpiobOdr = *pGpiobOdr | (1<<7) | (1<<9);
  
  /* 清 0 实验 */
  *pGpiobOdr &= ~((1<<7) | (1<<9));  // *pGpiobOdr = *pGpiobOdr & ~ ((1<<7) | (1<<9));
  
  return 0;
}
```

 `*pGpiobOdr` 指向了 GPIOB ODR，我们现在要做的就是修改 `*pGpiobOdr` 指向的内容

我们通过定义一个 [[16_结构、联合和枚举#结构变量|结构体]] 和 [[14_预处理器|预处理]] 来实现寄存器的封装

```c
/*
lesson4: 封装寄存器
*/

typedef struct 
{
  volatile unsigned int  CRL;
  volatile unsigned int  CRH;
  volatile unsigned int  IDR;
  volatile unsigned int  ODR;
  volatile unsigned int  BSRR;
  volatile unsigned int  BRR;
  volatile unsigned int  LCKR;
}GPIO_TypeDef;

#define GPIOA  ((GPIO_TypeDef *)  0x40010800)
#define GPIOB  ((GPIO_TypeDef *)  0x40010C00)
#define GPIOC  ((GPIO_TypeDef *)  0x40011000)

int main(void)
{
  GPIOB->ODR |= (1<<7) | (1<<9);

  return 0;
}

```

# [[CPU与外设]]