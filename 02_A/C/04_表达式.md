---
tags:
  - c
---
C 语言的一个特点就是它更多地强调表达式而不是语句。

# 算术表达式

- 一元运算符
	- `+`
	- `-`
- 二元运算符
	- 加法类
		- `+`
		- `-`
	- 乘法类
		- `*`
		- `/`
		- `%`

> [!NOTE] 
> 当运算符`/`和运算符`%`用于负操作数时，其结果难以确定。根据 C89 标准，如果两个操作数中有一个为负数，那么除法的结果既可以向上舍入也可以向下舍入。（例如， -9/7 的结果既可以是-1 也可以是-2。）在 C89 中，如果 i 或者 j 是负数，i%j 的符号与具体实现有关。（例如，-9%7 的值可能是-2 或者 5。） 但是在 C99 中，除法的结果总是趋零截尾的（因此-9/7 的结果是-1），i%j 的值的符号与 i 的相同（因此-9%7 的值是-2）。

> [!NOTE] “由实现定义”的行为
> 术语 **由实现定义（implementation-defined）** 出现频率很高，因此值得花些时间讨论一下。 C 标准故意对 C 语言的部分内容未加指定，并认为其细节可以由“实现”来具体定义。所谓实现是指程序在特定的平台上编译、链接和执行所需要的软件。因此，根据实现的不同，程序的行为可能会稍有差异。C89 中运算符 `/` 和运算符 `%` 对负操作数的行为就是一个由实现定义行为的例子。
> 留下语言的一部分内容未加指定，看起来可能有点奇怪，甚至很危险，但这正反映了 C 语言的基本理念。C 语言的目标之一是高效，这常常意味着要与硬件行为相匹配。-9 除以 7 时， 有些 CPU 产生的结果是-1，有些则是-2。C89 标准简单地反映了这一现实。
> 最好避免编写依赖于由实现定义的行为的程序。如果不可能做到，那么起码要仔细查阅手册——C 标准要求在文档中说明由实现定义的行为。

## 运算符的优先级和结合性

| 优先级 | 名称        | 符号                                 | 结合性  |
| :-- | :-------- | :--------------------------------- | :--- |
| 1   | 数组取下标     | `[]`                               | 左结合性 |
| 1   | 函数调用      | `()`                               | 左结合性 |
| 1   | 取结构和联合的成员 | `.` `→`                            | 左结合性 |
| 1   | 自增(后缀)    | `++`                               | 左结合性 |
| 1   | 自减(后缀)    | `--`                               | 左结合性 |
| 2   | 自增(前缀)    | `++`                               | 右结合性 |
| 2   | 自减(前缀)    | `--`                               | 右结合性 |
| 2   | 取地址       | &                                  | 右结合性 |
| 2   | 间接寻址      | *                                  | 右结合性 |
| 2   | 一元正号      | +                                  | 右结合性 |
| 2   | 一元负号      | -                                  | 右结合性 |
| 2   | 按位取反      | ~                                  | 右结合性 |
| 2   | 逻辑非       | !                                  | 右结合性 |
| 2   | 计算所需空间    | sizeof                             | 右结合性 |
| 3   | 强制类型转换    | ()                                 | 右结合性 |
| 4   | 乘法类运算符    | * / %                              | 左结合性 |
| 5   | 加法类运算符    | + -                                | 左结合性 |
| 6   | 移位        | << >>                              | 左结合性 |
| 7   | 关系        | < > <= >=                          | 左结合性 |
| 8   | 判等        | == !=                              | 左结合性 |
| 9   | 按位与       | &                                  | 左结合性 |
| 10  | 按位异或      | ^                                  | 左结合性 |
| 11  | 按位或       | \|                                 | 左结合性 |
| 12  | 逻辑与       | &&                                 | 左结合性 |
| 13  | 逻辑或       | \|\|                               | 左结合性 |
| 14  | 条件        | ? :                                | 右结合性 |
| 15  | 赋值        | = *= /= %= += -= <<= >>= &= ^= \|= | 右结合性 |
| 16  | 逗号        | ,                                  | 左结合性 |

## 程序：计算通用产品代码的校验位

为了读取单个的数字，我们使用带有 `%1d` 转换说明的 `scanf` 函数，其中 `%1d` 匹配只有 1 位的整数。

```c
printf("Enter the first (single) digit: ");
scanf("%1d", &d);
printf("Enter first group of five digits: "); scanf("%1d%1d%1d%1d%1d", &i1, &i2, &i3, &i4, &i5); printf("Enter second group of five digits: "); scanf("%1d%1d%1d%1d%1d", &j1, &j2, &j3, &j4, &j5);
```

# 赋值运算符

## 简单赋值

在许多编程语言中，赋值是语句；然而，在 C 语言中，赋值就像 `+` 那样是运算符。换句话说，赋值操作产生结果，就如同两个数相加产生结果一样。赋值表达式 `v = e` 的值就是赋值运算后 v 的值。

## 左值

大多数 C 语言运算符允许它们的操作数是变量、常量或者包含其他运算符的表达式。然而，**赋值运算符要求它的左操作数必须是左值（lvalue）** 。

左值表示对象，而不是常量或计算的结果。变量是左值，而诸如 10 或 2 * i 这样的表达式则不是左值。目前为止，变量是已知的唯一左值。在后面的章节中，我们将介绍其他类型的左值。

既然赋值运算符要求左操作数是左值，那么在赋值表达式的左侧放置任何其他类型的表达式都是不合法的，编译器会检测出这种错误，并给出 “invalid lvalue in assignment”这样的出错消息。

## 复合赋值

［其他复合赋值运算符（ 20.1 节）将在后面的章节中介绍。］所有复合赋值运算符的工作原理大体相同。

- `v += e` 表示 v 加上 e，然后将结果存储到 v 中。 
- `v -= e` 表示 v 减去 e，然后将结果存储到 v 中。
- `v *= e` 表示 v 乘以 e，然后将结果存储到 v 中。 
- `v /= e` 表示 v 除以 e，然后将结果存储到 v 中。 
- `v %= e` 表示 v 除以 e 取余数，然后将求余的结果存储到 v 中。

> [!tip] 
> 注意，这里没有说 `v += e` “等价于” `v = v + e`。问题在于运算符的优先级：表达式 `i *= j + k` 和表达式 `i = i * j + k` 是不一样的。在极少数情况下，由于 v 自身的副作用，`v += e` 也不等同于` v = v+ e`。类似的说明也适用于其他复合赋值运算符。

# 自增运算符和自减运算符

# 表达式求值

## 子表达式的求值顺序

C 语言没有定义子表达式的求值顺序［除了含有逻辑与运算符及逻辑或运算符（ 5.1 节）、条件运算符（ 5.2 节）以及逗号运算符（ 6.3 节）的子表达式］。因此，在表达式 `(a + b) * (c - d)` 中，无法确定子表达式 `(a + b)` 是否在子表达式 `(c – d)` 之前求值。

在下面的例子中，j 有两个可能的值：

```c
i = 2;
j = i * i++;
```

人们很自然地就会认定 j 赋值为 4。但是，该语句的执行效果是未定义的，j 也可能赋值为 6。

> [!NOTE] 未定义的行为
> 根据 C 标准，类似 `c = (b = a + 2) – (a = 1);` 和 `j = i * i++;` 这样的语句会导致“未定义的行为”（undefined behavior），这跟 [[04_表达式#算术表达式|4.1 节]] 中讲的由实现定义的行为是不同的。当程序中出现未定义的行为时，后果是不可预料的。不同的编译器给出的编译结果可能是不同的，但这还不是唯一可能发生的事情：首先程序可能无法通过编译，就算通过了编译也可能无法运行，就算可以运行也有可能崩溃、不稳定或者产生无意义的结果。换句话说，应该像躲避瘟疫一样避免未定义的行为。

# 表达式语句

C 语言有一条不同寻常的规则，那就是**任何表达式都可以用作语句**。换句话说，不论表达式是什么类型、计算什么结果，我们都可以通过在后面添加分号将其转换成语句。例如，可以把表达式 `++i` 转换成语句 `++i;`

> [!warning] 
> 键盘上的误操作很容易造成“什么也不做”的表达式语句。例如，本想输入 `i = j;` 但是错误地输入了 `i + j;` （因为=和+两个字符通常在键盘的同一个键上，所以这种错误发生的频率可能会超乎想象。）某些编译器可能会检查出无意义的表达式语句，会显示类似“statement with no effect”的警告。

# 问与答

> [!question] 当`/`运算符和`%`运算符的操作数是负数时，为什么规则那么复杂？
> 规则其实不像看起来那么复杂。C89 和 C99 都要确保 `(a / b) * b + a % b` 的结果总是等于 `a`（事实上，只要 `a / b` 的值是可表示的，C89 和 C99 标准就都能确保这一点）。问题在于 C89 中，`a / b` 和 `a % b` 有两种情况可满足这一相等性：`-9 / 7` 为 -1 且 -9 % 7 为 -2，或者-9 / 7 为 -2 且-9 % 7 为 5。
> 在第一种情况下，`(-9 / 7) * 7 + -9 % 7` 的值为 -1 × 7 + -2 = -9；在第二种情况下，(-9 / 7) * 7 + -9 % 7 的值为 -2 × 7 + 5 = -9。
> C99 出现的时候，大多数 CPU 都将除法的结果趋零截尾， 所以这也被写入这一标准作为唯一允许的结果

> [!question] 如果 C 语言有左值，那它也有右值吗？
> 是的，当然。不过在 C 语言里不叫右值，C 语言中的“值”就是“右值”，都是指“表达式的值”。只有左值才可能放在赋值运算符的左侧，否则它就是一个值，或者说右值。当然，C 语言不需要“右值”这个概念，C 标准也不使用这个概念，这是其他语言，比如 C++才使用的概念。

> [!question] 前面提到：如果 `v` 有副作用，那么 `v += e` 不等价于 `v = v + e`。可以解释一下吗？
> 计算 `v += e` 只会求一次 v 的值，而计算 `v = v + e` 会求两次 `v` 的值。在后一种情况下，对 `v` 求值可能引起的任何副作用也都会出现两次。在下面的例子中，`i` 只自增一次：
> `a[i++] += 2;` 
> 如果用 `=` 代替 `+=`，语句变成
> `a[i++] = a[i++] + 2;` 
> `i` 的值在别处被修改和使用了，因此上述语句的结果是未定义的。i 的值可能会自增两次，但我们无法确定到底会发生什么。

> [!question] C 语言为什么提供`++`和`--`运算符？它们是比其他的自增、自减方法执行得快，还是仅仅更便捷？
> C 语言从 Ken Thompson 早期的 B 语言中继承了`++`和`--`。Thompson 创造这类运算符是因为他的 B 语言编译器可以对`++`i 产生比` i = i + 1` 更简洁的翻译。这些运算符已经成为 C 语言根深蒂固的组成部分（事实上，许多最著名的 C 语言惯用法都依赖于这些运算符）。对于现代编译器而言，使用`++` 和`--`不会使编译后的程序变得更短小或更快，继续普及这些运算符主要是由于它们的简洁和便利。

> [!question] 在使用后缀形式的`++`或`--`时，何时执行自增或自减操作？
> 这是一个非常好的问题，也是一个非常难回答的问题。C 语言标准引入了“序列点”的概念，并且指出“应该在前一个序列点和后一个序列点之间对存储的操作数的值进行更新”。在 C 语言中有多种不同类型的序列点，表达式语句的末尾是其中一种。在表达式语句的末尾，该语句中的所有自增和自减操作都必须执行完毕，否则不能执行下一条语句。
> 在后面章节中会遇到的一些运算符（逻辑与、逻辑或、条件和逗号）对序列点也有影响。函数调用也是如此：在函数调用执行之前，所有的实际参数必须全部计算出来。如果实际参数恰巧是含有`++` 或`--`运算符的表达式，那么必须在调用前进行自增或自减操作。
