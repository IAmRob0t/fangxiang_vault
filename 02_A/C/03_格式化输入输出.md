---
tags:
  - c
aliases:
  - 03_格式化输入/输出
---
# `printf` 函数

`printf` 函数被设计用来显示 **格式串（format string）** 的内容，并且在该串中的指定位置插入可能的值。

格式串包含普通字符和转换说明（conversion specification），其中转换说明以字符 `%`  开头。转换说明是用来表示打印过程中待填充的值的占位符。跟随在字符 `%` 后边的信息指定了把数值从内部形式（二进制）转换成打印形式（字符）的方法，这就是“转换说明”这一术语的由来。

> [!warning] 
> C语言编译器不会检测格式串中转换说明的数量是否和输出项的数量相匹配。
> 此外，C语言编译器也不检测转换说明是否适合要显示项的数据类型。

## 转换说明

转换说明可以用 `%m.pX`  格式或 `%-m.pX` 格式，这里的 `m` 和 `p` 都是整型常量，而 `X` 是字母。`m` 和 `p` 都是可选的。如果省略 `p`，`m` 和 `p` 之间的小数点也要去掉。在转换说明 `%10.2f` 中，`m` 是10，`p` 是2，而 `X` 是 `f`。在转换说明 `%10f` 中，`m` 是10，`p`（连同小数点一起）省去了；而在转换说明 `%.2f` 中，`p` 是2，`m` 省去了。

**最小栏宽**（minimum field width）`m` 指定了要显示的最少字符数量。如果要显示的数值所需的字符数少于 `m`，那么值在字段内是右对齐的。（换句话说，在值前面放置额外的空格。）例如，转换说明 `%4d` 将以 `·123` 的形式显示数 `123`（本章用符号 `·` 表示空格字符）。如果要显示的值所需的字符数多于 `m`，那么栏宽会自动扩展为所需的尺寸。因此，转换说明 `%4d` 将以 `12345` 的形式显示数 `12345`，而不会丢失数字。在 `m` 前放上一个负号会导致左对齐；转换说明 `%-4d` 将以 `123·` 的形式显示 `123`。

**精度**（precision）`p` 的含义很难描述，因为它依赖于转换指定符（conversion specifier）`X` 的选择。`X` 表明在显示数值前需要对其进行哪种转换。对数值来说最常用的转换指定符有以下几个。
- `d` —— 表示十进制（基数为10）形式的整数。 $p$ 指明了待显示的数字的最少个数（必要时在数前加上额外的零）​；如果省略 $p$ ，则默认它的值为1。
- `e` —— 表示指数（科学记数法）形式的浮点数。 $p$ 指明了小数点后应该出现的数字的个数（默认值为6）​。如果 $p$ 为0，则不显示小数点。
- `f` —— 表示“定点十进制”形式的浮点数，没有指数。$p$ 的含义与在说明符 `e` 中的一样。
- `g` —— 表示指数形式或者定点十进制形式的浮点数，形式的选择根据数的大小决定。$p$ 说明可以显示的有效数字（没有小数点后的数字）的最大数量。与转换说明符f不同，g的转换将不显示尾随的零。此外，如果要显示的数值没有小数点后的数字，g就不会显示小数点。

编写程序时无法预知数的大小或者数值变化范围很大的情况下，说明符 `g` 对于数的显示是特别有用的。在用于显示大小适中的数时，说明符 `g` 采用定点十进制形式。但是，在显示非常大或非常小的数时，说明符 `g` 会转换成指数形式以便减少所需的字符数。

## 转义序列

转义序列（ 7.3 节）使字符串包含一些特殊字符而不会使编译器引发问题，这些字符包括非打印的（控制）字符和对编译器有特殊含义的字符（如"）。

# `scanf` 函数


> [!warning] 
> 如果 `scanf` 函数调用中忘记在变量前面放置符号`&`，将产生不可预知甚至可能是毁灭性的结果。程序崩溃是常见的结果。最轻微的后果则是从输入读进来的值无法存储到变量中，变量将保留原有的值（如果没有给变量赋初始值，那么这个原有值可能是没有意义的）。忽略符号`&`是极为常见的错误，一定要小心！一些编译器可以检查出这种错误，并产生一条类似“format argument is not a pointer”的警告消息。（术语指针将在第 11 章定义，符号`&`用于创建一个指向变量的指针。）如果抛出警告消息， 检查一下是否遗漏了符号`&`。

调用 `scanf` 函数是读数据的一种有效但不理想的方法。许多专业的 C 程序员会避免使用 `scanf` 函数，而是采用字符格式读取所有数据，然后再把它们转换成数值形式。

## `scanf` 函数的工作方法

`scanf` 函数本质上是一种“模式匹配”函数，试图把输入的字符组与转换说明相匹配。

调用时，`scanf` 函数从左边开始处理字符串中的信息。对于格式串中的每一个转换说明，`scanf` 函数从输入的数据中定位适当类型的项，并在必要时跳过空格。然后，`scanf` 函数读入数据项，并且在遇到不可能属于此项的字符时停止。如果读入数据项成功，那么 `scanf` 函数会继续处理格式串的剩余部分；如果某一项不能成功读入，那么 `scanf` 函数将不再查看格式串的剩余部分（或者余下的输入数据），并立即返回。

## 格式串中的普通字符

通过编写含有普通字符和转换说明的格式串能进一步地理解模式匹配的概念。处理格式串中的普通字符时，`scanf` 函数采取的动作依赖于这个字符是否为空白字符。
- 空白字符。当在格式串中遇到一个或多个连续的空白字符时，`scanf` 函数从输入中重复读空白字符，直到遇到一个非空白字符（把该字符“放回原处”）为止。格式串中空白字符的数量无关紧要，格式串中的一个空白字符可以与输入中任意数量的空白字符相匹配。（附带提一下，在格式串中包含空白字符并不意味着输入中必须包含空白字符。格式串中的一个空白字符可以与输入中任意数量的空白字符相匹配，包括零个。）
- 其他字符。当在格式串中遇到非空白字符时，`scanf` 函数将把它与下一个输入字符进行比较。如果两个字符相匹配，那么 `scanf` 函数会放弃输入字符，并继续处理格式串。如果两个字符不匹配，那么 `scanf` 函数会把不匹配的字符放回输入中，然后异常退出，而不进一步处理格式串或者从输入中读取字符。

## 易混淆的 `printf` 函数和 `scanf` 函数

# 问与答

> [!question] 转换说明 `%i` 也可以用于读写整数。`%i` 和 `%d` 之间有什么区别？
> 在 `printf` 格式串中使用时，二者没有区别。但是，在 `scanf` 格式串中，`%d` 只能与十进制（基数为 10）形式的整数相匹配，而 `%i` 则可以匹配用八进制（基数为 8）、十进制或十六进制（基数为 16） 表示的整数。如果输入的数有前缀 0（如 056），那么 `%i` 会把它作为八进制数（ 7.1 节）来处理；如果输入的数有前缀 0x 或 0X（如 0x56），那么 `%i` 会把它作为十六进制数（ 7.1 节）来处理。如果用户意外地将 0 放在数的开始处，那么用 `%i` 代替 `%d` 读取数可能有意想不到的结果。因为这是一个陷阱，所以建议坚持采用 `%d`。

> [!question] 如果 `printf` 函数将 `%` 作为转换说明的开始，那么如何显示字符 `%` 呢？
> 如果 `printf` 函数在格式串中遇到两个连续的字符 `%`，那么它将显示出一个字符 `%`。例如，语句
> ```c
> printf("Net profit: %d%%\n", profit);
> ```
> 可以显示出
> ```c
> Net profit: 10%
> ```

> [!question] 我不能理解 `scanf` 函数如何把字符“放回原处”并在以后再次读取。
> 我们知道，用户从键盘输入时，程序并没有读取输入，而是把用户的输入放在一个隐藏的缓冲区中， 由 `scanf` 函数来读取。`scanf` 函数把字符放回到缓冲区中供后续读取是非常容易的。第 22 章会更详细地讨论输入缓冲。

# 练习题

下面的 `printf` 函数调用产生的输出是什么？

```c
printf("%-6.2g", .0000009979);
```

`1e-006 `
`“%-6.2g”` 表示左对齐、最小6个字段宽，.2表示可以显示最大2个（去掉小数点后）有效数字。之所以显示1e是因为数字9979只能显示99这两个有效数字，所有后面的7会四舍五入向前进位，这样实际要显示的 数字就从.0000009979变成了.0000010000，所以结果显示为1e，如果将.2变为.3的话就会显示为9.98e-007。在 `%f` 和 `%e` 当中，如果需要舍弃小数点后部分数字，同样会使用这种四舍五入的显示方式。

---

