{
	"nodes":[
		{"id":"f0f9fbc3f9946af9","type":"text","text":"```mermaid\nflowchart TD\n    StartSend[开始：写队列] --> LoopSend[尝试写入]\n\n    LoopSend --> EnterCriticalSend[关中断 进入关键区]\n\n    EnterCriticalSend --> HasSpace{队列有空间？}\n\n    HasSpace -- 是 --> CopySend[复制数据并添加 （当前任务保持在 Ready lists）]\n    CopySend --> WakeRecv[唤醒等待接收的任务 （被唤醒任务：Delayed lists → Ready lists 或 Pending ready list，如果调度器挂起） （如果返回 pdTRUE 且使用抢占，则 yield）]\n    WakeRecv --> ExitCriticalSend1[开中断 退出关键区]\n    ExitCriticalSend1 --> SuccessSend[返回成功 （当前任务保持在 Ready lists）]\n\n    HasSpace -- 否 --> TimeoutSend{超时为0或已过期？（不阻塞）}\n    TimeoutSend -- 是 --> ExitCriticalSend2[开中断 退出关键区]\n    ExitCriticalSend2 --> ErrorSend[返回错误 （当前任务保持在 Ready lists）]\n\n    TimeoutSend -- 否 --> SuspendSend[挂起调度器]\n    SuspendSend --> LockSend[锁定队列]\n    LockSend --> CheckTimeoutSend{超时过期？}\n    CheckTimeoutSend -- 是 --> UnlockSend1[解锁队列]\n    UnlockSend1 --> ResumeSend1[恢复调度器 （处理 Pending ready list → Ready lists，如果有）]\n    ResumeSend1 --> CheckFull{仍满？}\n    CheckFull -- 是 --> ErrorSend2[返回错误 （当前任务保持在 Ready lists）]\n    CheckFull -- 否 --> LoopSend2[重试写入 （当前任务在 Ready lists）]\n\n    CheckTimeoutSend -- 否 --> CheckQueueFull{队列满？}\n    CheckQueueFull -- 否 --> UnlockSend2[解锁队列]\n    UnlockSend2 --> ResumeSend3[恢复调度器 （处理 Pending ready list → Ready lists，如果有）]\n    ResumeSend3 --> LoopSend4[重试写入 （当前任务在 Ready lists）]\n\n    CheckQueueFull -- 是 --> BlockSend[任务阻塞到等待列表 （当前任务：Ready lists → Delayed lists）]\n    BlockSend --> UnlockSend3[解锁队列]\n    UnlockSend3 --> ResumeSend2[恢复调度器 （处理 Pending ready list → Ready lists，如果有） （如果返回 pdFALSE，则 yield）]\n    ResumeSend2 --> WakeSend[被唤醒时 （当前任务：Delayed lists → Ready lists 或 Pending ready list，如果调度器挂起）]\n    WakeSend --> LoopSend3[重试写入 （当前任务在 Ready lists）]\n```","x":-960,"y":1360,"width":1360,"height":2500},
		{"id":"71cd66eb99d6068d","type":"text","text":"```mermaid\nflowchart TD\n    Start[开始：读队列] --> Loop[尝试读取]\n\n    Loop --> EnterCritical[关中断 进入关键区]\n\n    EnterCritical --> HasData{队列有数据？}\n\n    HasData -- 是 --> Copy[复制数据并移除 （当前任务保持在 Ready lists）]\n    Copy --> WakeSend[唤醒等待发送的任务 （被唤醒任务：Delayed lists → Ready lists 或 Pending ready list，如果调度器挂起） （如果返回 pdTRUE 且使用抢占，则 yield）]\n    WakeSend --> ExitCritical1[开中断 退出关键区]\n    ExitCritical1 --> Success[返回成功 （当前任务保持在 Ready lists）]\n\n    HasData -- 否 --> Timeout{超时为0或已过期？（不阻塞）}\n    Timeout -- 是 --> ExitCritical2[开中断 退出关键区]\n    ExitCritical2 --> Error[返回错误 （当前任务保持在 Ready lists）]\n\n    Timeout -- 否 --> Suspend[挂起调度器]\n    Suspend --> Lock[锁定队列]\n    Lock --> CheckTimeout{超时过期？}\n    CheckTimeout -- 是 --> Unlock1[解锁队列]\n    Unlock1 --> Resume1[恢复调度器 （处理 Pending ready list → Ready lists，如果有）]\n    Resume1 --> CheckEmpty{仍空？}\n    CheckEmpty -- 是 --> Error2[返回错误 （当前任务保持在 Ready lists）]\n    CheckEmpty -- 否 --> Loop2[重试读取 （当前任务在 Ready lists）]\n\n    CheckTimeout -- 否 --> CheckQueueEmpty{队列空？}\n    CheckQueueEmpty -- 否 --> Unlock2[解锁队列]\n    Unlock2 --> Resume3[恢复调度器 （处理 Pending ready list → Ready lists，如果有）]\n    Resume3 --> Loop4[重试读取 （当前任务在 Ready lists）]\n\n    CheckQueueEmpty -- 是 --> Block[任务阻塞到等待列表 （当前任务：Ready lists → Delayed lists）]\n    Block --> Unlock3[解锁队列]\n    Unlock3 --> Resume2[恢复调度器 （处理 Pending ready list → Ready lists，如果有） （如果返回 pdFALSE，则 yield）]\n    Resume2 --> Wake[被唤醒时 （当前任务：Delayed lists → Ready lists 或 Pending ready list，如果调度器挂起）]\n    Wake --> Loop3[重试读取 （当前任务在 Ready lists）]\n```","x":-2140,"y":1960,"width":1360,"height":2500}
	],
	"edges":[]
}