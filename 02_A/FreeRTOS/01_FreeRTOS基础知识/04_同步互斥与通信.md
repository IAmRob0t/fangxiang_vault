---
tags:
  - freeRTOS
---
可以把多任务系统当做一个团队，里面的每一个任务就相当于团队里的一个人。团队成员之间要协调工作进度(同步)、争用会议室(互斥)、沟通(通信)。多任务系统中所涉及的概念，都可以在现实生活中找到例子。

各类 RTOS 都会涉及这些概念：
- 任务通知(task notification)
- 队列(queue)
- 事件组(event group)
- 信号量(semaphoe)
- 互斥量(mutex)等。

我们先站在更高角度来讲解这些概念。

# 同步与互斥的概念

对应程序：`12_freertos_example_sync_exclusion `，基于 `05_freertos_example_createtask` 修改。

**同步就是“我等你”，​**​ 就像约好一起出发，一个任务做完某件事后，通知另一个任务可以开始了；​**​互斥就是“我用时你别碰”，​**​ 就像只有一个厕所，一个人进去后会把门锁上，用完出来另一个人才能用，防止同时使用造成混乱。

# 同步与互斥并不简单



# 各类方法的对比

![[FreeRTOS完全开发手册之上册_快速入门.pdf#page=68&rect=77,169,518,544|FreeRTOS完全开发手册之上册_快速入门, p.68]]

![[FreeRTOS完全开发手册之上册_快速入门.pdf#page=69&rect=65,55,524,574|FreeRTOS完全开发手册之上册_快速入门, p.69]]

## 同步的例子：有缺陷

- 效率降低​​：一个任务必须停下所有工作，空转 CPU，干等着另一个任务给它“信号”，这浪费了宝贵的 CPU 时间。
- ​系统卡死（死锁）​​：如果那个你等待的任务因为某种原因（比如它也在等别人）永远发不出信号，那你就会永远等下去，整个系统就“卡死”了。

## 互斥的例子：有缺陷

```c
void TaskGenericFunction(void * param)
{
	while (1)
	{
		if (!flagUARTused)
		{
			flagUARTused = 1;
			printf("%s\r\n", (char *)param);
			flagUARTused = 0;
			vTaskDelay(1);
		}
	}
}
```

想象一下：两个人（任务）同时跑到厕所门口，都看见门没锁（`flagUARTused == 0`），于是都冲进去（同时设置 `flagUARTused = 1`），结果挤在厕所里打架（`printf` 输出乱套了）！

## 通信的例子：有缺陷

**通信就像“寄快递”​**​，它虽然能让任务之间传递消息，但也带来三个麻烦：

1. 费钱（占内存）​​：每个“快递柜”（队列、邮箱）都要占用系统宝贵的内存空间，柜子越多越占地方。
2. 可能堵车（延迟）​​：快递员（通信机制）送信需要时间，如果任务急需对方回复，就只能干等着（阻塞），耽误干活。
3. 柜子可能满/丢件（不可靠风险）​​：如果快递柜满了（队列满），你的消息就寄不出去（任务可能被卡住）；更糟的是，万一系统出错（崩溃），消息可能就丢了（数据不一致）。

## FreeRTOS 的解决方案

* 正确性
* 效率：等待者要进入阻塞状态
* 多种解决方案（多种内核对象）