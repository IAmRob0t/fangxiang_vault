---
tags:
  - freeRTOS
---
# 调试

FreeRTOS 提供了很多调试手段：
* [[#打印]]
* [[#断言]]：`configASSERT  `
* [[#Trace]]
* [[#Malloc Hook 函数]] (回调函数)

## 打印

`printf`： FreeRTOS 工程里使用了 `microlib`（“链接的时候，别用默认的大而全的 C 库，用 ARM 专门做的‘微库’—— `microlib`。”），里面实现了 `printf` 函数：

![[microlib.png|692]]

我们只需实现一下函数即可使用 printf：

```c
int fputc( int ch, FILE *f );
```

## 断言

一般的 C 库里面，断言就是一个函数：

```c
void assert(scalar expression);
```

它的作用是：确认 `expression` 必须为真，如果 `expression` 为假的话就中止程序。

---

在 FreeRTOS 里，使用 `configASSERT()`，比如：

```c
#define configASSERT(x)  if (!x) while(1);
```

我们可以让它提供更多信息，比如：

```c
#define configASSERT(x)  \
				if (!x) \
				{
					printf("%s %s %d\r\n", __FILE__, __FUNCTION__, __LINE__); \
					while(1); \
				}
```

`configASSERT (x)` 中，如果 x 为假，表示发生了很严重的错误，必须停止系统的运行。

它用在很多场合，比如：

* 队列操作

  ```c
  BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                                const void * const pvItemToQueue,
                                TickType_t xTicksToWait,
                                const BaseType_t xCopyPosition )
  {
      BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
      TimeOut_t xTimeOut;
      Queue_t * const pxQueue = xQueue;
  
      configASSERT( pxQueue );
      configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
      configASSERT( !((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1 )));
  ```

* 中断级别的判断

  ```c
	void vPortValidateInterruptPriority( void )
	{
  	uint32_t ulCurrentInterrupt;
  	uint8_t ucCurrentPriority;
  
  	/* Obtain the number of the currently executing interrupt. */
  	ulCurrentInterrupt = vPortGetIPSR();
  
  	/* Is the interrupt number a user defined interrupt? */
  	if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
  	{
  		/* Look up the interrupt's priority. */
  		ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
  
  		configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
  	}
  ```

## Trace

FreeRTOS 中定义了很多 trace 开头的宏，这些宏被放在系统个关键位置。

它们一般都是空的宏，这不会影响代码：不影响编程处理的程序大小、不影响运行时间。

我们要调试某些功能时，可以修改宏：修改某些标记变量、打印信息等待。

| trace 宏                                      | 描述                                                                                                                                          |
| -------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |
| `traceTASK_INCREMENT_TICK (xTickCount)`        | 当 tick 计数自增之前此宏函数被调用。参数 xTickCount 当前的 Tick 值，它还没有增加。                                                                                       |
| `traceTASK_SWITCHED_OUT ()`                    | vTaskSwitchContext 中，把当前任务切换出去之前调用此宏函数。                                                                                                     |
| `traceTASK_SWITCHED_IN ()`                     | vTaskSwitchContext 中，新的任务已经被切换进来了，就调用此函数。                                                                                                   |
| `traceBLOCKING_ON_QUEUE_RECEIVE (pxQueue)`     | 当正在执行的当前任务因为试图去读取一个空的队列、信号或者互斥量而进入阻塞状态时，此函数会被立即调用。参数 pxQueue 保存的是试图读取的目标队列、信号或者互斥量的句柄，传递给此宏函数。                                              |
| `traceBLOCKING_ON_QUEUE_SEND (pxQueue)`        | 当正在执行的当前任务因为试图往一个已经写满的队列或者信号或者互斥量而进入了阻塞状态时，此函数会被立即调用。参数 pxQueue 保存的是试图写入的目标队列、信号或者互斥量的句柄，传递给此宏函数。                                           |
| `traceQUEUE_SEND (pxQueue)`                    | 当一个队列或者信号发送成功时，此宏函数会在内核函数 xQueueSend (), xQueueSendToFront (), xQueueSendToBack (), 以及所有的信号 give 函数中被调用，参数 pxQueue 是要发送的目标队列或信号的句柄，传递给此宏函数。 |
| `traceQUEUE_SEND_FAILED (pxQueue)`             | 当一个队列或者信号发送失败时，此宏函数会在内核函数 xQueueSend (), xQueueSendToFront (), xQueueSendToBack (), 以及所有的信号 give 函数中被调用，参数 pxQueue 是要发送的目标队列或信号的句柄，传递给此宏函数。 |
| `traceQUEUE_RECEIVE (pxQueue)`                 | 当读取一个队列或者接收信号成功时，此宏函数会在内核函数 xQueueReceive () 以及所有的信号 take 函数中被调用，参数 pxQueue 是要接收的目标队列或信号的句柄，传递给此宏函数。                                        |
| `traceQUEUE_RECEIVE_FAILED (pxQueue)`          | 当读取一个队列或者接收信号失败时，此宏函数会在内核函数 xQueueReceive () 以及所有的信号 take 函数中被调用，参数 pxQueue 是要接收的目标队列或信号的句柄，传递给此宏函数。                                        |
| `traceQUEUE_SEND_FROM_ISR (pxQueue)`           | 当在中断中发送一个队列成功时，此函数会在 xQueueSendFromISR () 中被调用。参数 pxQueue 是要发送的目标队列的句柄。                                                                     |
| `traceQUEUE_SEND_FROM_ISR_FAILED (pxQueue)`    | 当在中断中发送一个队列失败时，此函数会在 xQueueSendFromISR () 中被调用。参数 pxQueue 是要发送的目标队列的句柄。                                                                     |
| `traceQUEUE_RECEIVE_FROM_ISR (pxQueue)`        | 当在中断中读取一个队列成功时，此函数会在 xQueueReceiveFromISR () 中被调用。参数 pxQueue 是要发送的目标队列的句柄。                                                                  |
| `traceQUEUE_RECEIVE_FROM_ISR_FAILED (pxQueue)` | 当在中断中读取一个队列失败时，此函数会在 xQueueReceiveFromISR () 中被调用。参数 pxQueue 是要发送的目标队列的句柄。                                                                  |
| `traceTASK_DELAY_UNTIL ()`                     | 当一个任务因为调用了 vTaskDelayUntil () 进入了阻塞状态的前一刻此宏函数会在 vTaskDelayUntil () 中被立即调用。                                                                  |
| `traceTASK_DELAY ()`                           | 当一个任务因为调用了 vTaskDelay () 进入了阻塞状态的前一刻此宏函数会在 vTaskDelay 中被立即调用。                                                                               |

## Malloc Hook 函数

编程时，一般的逻辑错误都容易解决。难以处理的是内存越界、栈溢出等。

内存越界经常发生在堆的使用过程中：堆，就是使用 malloc 得到的内存。

并没有很好的方法检测内存越界，但是可以提供一些回调函数：

* 使用 `pvPortMalloc` 失败时，如果在 `FreeRTOSConfig.h` 里配置 `configUSE_MALLOC_FAILED_HOOK` 为 1，会调用：

  ```c
  void vApplicationMallocFailedHook( void );
  ```

## 栈溢出 Hook 函数

![[16_调试与优化.tif]]

在切换任务 (`vTaskSwitchContext`) 时调用 `taskCHECK_FOR_STACK_OVERFLOW` 来检测栈是否溢出，如果溢出会调用：

```c
void vApplicationStackOverflowHook( TaskHandle_t xTask, char * pcTaskName );
```

怎么判断栈溢出？有两种方法：

* 方法 1：
	* 当前任务被切换出去之前，它的整个运行现场都被保存在栈里，这时**很可能**就是它对栈的使用到达了峰值。
	* 这方法很高效，但是并不精确
	* 比如：任务在运行过程中调用了函数 A 大量地使用了栈，调用完函数 A 后才被调度。
	* ![[01_stack_overflow_1.png]]

* 方法 2：
	* 创建任务时，它的栈被填入固定的值，比如：0xa5
	* 检测栈里最后 16 字节的数据，如果不是 0xa5 的话表示栈即将、或者已经被用完了
	* 没有方法 1 快速，但是也足够快
	* 能捕获**几乎所有**的栈溢出
	* 为什么是几乎所有？可能有些函数使用栈时，非常凑巧地把栈设置为 0xa5：几乎不可能
	* ![[02_stack_overflow_2.png]]

# 优化

在 Windows 中，当系统卡顿时我们可以查看任务管理器找到最消耗 CPU 资源的程序。

在 FreeRTOS 中，我们也可以查看任务使用 CPU 的情况、使用栈的情况，然后针对性地进行优化。

这就是查看"任务的统计"信息。

## 栈使用情况

在创建任务时分配了栈，可以填入固定的数值比如 0xa5，以后可以使用以下函数查看"栈的高水位"，也就是还有多少空余的栈空间：

```c
UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );
```

原理是：从栈底往栈顶逐个字节地判断，它们的值持续是 0xa5 就表示它是空闲的。

函数说明：

| 参数/返回值 | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| xTask       | 哪个任务                                                     |
| 返回值      | 任务运行时、任务被切换时，都会用到栈。栈里原来值 (0xa5) 就会被覆盖。<br />逐个函数从栈的尾部判断栈的值连续为 0xa5 的个数，<br />它就是任务运行过程中空闲内存容量的最小值。<br />注意：假设从栈尾开始连续为 0xa5 的栈空间是 N 字节，返回值是 N/4。 |

## 任务运行时间统计

对于同优先级的任务，它们按照时间片轮流运行：你执行一个 Tick，我执行一个 Tick。

是否可以在 Tick 中断函数中，统计当前任务的累计运行时间？

不行！很不精确，因为有更高优先级的任务就绪时，当前任务还没运行一个完整的 Tick 就被抢占了。

我们需要比 Tick 更快的时钟，比如 Tick 周期时 1ms，我们可以使用另一个定时器，让它发生中断的周期时 0.1ms 甚至更短。

使用这个定时器来衡量一个任务的运行时间，原理如下图所示：

![[03_task_statistics.png]]

* 切换到 Task1 时，使用更快的定时器记录当前时间 T1
* Task1 被切换出去时，使用更快的定时器记录当前时间 T4
* (T4-T1) 就是它运行的时间，累加起来
* 关键点：在 `vTaskSwitchContext` 函数中，使用**更快的定时器**统计运行时间

## 涉及的代码

* 配置宏

  ```c
  #define configGENERATE_RUN_TIME_STATS 1
  #define configUSE_TRACE_FACILITY    1
  #define configUSE_STATS_FORMATTING_FUNCTIONS  1
  ```

* 实现宏 `portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()`，它用来初始化更快的定时器
* 实现这两个宏之一，它们用来返回当前时钟值 (更快的定时器)
	* `portGET_RUN_TIME_COUNTER_VALUE()` ：直接返回时钟值
	* `portALT_GET_RUN_TIME_COUNTER_VALUE(Time)` ：设置 Time 变量等于时钟值

代码执行流程：
* 初始化更快的定时器：启动调度器时
  ![[04_init_timer.png]]
* 在任务切换时统计运行时间
  ![[05_cal_runtime.png|419]]
* 获得统计信息，可以使用下列函数
	* `uxTaskGetSystemState`：对于每个任务它的统计信息都放在一个 TaskStatus_t 结构体里
	* `vTaskList`：得到的信息是可读的字符串，比如
	* `vTaskGetRunTimeStats`：  得到的信息是可读的字符串，比如

## 函数说明

* `uxTaskGetSystemState`：获得任务的统计信息

```c
UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray,
                                        const UBaseType_t uxArraySize,
                                        uint32_t * const pulTotalRunTime );
```

| 参数                | 描述                                                                                                  |
| ----------------- | --------------------------------------------------------------------------------------------------- |
| `pxTaskStatusArray` | 指向一个 TaskStatus_t 结构体数组，用来保存任务的统计信息。<br />有多少个任务？可以用 `uxTaskGetNumberOfTasks()` 来获得。                |
| `uxArraySize`       | 数组大小、数组项个数，必须大于或等于 `uxTaskGetNumberOfTasks()`                                                       |
| `pulTotalRunTime`   | 用来保存当前总的运行时间 (更快的定时器)，可以传入 NULL                                                                     |
| 返回值               | 传入的 pxTaskStatusArray 数组，被设置了几个数组项。<br />注意：如果传入的 uxArraySize 小于 `uxTaskGetNumberOfTasks()`，返回值就是 0 |

* vTaskList ：获得任务的统计信息，形式为可读的字符串。注意，pcWriteBuffer 必须足够大。

```c
  void vTaskList( signed char *pcWriteBuffer );
```

可读信息格式如下：

![[06_task_list.png]]

* vTaskGetRunTimeStats：获得任务的运行信息，形式为可读的字符串。注意，pcWriteBuffer 必须足够大。

```c
void vTaskGetRunTimeStats( signed char *pcWriteBuffer );
```

  可读信息格式如下：

![[07_task_runtimestats.png]]

## 上机实验

本节视频源码为：`28_freertos_example_stats`