---
tags:
  - freeRTOS
---
# 基本概念

## RTOS 的概念

RTOS 的意思是：Real-time operating system，**实时操作系统**。

我们使用的 Windows 也是操作系统，被称为**通用操作系统**。使用 Windows 时，我们经常碰到程序卡死、停顿的现象，日常生活中这可以忍受。

但是在电梯系统中，你按住开门键时如果没有即刻反应，即使只是慢个 1 秒，也会夹住人。

在专用的电子设备中，“实时性”很重要。

---

```c
// RTOS程序
taskA()
{
	while (1)
	{
		...;
	}
}
```

```c
taskB()
{
	while (1)
	{
		...;
	}
}
```

```c
void main()
{
	create_task(taskA);
	create_task(taskB);
	start_scheduler();
	while (1)
}
```

## 架构的概念

在电子系统中，CPU 就是大脑，CPU 有很多种类别，被称为架构。

常见的有：
* ARM：
	- 目前主流的架构，用得最广，芯片公司需要付费购买，再搭配各种模块才能设计出芯片。
	- 目前华为被美国制裁，无法获得最新的 ARM 架构；
	- 对于其他公司，购买 ARM 新架构的价格也不低。
* RISC-V：
	* 后起之秀，开源、免费。
	* 目前华为海思的 HI3861、乐鑫的 ESP32-C3 等芯片，都是使用 RISC-V 的单片机芯片；
	* 平头哥和全志的 D1 芯片，是使用 RISC-V 的、能运行 Linux 的芯片；
	* RISC-V 作为全新的架构，没有历史包袱，设计优美，在技术上大有可为，另外它开源无需授权，能摆脱技术的卡脖子问题。

---

如果只是使用别人移植好的 RTOS 来写程序，当然不需要了解 CPU 架构。

甚至编写驱动程序时，也不需要了解 CPU 架构：因为我们操作的是 CPU 之外的设备，不是操作 CPU。

但是，如果你想达到如下目标，就需要先了解 CPU 架构：
* 深入理解 RTOS 的内部实现
* 移植 RTOS
* 解决疑难问题

# 任务创建与删除

## 什么是任务

> [!question] 在 FreeRTOS 中，任务是什么？
> 任务（Task）可以理解为一个由内核调度、独立运行的函数（代码通常存储在 Flash 中，运行时使用 RAM 的栈空间）。

要注意的是：
- 任务函数通常应包含一个无限循环，否则退出后任务会自动被删除。
- 同一个函数，可以用来创建多个任务；换句话说，多个任务可以运行同一个函数
- 函数内部，尽量使用局部变量：
	- 每个任务有独立的栈空间
	- 每个任务运行这个函数时
		- 局部变量存放在该任务的栈上；
		- 不同任务调用同一个函数时，它们的局部变量存放在各自的栈帧中，互不干扰。
	- 函数使用全局变量、静态变量的话
		- 全局变量和静态变量在整个系统里只有一份存储空间，所有任务共享；
		- 多任务同时访问时，需要考虑互斥或同步。(后续会讲)

下面是一个示例：

```c
void ATaskFunction (void *pvParameters)
{
	/* 对于不同的任务，局部变量放在任务的栈里，有各自的副本 */
	int32_t lVariableExample = 0;

	/* 任务函数通常实现为一个无限循环 */
	for( ;; ) {
		/* 任务的代码 */
	}

	/* 如果程序从循环中退出，一定要使用vTaskDelete删除自己
	 * NULL表示删除的是自己
	 */
	vTaskDelete( NULL );
	
	/* 程序不会执行到这里, 如果执行到这里就出错了 */ }
```

## 创建任务

创建任务时使用的函数如下：

![[FreeRTOS完全开发手册之上册_快速入门.pdf#page=36&rect=76,693,518,814|FreeRTOS完全开发手册之上册_快速入门, p.36]]

( [[FreeRTOS完全开发手册之上册_快速入门.pdf#page=36&selection=90,0,90,5&color=note|📖]])
参数说明：

## 参数详解

`xTaskCreat ()` 的内部实现：
- 分配并初始化 TCB 结构体
	- 包含任务名、优先级、状态、栈指针、事件列表项等
- 分配并初始化栈空间
	- 如果是 `xTaskCreate()`，栈在堆中分配；
	- 如果是 `xTaskCreateStatic()`，栈由用户提供。
- 在栈里构建“初始任务上下文”
	- 把任务入口函数指针（任务代码）、任务参数、初始的 CPU 寄存器值、返回地址等都按架构要求压入栈，  这样当任务第一次被调度时，任务切换代码只需恢复这些寄存器，就能像从中断返回一样开始执行任务函数。
- 把任务添加到就绪列表
	- 一旦调度器运行，该任务就可能被调度执行。

```c
xTaskCreate() →
  ├── 分配栈内存 [StackType_t usStackDepth]
  ├── 分配TCB结构体 [TCB_t]
  │     ├─ 保存任务名、优先级
  │     ├─ 保存栈指针(pxStack)
  │     ├─ 保存栈顶(pxTopOfStack)
  │     └─ 状态信息
  ├── 初始化栈内容（任务入口、参数、寄存器值…）
  └── 返回TCB指针给*pxCreatedTask（任务句柄）

```

## 示例 1: 创建任务


> [!question] ( [[FreeRTOS完全开发手册之上册_快速入门.pdf#page=38&selection=0,0,6,30&color=note|📖]] )依次创建 Task1、Task2 为何 Task2 先运行?
> 要分析 `xTaskCreate` 的代码才能知道原因：
> 
> ```c
> ...
> if (xSchedulerRunning == pdFALSE)
> {
> 	if (pxCurrentTCB->uxPriority <= pxNewTCB->uxpriority)
> 	{
> 		pxCurrentTCB = pxNewTCB;
> 	}
> 	else
> 	{
> 		mtCOVERAGE_TEST_MARKER
> 	}
> }
> else
> ...
> ```
> 
> - 更高优先级的
> - 或者后面创建的任务先运行。
> - 如果任务优先级都为 0 的话，空闲任务会影响任务的优先执行顺序



对应程序：`06_freertos_example_createtaskstatic`

## 示例 2: 使用任务参数

( [[FreeRTOS完全开发手册之上册_快速入门.pdf#page=38&selection=39,0,41,14&color=note|📖]])
我们说过，多个任务可以使用同一个函数，怎么体现它们的差别？
- 栈不同
- 创建任务时可以传入不同的参数

## 任务的删除

删除任务时使用的函数如下：

```c
void vTaskDelete( TaskHandle_t xTaskToDelete )
```

参数说明：

| 参数           | 描述                                                           |
| ------------ | ------------------------------------------------------------ |
| `pvTaskCode` | 任务句柄，使用 `xTaskCreate` 创建任务时可以得到一个句柄。<br>也可传入 `NULL`，这表示删除自己。 |

## 示例 3: 删除任务

( [[FreeRTOS完全开发手册之上册_快速入门.pdf#page=42&selection=0,0,12,34&color=note|📖]])
在任务1的函数中，如果不调用 `vTaskDelay`，则 Idle 任务用于没有机会执行，它就无法释放创建任务2是分配的内存。
而任务1在不断地创建任务，不断地消耗内存，最终内存耗尽再也无法创建新的任务。

# 任务优先级和 Tick

## 任务优先级

优先级的取值范围是：0~(`configMAX_PRIORITIES` – 1)，数值越大优先级越高。

( [[FreeRTOS完全开发手册之上册_快速入门.pdf#page=43&selection=14,0,21,8&color=note|📖]])
FreeRTOS的调度器可以使用2种方法来快速找出优先级最高的、可以运行的任务。使用不同的方法时， `configMAX_PRIORITIES` 的取值有所不同。

## Tick

如下图：
- 假设t1、t2、t3发生时钟中断
- 两次中断之间的时间被称为时间片(time slice、tick period)
- 时间片的长度由 `configTICK_RATE_HZ` 决定，假设 `configTICK_RATE_HZ` 为100 ，那么时间片长度就是10ms

![[FreeRTOS完全开发手册之上册_快速入门.pdf#page=44&rect=64,680,524,823&color=note|📖]]

---

相同优先级的任务怎么切换呢？请看下图：
- 任务 2 从 t1 执行到 t2
- 在t2发生tick中断，进入tick中断处理函数：
	- 选择下一个要运行的任务
	- 执行完中断处理函数后，切换到新的任务：任务1
- 任务1从t2执行到t3
- 从图中可以看出，任务运行的时间并不是严格从t1,t2,t3哪里开始

![[FreeRTOS完全开发手册之上册_快速入门.pdf#page=44&rect=64,181,509,539&color=note|📖]]

---

有了 Tick 的概念后，我们就可以使用 Tick 来衡量时间了，比如：

```c
vTaskDelay(2); // 等待2个Tick，假设configTICK_RATE_HZ=100, Tick周期时10ms, 等待20ms 

// 还可以使用pdMS_TO_TICKS宏把ms转换为tick
vTaskDelay(pdMS_TO_TICKS(100)); // 等待100ms
```

---

注意，基于 Tick 实现的延时并不精确，比如 `vTaskDelay(2)` 的本意是延迟 2 个 Tick 周期，有可能经过 1 个 Tick 多一点就返回了。

![[FreeRTOS完全开发手册之上册_快速入门.pdf#page=45&rect=73,631,524,758&color=note|📖]]

使用 `vTaskDelay` 函数时，建议以 ms 为单位，使用 `pdMS_TO_TICKS` 把时间转换为 Tick。

这样的代码就与 `configTICK_RATE_HZ` 无关，即使配置项 `configTICK_RATE_HZ` 改变了，我们也不用去修改代码。

## 示例 4: 优先级实验

对应程序：`07_freertos_example_test`

## 示例 5: 修改优先级

使用 `uxTaskPriorityGet` 来获得任务的优先级：

```c
UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask );
```

使用参数 `xTask` 来指定任务，设置为 NULL 表示获取自己的优先级。

---

使用 `vTaskPrioritySet` 来设置任务的优先级：

```c
void vTaskPrioritySet	(TaskHandle_t xTask,
						UBaseType_t uxNewPriority);
```

使用参数 `xTask` 来指定任务，设置为 `NULL` 表示设置自己的优先级；
参数 `uxNewPriority` 表示新的优先级，取值范围是 0~(`configMAX_PRIORITIES` – 1)。

# 任务状态

- 运行(Running)
- 非运行
	- **阻塞状态(Blocked)**
	- **暂停状态(Suspended)**
		- 主动休息
		- 被动休息
	- **就绪状态(Ready)**
		- 就绪态的任务，可以被调度器挑选出来切换为运行状态，调度器永远都是挑选最高优先级的就绪态任务并让它进入运行状态。

## 阻塞状态(Blocked)

在实际产品中，我们不会让一个任务一直运行，而是使用"事件驱动"的方法让它运行：
- 任务要等待某个事件，事件发生后它才能运行
- 在等待事件过程中，它不消耗CPU资源
- 在等待事件的过程中，这个任务就处于阻塞状态(Blocked)

在阻塞状态的任务，它可以等待两种类型的事件：
- 时间相关的事件
	- 可以等待一段时间：我等2分钟
	- 也可以一直等待，直到某个绝对时间：我等到下午3点
- 同步事件：这事件由别的任务，或者是中断程序产生
	- 例子1：任务A等待任务B给它发送数据
	- 例子2：任务A等待用户按下按键
	- 同步事件的来源有很多
		- 队列(queue)
		- 二进制信号量(binary semaphores)
		- 计数信号量(counting semaphores)
		- 互斥量(mutexes)
		- 递归互斥量、递归锁(recursive mutexes)
		- 事件组(event groups)
		- 任务通知(task notifications)

在等待一个同步事件时，可以加上超时时间。比如等待队里数据，超时时间设为 10ms：
- 10ms之内有数据到来：成功返回
- 10ms到了，还是没有数据：超时返回

## 暂停状态(Suspended)

FreeRTOS 中的任务也可以进入暂停状态，唯一的方法是通过 `vTaskSuspend` 函数。函数原型如下：

```c
void vTaskSuspend( TaskHandle_t xTaskToSuspend );
```

参数 `xTaskToSuspend` 表示要暂停的任务，如果为 `NULL`，表示暂停自己。

要退出暂停状态，只能由别人来操作：
- 别的任务调用：`vTaskResume`
- 中断程序调用：`xTaskResumeFromISR`

实际开发中，暂停状态用得不多。

## 就绪状态(Ready)

这个任务完全准备好了，随时可以运行：只是还轮不到它。这时，它就处于就绪态(Ready)。

## 完整的状态转换图

![[FreeRTOS完全开发手册之上册_快速入门.pdf#page=52&rect=68,270,508,816&color=note|📖|462]]

怎么管理不同状态的任务：放在不同 **链表** 里

# Delay 函数

## 两个 Delay 函数

有两个 Delay 函数：
- `vTaskDelay`：至少等待指定个数的 Tick Interrupt 才能变为就绪状态
- `vTaskDelayUntil`：等待到指定的绝对时刻，才能变为就绪态。
	* 老版本，没有返回值

这 2 个函数原型如下：

```c
void vTaskDelay( const TickType_t xTicksToDelay ); /* xTicksToDelay: 等待多少给 Tick */

/* pxPreviousWakeTime: 上一次被唤醒的时间
 * xTimeIncrement: 要阻塞到(pxPreviousWakeTime + xTimeIncrement)
 * 单位都是Tick Count
 */
 
BaseType_t xTaskDelayUntil 	(TickType_t * const pxPreviousWakeTime,
							const TickType_t xTimeIncrement);
```

下面画图说明：
- 使用 `vTaskDelay(n)` 时，进入、退出 `vTaskDelay` 的时间间隔至少是n个Tick中断
- 使用 `xTaskDelayUntil(&Pre, n)` 时，前后两次退出 `xTaskDelayUntil` 的时间至少是n个Tick中断
	- 退出 `xTaskDelayUntil` 时任务就进入的就绪状态，一般都能得到执行机会
	- 所以可以使用 `xTaskDelayUntil` 来让任务周期性地运行
	- 返回 `pdTRUE` 表示确实延迟了，返回 `pdFALSE` 表示没有发生延迟 (因为延迟的时间点早就过了)
- ![[FreeRTOS完全开发手册之上册_快速入门.pdf#page=53&rect=74,149,528,385&color=note|📖]]
- `vTaskDelay()`是 ​**​“延迟多久”​**​ （相对时间，容易产生周期误差），而 `xTaskDelayUntil()`是 ​**​“延迟到什么时候”​**​ （绝对时间，能实现精准的周期性执行）。想做精确的定时任务，比如每10ms采集一次数据，就用 `xTaskDelayUntil()`。

## 示例 6: Delay

对应程序：`08_freertos_example_task_status`
对应程序：`09_freertos_example_delay`

# 空闲任务及其钩子函数

对应程序：`10_freertos_example_idletask`，在 `05_freertos_example_createtask` 基础上修改

## 介绍

* 任务后的清理工作在哪执行？分两类：
	* 非自杀的任务：在 `vTaskDelete` 内部完成清理工作 (凶手执行清理工作)
	* 自杀的任务：在**空闲任务**中完成清理工作，比如释放内存 (都自杀了，怎么清理自己的尸体? 由别人来做)

除了释放被删除的任务的内存之外，为什么必须要有空闲任务？一个良好的程序，它的任务都是事件驱动的：平时大部分时间处于阻塞状态。有可能我们自己创建的所有任务都无法执行，但是调度器必须能找到一个可以运行的任务：所以，我们要提供空闲任务。在使用 `vTaskStartScheduler()` 函数来创建、启动调度器时，这个函数内部会创建空闲任务：
- 空闲任务优先级为0：它不能阻碍用户任务运行
- 空闲任务要么处于就绪态，要么处于运行态，永远不会阻塞

空闲任务的优先级为 0，这意味着一旦某个用户的任务变为就绪态，那么空闲任务马上被切换出去，让这个用户任务运行。在这种情况下，我们说用户任务"抢占"(pre-empt)了空闲任务，这是由调度器实现的。

---

我们可以添加一个空闲任务的 **钩子函数(Idle Task Hook Functions)** ，空闲任务的循环每执行一次，就会调用一次钩子函数。钩子函数的作用有这些：
- 执行一些低优先级的、后台的、需要连续执行的函数
- 测量系统的空闲时间：空闲任务能被执行就意味着所有的高优先级任务都停止了，所以测量空闲任务占据的时间，就可以算出处理器占用率。
- 让系统进入省电模式：空闲任务能被执行就意味着没有重要的事情要做，当然可以进入省电模式了。

空闲任务的钩子函数的限制：
- 不能导致空闲任务进入阻塞状态、暂停状态
- 如果你会使用 `vTaskDelete()` 来删除任务，那么钩子函数要非常高效地执行。如果空闲任务移植卡在钩子函数里的话，它就无法释放内存。

## 使用钩子函数的前提

![[FreeRTOS完全开发手册之上册_快速入门.pdf#page=57&rect=58,672,521,813&color=note|📖]]

# 调度算法

对应程序：`11_freertos_example_scheduler` 

## 重要概念

正在运行的任务，被称为"**正在使用处理器**"，它处于运行状态。在单处理系统中，任何时间里只能有一个任务处于运行状态。

非运行状态的任务，它处于这 3 中状态之一：
- 阻塞(Blocked)
- 暂停(Suspended)
- 就绪(Ready)
	- 就绪态的任务，可以被调度器挑选出来切换为运行状态，调度器永远都是挑选最高优先级的就绪态任务并让它进入运行状态。

阻塞状态的任务，它在等待"事件"，当事件发生时任务就会进入就绪状态。事件分为两类：
1. **时间**相关的事件
	- 所谓时间相关的事件，就是设置超时时间：在指定时间内阻塞，时间到了就进入就绪状态。
	- 使用时间相关的事件，可以实现周期性的功能、可以实现超时功能。
2. **同步**事件。
	- 同步事件就是：某个任务在等待某些信息，别的任务或者中断服务程序会给它发送信息。
	- 怎么"发送信息"？方法很多，有：
		- 任务通知(task notification)
		- 队列(queue)
		- 事件组(event group)
		- 信号量(semaphore)
		- 互斥量(mutex)等。
		- 这些方法用来发送同步信息，比如表示某个外设得到了数据。

## 配置调度算法

所谓调度算法，就是怎么确定哪个就绪态的任务可以切换为运行状态。

通过配置文件 `FreeRTOSConfig.h` 的两个配置项来配置调度算法：`configUSE_PREEMPTION`、 `configUSE_TIME_SLICING`。

还有第三个配置项：`configUSE_TICKLESS_IDLE`，它是一个高级选项，用于关闭 Tick 中断来实现省电， 后续单独讲解。现在我们假设 `configUSE_TICKLESS_IDLE` 被设为 0，先不使用这个功能。

调度算法的行为主要体现在两方面：高优先级的任务先运行、同优先级的就绪态任务如何被选中。调度算法要确保同优先级的就绪态任务，能"轮流"运行，策略是"轮转调度"(Round Robin Scheduling)。轮转调度并不保证任务的运行时间是公平分配的，我们还可以细化时间的分配方法。

从 3 个角度统一理解多种调度算法：
- 可否抢占？高优先级的任务能否优先执行(配置项: `configUSE_PREEMPTION`)
	- 可以：被称作"可抢占调度"(Pre-emptive)，高优先级的就绪任务马上执行，下面再细化。
	- 不可以：不能抢就只能协商了，被称作"合作调度模式"(Co-operative Scheduling)
		- 当前任务执行时，更高优先级的任务就绪了也不能马上运行，只能等待当前任务主动让出 CPU 资源。
		- 其他同优先级的任务也只能等待：更高优先级的任务都不能抢占，平级的更应该老实点
- 可抢占的前提下，同优先级的任务是否轮流执行(配置项：`configUSE_TIME_SLICING`)
	- 轮流执行：被称为"时间片轮转"(Time Slicing)，同优先级的任务轮流执行，你执行一个时间片、我再执行一个时间片
	- 不轮流执行：英文为"without Time Slicing"，当前任务会一直执行，直到主动放弃、或者被高优先级任务抢占
- 在"可抢占"+"时间片轮转"的前提下，进一步细化：空闲任务是否让步于用户任务(配置项： `configIDLE_SHOULD_YIELD`)
	- 空闲任务低人一等，每执行一次循环，就看看是否主动让位给用户任务
	- 空闲任务跟用户任务一样，大家轮流执行，没有谁更特殊

列表如下：

| 配置项                       | A   | B   | C   | D   | E    |
| ------------------------- | --- | --- | --- | --- | ---- |
| `configUSE_PREEMPTION`    | 1   | 1   | 1   | 1   | 0    |
| `configUSE_TIME_SLICING`  | 1   | 1   | 0   | 0   | x    |
| `configIDLE_SHOULD_YIELD` | 1   | 0   | 1   | 0   | x    |
| 说明                        | 常用  | 很少用 | 很少用 | 很少用 | 几乎不用 |

注：  
- A：可抢占 + 时间片轮转 + 空闲任务让步  
- B：可抢占 + 时间片轮转 + 空闲任务不让步  
- C：可抢占 + 非时间片轮转 + 空闲任务让步  
- D：可抢占 + 非时间片轮转 + 空闲任务不让步  
- E：合作调度

## 示例 7: 调度

( [[FreeRTOS完全开发手册之上册_快速入门.pdf#page=59&selection=93,0,96,2&color=note|📖]])
示例7: 调度

## 对比效果：抢占与否

( [[FreeRTOS完全开发手册之上册_快速入门.pdf#page=61&selection=3,1,7,4&color=note|📖]])
对比效果: 抢占与否

## 对比效果：时间片轮转与否

( [[FreeRTOS完全开发手册之上册_快速入门.pdf#page=62&selection=2,0,5,7&color=note|📖]])
对比效果: 时间片轮转与否

## 对比效果: 空闲任务让步

( [[FreeRTOS完全开发手册之上册_快速入门.pdf#page=63&selection=12,0,15,6&color=note|📖]])
对比效果: 空闲任务让步

# 通过链表深入理解调度机制

- **抢占**：高优先级的任务，优先执行，可以抢占低优先级的任务；高优先级的任务不停止，低优先级的任务永远无法执行
- **时间片轮转**：同等优先级的任务，轮流执行
- 空闲任务礼让：如果有同时优先级为 0 的其他就绪任务，空闲任务主动放弃一次运行机会

---

FreeRTOS 的调度机制依赖几个核心链表来管理任务的状态和优先级调度。这些链表包括：

- **Ready lists**：这是一个优先级数组（通常命名为 `pxReadyTasksLists`），每个优先级对应一个链表，用于存储处于就绪（Ready）状态的任务。这些任务已准备好运行，但当前可能被更高优先级的任务或调度器占用。调度器总是从最高优先级的非空 Ready list 中选择任务执行。
- **Pending ready list**：这是一个临时链表（通常命名为 `xPendingReadyList`），用于处理中断服务例程（ISR）中唤醒的任务。在 ISR 上下文中，不能直接修改 Ready lists（以避免竞争条件），因此将这些任务先放入 Pending ready list。随后，在任务切换或 tick 中断结束时，这些任务会被转移到相应的 Ready list 中，确保安全性和原子性。
- **Delayed lists**：这些链表用于管理处于阻塞（Blocked）状态的任务，特别是那些通过 `vTaskDelay()` 或 `vTaskDelayUntil()` 等 API 延迟的任务。FreeRTOS 设计了两个 Delayed lists（内部实现为 `xDelayedTaskList1` 和 `xDelayedTaskList2`），通过指针 pxDelayedTaskList（指向当前 Delayed list）和 pxOverflowDelayedTaskList（指向 Overflow Delayed list）来访问和管理。

## 为什么 Delayed lists 设计成两个？

FreeRTOS 的 tick 计数器（xTickCount）是一个无符号整数（通常 32 位或 16 位，取决于配置），它会周期性地溢出（wrap around，例如从最大值回绕到 0）。为了高效处理任务的唤醒时间（wake time）并避免在溢出时丢失或错误处理任务，系统使用两个 Delayed lists：

- **当前 Delayed list**（pxDelayedTaskList 指向的列表）：存储唤醒时间在 tick 计数器下次溢出前的任务。这些任务按唤醒时间排序，并在每个 tick 中断中检查列表头部：如果任务的唤醒时间 ≤ 当前 tick 值，则将其移到 Ready list 中激活。
- **Overflow Delayed list**（pxOverflowDelayedTaskList 指向的列表）：存储唤醒时间在 tick 计数器下次溢出后的任务。这些任务的唤醒时间在数学上小于当前 tick（由于环绕），但实际应在未来处理。

当一个任务被延迟时，FreeRTOS 计算其绝对唤醒时间（当前 tick + 延迟 ticks）。如果唤醒时间导致溢出（即唤醒时间 < 当前 tick，但实际在未来），则插入 Overflow list；否则插入当前 Delayed list。

在 tick 计数器溢出时（检测到 xTickCount 回绕），系统交换两个列表的指针：原来的 Overflow list 成为新的当前 Delayed list（现在包含了“未来”的任务），而原来的当前 Delayed list 变为 Overflow list（通常为空或仅剩远期任务）。这种交换机制确保：

- 避免复杂的 signed 时间比较或额外计算开销。
- 任务不会因 tick 溢出而被错误唤醒或遗漏。
- 列表保持有序，提高 tick 中断的效率（只需检查列表头部，而非遍历整个列表）。

这种设计在资源受限的嵌入式系统中特别高效，避免了在每个 tick 中进行昂贵的操作。