---
tags:
  - ARM
  - Assembly
  - Disassembly
  - MachineCode
  - Compiler
  - C
---

# [进制](../../02_A/C/进制.md)

# [字节序](../../02_A/C/字节序.md)

# [位操作](../../02_A/C/位操作.md)

# 从 C 语言到机器码：汇编与反汇编

## 1. 概念：人、编译器与 CPU 的语言

从我们编写代码到 CPU 执行，存在一个语言翻译的层级：

*   **C 语言 (高级语言)**：为方便程序员开发而设计，接近人类逻辑。
*   **汇编语言 (Assembly)**：机器指令的“助记符”，用易于记忆的单词（如 `MOV`, `LDR`）代替纯数字的机器码，是理解 C 语言底层行为和进行性能优化的关键。
*   **机器码 (Machine Code)**：CPU 能直接理解和执行的二进制指令。

它们之间的转换关系是：`C 代码` -> `汇编代码` -> `机器码`。

## 2. 核心过程：编译、汇编与反汇编

我们的代码（如 `start.S` 和 `main.c`）通过一个工具链转变为可执行程序，主要步骤如下：

![](attachments/11_C与汇编_ARM底层编程与启动过程/file-20251120225700941.png)

*   **编译 (Compile)**：编译器（如 GCC）将 C 语言代码翻译成汇编代码。
*   **汇编 (Assemble)**：汇编器将汇编代码转换成包含机器码的目标文件（`.o` 文件）。
*   **链接 (Link)**：链接器将多个目标文件和库文件合并成一个最终的可执行文件（如 `.elf` 或 `.axf`）。
*   **反汇编 (Disassemble)**：一个逆向过程，可以将可执行文件中的机器码“翻译”回汇编代码，方便我们分析和调试程序。

## 3. 实践：如何获取反汇编代码

### 在 KEIL 中

在项目设置的 "User" 选项卡中，添加以下命令，编译后即可生成反汇编文件 `led.dis`。

```
fromelf --text -a -c --output=led.dis Objects\led_c.axf
```

![](attachments/11_C与汇编_ARM底层编程与启动过程/file-20251120225700940.png)

### 使用 GCC 工具链

在 `Makefile` 中，通常使用 `objdump` 工具来生成反汇编文件。

```
$(OBJDUMP) -D -m arm led.elf > led.dis	# OBJDUMP 通常是 arm-linux-gnueabihf-objdump
```

## 4. 实例分析：从汇编代码看机器码

通过反汇编，我们可以看到高级语言或汇编伪指令最终对应的真实机器码和汇编指令。下面是不同 ARM 芯片对 `LDR SP, =address` 这条伪指令的实现。

第一列是地址，第二列是机器码，第三列是汇编指令。

### 4.1 STM32F103 (Cortex-M) 反汇编

![](attachments/11_C与汇编_ARM底层编程与启动过程/file-20251120225700939.png)

### 4.2 STM32MP157 (Cortex-A) 反汇编

![](attachments/11_C与汇编_ARM底层编程与启动过程/file-20251120225700938%201.png)

### 4.3 IMX6ULL (Cortex-A) 反汇编

![](attachments/11_C与汇编_ARM底层编程与启动过程/file-20251120225700939%201.png)

## 5. 深入一步：伪指令与流水线

参考资料： ![ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition, p.410](attachments/ARM%20ArchitectureReference%20Manual%20ARMv7-A%20and%20ARMv7-R%20edition.pdf#page=410&rect=136,389,514,675)

你可能已经注意到，简单的 `LDR` 伪指令被转换成了 `MOV` 或者 `LDR PC, [PC, #offset]` 这样的指令。这是为什么呢？

*   **指令集编码不同**：不同的 ARM 处理器系列使用不同的指令集编码。
    *   **Thumb-2 (Cortex-M)**：指令长度可以是 16 位或 32 位，编码更紧凑。
        ![](attachments/11_C与汇编_ARM底层编程与启动过程/file-20251120225700938.png)
    *   **ARM (Cortex-A)**：指令长度通常是 32 位。
        ![](attachments/11_C与汇编_ARM底层编程与启动过程/file-20251120225700937.png)
*   **PC 相对寻址**：`LDR` 伪指令通常被实现为 PC 相对寻址，即从当前程序计数器 (PC) 的位置加上一个偏移量来加载数据。
*   **流水线 (Pipeline)**：ARM 处理器使用流水线技术来提升效率。这意味着在执行当前指令时，CPU 已经在预取和解码后续的指令。因此，PC 的值通常是**当前执行指令地址 + 4 (Thumb-2) 或 + 8 (ARM 指令集)**。这就是为什么反汇编代码中 `[PC, #offset]` 的计算基址不是当前指令地址的原因。
  ![ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition, p.45](attachments/ARM%20ArchitectureReference%20Manual%20ARMv7-A%20and%20ARMv7-R%20edition.pdf#page=45&rect=137,351,541,420)

# C 与汇编的交互与底层实现

C 语言和汇编语言的混合编程是嵌入式开发中的常见场景。理解它们之间的调用规则、数据传递方式以及程序的启动过程，是深入掌握底层开发的关键。

## 1. 函数调用约定 (ATPCS)

为了让 C 语言和汇编语言能够相互“理解”并正确调用，ARM 定义了一套规则，称为 **ATPCS (ARM-Thumb Procedure Call Standard)**，即 ARM-Thumb 过程调用标准。这套规则约定了函数调用时寄存器的使用方法。

### 1.1 参数传递与返回值

-   **参数传递**：当函数参数少于或等于 4 个时，使用 `R0` - `R3` 这四个寄存器来传递。
    -   `R0` 用于传递第 1 个参数。
    -   `R1` 用于传递第 2 个参数，以此类推。
-   **返回值**：函数的返回值（如果小于 32 位）通常存储在 `R0` 寄存器中。

### 1.2 寄存器使用规则

![](attachments/11_C与汇编_ARM底层编程与启动过程/file-20251120225700936.png)

-   **R4 - R11**：这些寄存器在函数调用前后必须保持不变。如果被调用的函数需要使用这些寄存器，它必须在函数入口处将它们的初始值**入栈 (Push)** 保存，并在函数退出前**出栈 (Pop)** 恢复。这些寄存器也被称为“被调用者保存的寄存器”(Callee-saved registers)。

## 2. 汇编调用 C 函数示例

遵循 ATPCS 规则，我们可以轻易地在汇编代码中调用 C 函数。

**C 函数原型：**
```c
int delay(unsigned int d)
{
    while (d--);
    return 0;
}
```

**汇编调用代码：**
```arm
; 调用 C 函数 delay(1000000)
ldr  r0, =1000000   ; 1. 将第一个参数 1000000 放入 R0
bl delay            ; 2. 跳转到 delay 函数执行。bl 指令会自动将返回地址存入 LR 寄存器

; 函数返回后，可以检查返回值
cmp r0, #0          ; 3. delay 函数的返回值已保存在 R0 中，这里将其与 0 比较
```

## 3. C 函数的底层视角：反汇编分析

通过反汇编，我们可以观察到 C 语言在底层是如何运作的，并理解栈（Stack）的关键作用。

### 3.1 栈 (Stack) 的核心作用

在函数调用过程中，栈主要用于：
1.  **保存上下文**：保存返回地址（`LR` 寄存器），以及需要在函数调用前后保持不变的寄存器（如 `R4`-`R11`）。
2.  **存储局部变量**：函数内部定义的非静态局部变量通常分配在栈上。
3.  **传递额外参数**：当函数参数超过 4 个时，多余的参数会通过栈来传递。

### 3.2 启动代码分析

下图是典型的 Cortex-M 微控制器启动代码 `Reset_Handler` 的反汇编视图。

![](attachments/11_C与汇编_ARM底层编程与启动过程/file-20251120225700932.png)

这段代码是 MCU 上电后执行的第一段程序，主要负责：
1.  **关闭所有中断** (`cpsid i`)，防止在初始化过程中被意外打断。
2.  **设置向量表偏移** (`ldr r0, =0xE000ED08`, `ldr r1, =0x08000000`, `str r1, [r0]`)，告诉 CPU 中断向量表位于 Flash 的起始地址。
3.  **调用 `SystemInit`** (`bl SystemInit`)，这是由芯片厂商提供的库函数，用于初始化时钟等系统关键配置。
4.  **调用 `main` 函数** (`bl main`)，跳转到我们熟悉的 C 语言主函数，开始执行用户程序。

## 4. 物理内存与启动流程

### 4.1 Flash 内存布局

程序最终被烧写到 Flash 中，形成二进制的机器码。其内容与反汇编代码一一对应。

| 地址 | Flash 内容 | 对应指令（部分） |
| :--- | :--- | :--- |
| `0x08000000` | `20010000` | 栈顶地址 (Initial SP) |
| `0x08000004` | `08000185` | 复位向量 (Reset_Handler Address) |
| ... | ... | ... |
| `0x08000184` | `f000 f8df` | `Reset_Handler` 的第一条指令 |

*注意：上表中的值是示例，实际内容取决于具体程序。*

### 4.2 Cortex-M 启动过程

对于 103 来说， 上电复位后，CPU 的硬件逻辑会自动执行以下步骤：
1.  **设置栈指针 (SP)**：CPU 从地址 `0x08000000` 处取出值，并将其加载到 SP 寄存器。
2.  **获取复位向量**：CPU 从地址 `0x08000004` 处取出 `Reset_Handler` 的地址。
3.  **跳转执行**：CPU 跳转到 `Reset_Handler` 的地址开始执行代码。
    -   对于 Cortex-M 系列，CPU 只支持 **Thumb 状态**，因此要求向量地址的最低位（BIT0）必须为 1，以标识这是一个 Thumb 指令地址。这就是为什么 `0x08000004` 处的值通常是 `Reset_Handler` 实际地址 `+1` 的原因。

## 5. 课后作业

-   编写一个纯汇编程序，实现点灯。
-   编写一个 C 程序，实现用按钮控制 LED。