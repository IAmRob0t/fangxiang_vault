---
tags:
  - ARM
  - Assembly
  - Disassembly
  - MachineCode
  - Compiler
  - C
---

# [进制](../../02_A/C/进制.md)

# [字节序](../../02_A/C/字节序.md)

# [位操作](../../02_A/C/位操作.md)

# 从 C 语言到机器码：汇编与反汇编

## 1. 概念：人、编译器与 CPU 的语言

从我们编写代码到 CPU 执行，存在一个语言翻译的层级：

*   **C 语言 (高级语言)**：为方便程序员开发而设计，接近人类逻辑。
*   **汇编语言 (Assembly)**：机器指令的“助记符”，用易于记忆的单词（如 `MOV`, `LDR`）代替纯数字的机器码，是理解 C 语言底层行为和进行性能优化的关键。
*   **机器码 (Machine Code)**：CPU 能直接理解和执行的二进制指令。

它们之间的转换关系是：`C 代码` -> `汇编代码` -> `机器码`。

## 2. 核心过程：编译、汇编与反汇编

我们的代码（如 `start.S` 和 `main.c`）通过一个工具链转变为可执行程序，主要步骤如下：

![](attachments/11_编程知识/file-20251119160008419.png)

*   **编译 (Compile)**：编译器（如 GCC）将 C 语言代码翻译成汇编代码。
*   **汇编 (Assemble)**：汇编器将汇编代码转换成包含机器码的目标文件（`.o` 文件）。
*   **链接 (Link)**：链接器将多个目标文件和库文件合并成一个最终的可执行文件（如 `.elf` 或 `.axf`）。
*   **反汇编 (Disassemble)**：一个逆向过程，可以将可执行文件中的机器码“翻译”回汇编代码，方便我们分析和调试程序。

## 3. 实践：如何获取反汇编代码

### 在 KEIL 中

在项目设置的 "User" 选项卡中，添加以下命令，编译后即可生成反汇编文件 `led.dis`。

```
fromelf --text -a -c --output=led.dis Objects\led_c.axf
```

![](attachments/11_编程知识/file-20251119160008418%201.png)

### 使用 GCC 工具链

在 `Makefile` 中，通常使用 `objdump` 工具来生成反汇编文件。

```
$(OBJDUMP) -D -m arm led.elf > led.dis	# OBJDUMP 通常是 arm-linux-gnueabihf-objdump
```

## 4. 实例分析：从汇编代码看机器码

通过反汇编，我们可以看到高级语言或汇编伪指令最终对应的真实机器码和汇编指令。下面是不同 ARM 芯片对 `LDR SP, =address` 这条伪指令的实现。

第一列是地址，第二列是机器码，第三列是汇编指令。

### 4.1 STM32F103 (Cortex-M) 反汇编

![](attachments/11_编程知识/file-20251119160008418.png)

### 4.2 STM32MP157 (Cortex-A) 反汇编

![](attachments/11_编程知识/file-20251119160008417%201.png)

### 4.3 IMX6ULL (Cortex-A) 反汇编

![](attachments/11_编程知识/file-20251119160008416.png)

## 5. 深入一步：伪指令与流水线

你可能已经注意到，简单的 `LDR` 伪指令被转换成了 `MOV` 或者 `LDR PC, [PC, #offset]` 这样的指令。这是为什么呢？

*   **指令集编码不同**：不同的 ARM 处理器系列使用不同的指令集编码。
    *   **Thumb-2 (Cortex-M)**：指令长度可以是 16 位或 32 位，编码更紧凑。
        ![](attachments/11_编程知识/file-20251119160008413.png)
    *   **ARM (Cortex-A)**：指令长度通常是 32 位。
        ![](attachments/11_编程知识/file-20251119160008417.png)
*   **PC 相对寻址**：`LDR` 伪指令通常被实现为 PC 相对寻址，即从当前程序计数器 (PC) 的位置加上一个偏移量来加载数据。
*   **流水线 (Pipeline)**：ARM 处理器使用流水线技术来提升效率。这意味着在执行当前指令时，CPU 已经在预取和解码后续的指令。因此，PC 的值通常是**当前执行指令地址 + 4 (Thumb-2) 或 + 8 (ARM 指令集)**。这就是为什么反汇编代码中 `[PC, #offset]` 的计算基址不是当前指令地址的原因。