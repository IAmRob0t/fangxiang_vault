---
tags:
  - ARM
  - Assembly
  - Disassembly
  - MachineCode
  - Compiler
  - C
---

# [进制](../../02_A/C/进制.md)

# [字节序](../../02_A/C/字节序.md)

# [位操作](../../02_A/C/位操作.md)

# 从 C 语言到机器码：汇编与反汇编

## 1. 概念：人、编译器与 CPU 的语言

从我们编写代码到 CPU 执行，存在一个语言翻译的层级：

*   **C 语言 (高级语言)**：为方便程序员开发而设计，接近人类逻辑。
*   **汇编语言 (Assembly)**：机器指令的“助记符”，用易于记忆的单词（如 `MOV`, `LDR`）代替纯数字的机器码，是理解 C 语言底层行为和进行性能优化的关键。
*   **机器码 (Machine Code)**：CPU 能直接理解和执行的二进制指令。

它们之间的转换关系是：`C 代码` -> `汇编代码` -> `机器码`。

## 2. 核心过程：编译、汇编与反汇编

我们的代码（如 `start.S` 和 `main.c`）通过一个工具链转变为可执行程序，主要步骤如下：

![](attachments/11_编程知识/image-01.png)

*   **编译 (Compile)**：编译器（如 GCC）将 C 语言代码翻译成汇编代码。
*   **汇编 (Assemble)**：汇编器将汇编代码转换成包含机器码的目标文件（`.o` 文件）。
*   **链接 (Link)**：链接器将多个目标文件和库文件合并成一个最终的可执行文件（如 `.elf` 或 `.axf`）。
*   **反汇编 (Disassemble)**：一个逆向过程，可以将可执行文件中的机器码“翻译”回汇编代码，方便我们分析和调试程序。

## 3. 实践：如何获取反汇编代码

### 在 KEIL 中

在项目设置的 "User" 选项卡中，添加以下命令，编译后即可生成反汇编文件 `led.dis`。

```
fromelf --text -a -c --output=led.dis Objects\led_c.axf
```

![](attachments/11_编程知识/image-02.png)

### 使用 GCC 工具链

在 `Makefile` 中，通常使用 `objdump` 工具来生成反汇编文件。

```
$(OBJDUMP) -D -m arm led.elf > led.dis	# OBJDUMP 通常是 arm-linux-gnueabihf-objdump
```

## 4. 实例分析：从汇编代码看机器码

通过反汇编，我们可以看到高级语言或汇编伪指令最终对应的真实机器码和汇编指令。下面是不同 ARM 芯片对 `LDR SP, =address` 这条伪指令的实现。

第一列是地址，第二列是机器码，第三列是汇编指令。

### 4.1 STM32F103 (Cortex-M) 反汇编

![](attachments/11_编程知识/image-03.png)

### 4.2 STM32MP157 (Cortex-A) 反汇编

![](attachments/11_编程知识/image-04.png)

### 4.3 IMX6ULL (Cortex-A) 反汇编

![](attachments/11_编程知识/image-05.png)

## 5. 深入一步：伪指令与流水线

参考资料： ![ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition, p.410](01_P/ARM%20架构/attachments/ARM%20ArchitectureReference%20Manual%20ARMv7-A%20and%20ARMv7-R%20edition.pdf#page=410&rect=136,389,514,675)

你可能已经注意到，简单的 `LDR` 伪指令被转换成了 `MOV` 或者 `LDR PC, [PC, #offset]` 这样的指令。这是为什么呢？

*   **指令集编码不同**：不同的 ARM 处理器系列使用不同的指令集编码。
    *   **Thumb-2 (Cortex-M)**：指令长度可以是 16 位或 32 位，编码更紧凑。
        ![](attachments/11_编程知识/image-06.png)
    *   **ARM (Cortex-A)**：指令长度通常是 32 位。
        ![](attachments/11_编程知识/image-07.png)
*   **PC 相对寻址**：`LDR` 伪指令通常被实现为 PC 相对寻址，即从当前程序计数器 (PC) 的位置加上一个偏移量来加载数据。
*   **流水线 (Pipeline)**：ARM 处理器使用流水线技术来提升效率。这意味着在执行当前指令时，CPU 已经在预取和解码后续的指令。因此，PC 的值通常是**当前执行指令地址 + 4 (Thumb-2) 或 + 8 (ARM 指令集)**。这就是为什么反汇编代码中 `[PC, #offset]` 的计算基址不是当前指令地址的原因。
  ![ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition, p.45](01_P/ARM%20架构/attachments/ARM%20ArchitectureReference%20Manual%20ARMv7-A%20and%20ARMv7-R%20edition.pdf#page=45&rect=137,351,541,420)

# C 与汇编深入分析

## 1. 汇编怎么调用 C 函数

### 1.1 直接调用

```
bl main
```

### 1.2 想传参数怎么办？

在 arm 中有个 ATPCS 规则(ARM-THUMB procedure call standard（ARM-Thumb 过程调用标准）。
约定 r0-r15 寄存器的用途：

* r0-r3

  调用者和被调用者之间传参数

* r4-r11

  函数可能被使用，所以在函数的入口保存它们，在函数的出口恢复它们。
  
  ![](attachments/11_编程知识/image-08.png)

代码示例：

```c
int delay(unsigned int d)
{
	while (d--);
    return 0;
}
```

在汇编里调用 delay：

```
ldr  r0, =1000000   /* 给delay函数传参数，保存在r0里 */
bl delay
cmp r0, #0          /* 返回值保存在r0中 */
```



## 2. C 函数的反汇编码阅读

要解决这几个问题：

* 为什么调用 C 函数前要设置栈？栈的作用是？
* C 函数传参
* C 函数执行过程体验

## 3. Flash 上的内容

### 3.1 反汇编示例

![](attachments/11_编程知识/image-09.png)

### 3.2 烧写在 Flash 上的内容

| 地址       | Flash 内容 |
| ---------- | -------- |
| 0x08000000 | 00000000 |
| 0x08000004 | 08000009 |
| 0x08000008 | f8dfd004 |
| 0x0800000c | f000f80c |
| 0x08000010 | 20010000 |
| 0x08000014 | bf00b501 |
| 0x08000018 | 1e419800 |
| …… | …… |

### 3.3 启动流程

上电后：

* 设置栈：CPU 会从 0x08000000 读取值，用来设置 SP(我们的程序里再次设置了 SP)
* 跳转：CPU 从 0x08000004 得到地址值，根据它的 BIT0 切换为 ARM 状态或 Thumb 状态，然后跳转
  * 对于 cortex M3/M4，它只支持 Thumb 状态，所以 0x08000004 上的值 bit0 必定是 1
  * 0x08000004 上的值 = Reset_Handler + 1
* 从 Reset_Handler 继续执行

## 4.课后作业

* 编写一个纯汇编程序，实现点灯
* 编写一个 c 程序，实现用按钮控制 LED