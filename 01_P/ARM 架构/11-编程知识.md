---
tags:
---

# [进制](../../02_A/C/进制.md)

# [字节序](../../02_A/C/字节序.md)

# [位操作](../../02_A/C/位操作.md)

# 汇编_反汇编_机器码

## 1. 程序处理的 4 个步骤

我们的第 1 个 LED 程序涉及 2 个文件：start.S、main.c，它们的处理过程如下：

![](attachments/11-编程知识/001_4_steps.png)

我们想深入理解 ARM 架构，想深入理解汇编与 C，想深入理解栈的作用，想深入理解 C 语言的实质，
就必须把最终的可执行程序，反汇编后，阅读得到的汇编代码。

上述 4 个步骤的细节，在后面课程里再讲。
现在只需要理解“汇编”、“反汇编”的概念：

* 汇编
  汇编文件转换为目标文件(里面是机器码)。
* 反汇编
  可执行文件(目标文件，里面是机器码)，转换为汇编文件。

## 2. KEIL 下怎么反汇编

在 KEIL 的 User 选项中，如下图添加这两项：

```
fromelf  --bin  --output=led.bin  Objects\led_c.axf
fromelf  --text  -a -c  --output=led.dis  Objects\led_c.axf
```

然后重新编译，即可得到二进制文件 led.bin(以后会分析)、反汇编文件 led.dis。
如下图操作：

![](attachments/11-编程知识/002_keil_create_dis.png)

## 3. GCC 下反汇编

使用 GCC 工具链编译程序时，在 Makefile 中有这一句：

```
$(OBJDUMP) -D -m arm  led.elf  > led.dis	# OBJDUMP = arm-linux-gnueabihf-objdump
```

它就是把可执行程序 led.elf，反汇编，得到 led.dis。


## 4. 机器码与汇编

参考资料：
```
doc_and_source_for_mcu_mpu\通用资料\ARM:
    DDI0403E_B_armv7m_arm.pdf  P254  // cortex M3/M4
    ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition.pdf  P410  // cortex A7
```

前面介绍过伪指令，伪指令是实际不存在的 ARM 命令，编译器在编译时转换成存在的 ARM 指令。
我们代码中的 `ldr r1, =0x????????` 这条伪指令的真实指令是什么呢?
对于我们使用的 3 款板子，汇编代码如下(如果你的板子不是这 3 款之一，请灵活变通，知识是一样的)：

```
LDR SP, =(0x20000000+0x10000)   // STM32F103
ldr sp, =(0x80000000+0x100000)  // IMX6ULL
ldr sp, =0xc0000000 + 0x100000  // STM32MP157 A7
```

我们可以通过反汇编来查看, 只摘取前面一小段。

### 4.1 STM32F103 反汇编

我们只摘取前面一小段，第一列是地址，第二列是机器码，第三列是汇编：

![](attachments/11-编程知识/003_stm32f103_dis.png)

### 4.2 STM32MP157 反汇编

![](attachments/11-编程知识/004_stm32mp157_a7.png)

### 4.3 IMX6ULL 反汇编

![](attachments/11-编程知识/005_imx6ull_dis.png)

### 4.4 机器码与汇编示例

#### 4.4.1 Thumb/Thumb2 指令集

![](attachments/11-编程知识/006_thumb_encoding.png)

#### 4.4.2 ARM 指令集

![](attachments/11-编程知识/007_arm_encoding.png)

### 4.5 解析 LDR 伪指令

为什么 PC=当前指令+4 或 8？

* CORTEX M3/M4
  使用 Thumb2 指令集，一条指令是 16 位或 32 位。

* CORTEX A7

  默认使用 ARM 指令集，一条指令是 32 位的。

* 流水线

  ARM 指令采用流水线机制：

  * 当前执行地址 A 的指令，
  * 同时已经在对下一条指令进行译码
  * 同时已经在读取下下一条指令：PC = A +4 (Thumb/Thumb2 指令集)、PC = A + 8 (ARM 指令集)

### 4.5 总结

* C
  为了方便人类方便使用，发明的高级语言，要转换为汇编。

* 汇编
  为了解放人类的记忆，发明的“助记符”，不用去记各类机器码。

  最终要转换为机器码。
  
* 机器码

  给 CPU 使用

  


